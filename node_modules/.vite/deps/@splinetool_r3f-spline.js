import {
  AxesHelper,
  Box2,
  Box3,
  Box3Helper,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  BufferGeometryLoader,
  Camera,
  CameraHelper,
  Color,
  ConeGeometry,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CubicBezierCurve,
  CubicBezierCurve3,
  CurvePath,
  CylinderGeometry,
  DirectionalLight,
  DirectionalLightHelper,
  DodecahedronGeometry,
  EllipseCurve,
  Euler,
  EventDispatcher,
  FileLoader,
  Float16BufferAttribute,
  Float32BufferAttribute,
  Fog,
  Group,
  HemisphereLight,
  IcosahedronGeometry,
  LatheGeometry,
  Light,
  Line3,
  LineBasicMaterial,
  LineCurve,
  LineCurve3,
  LineSegments,
  LinearEncoding,
  Loader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  PointLightHelper,
  QuadraticBezierCurve,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderLib,
  ShaderMaterial,
  Shape,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  SplineCurve,
  SpotLight,
  SpotLightHelper,
  Texture,
  TorusKnotGeometry,
  Triangle,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  VideoTexture,
  sRGBEncoding,
  useGraph,
  useLoader
} from "./chunk-VGQHE5VF.js";
import "./chunk-YN3MIK7E.js";
import "./chunk-4EOJPDL2.js";

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeBufferGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeBufferAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeBufferAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  return new BufferAttribute(array, itemSize, normalized);
}

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.decodeDracoFile(buffer, onLoad).catch(onError);
    }, onProgress, onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const attribute = geometryData.attributes[i];
      const name = attribute.name;
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      geometry.setAttribute(name, new BufferAttribute(array, itemSize));
    }
    return geometry;
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn2 = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn2.substring(fn2.indexOf("{") + 1, fn2.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module2) => {
          const draco = module2.draco;
          const decoder = new draco.Decoder();
          const decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
          try {
            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoderBuffer);
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/@splinetool/loader/build/SplineLoader.js
var Bg = Object.create;
var Ul = Object.defineProperty;
var Dg = Object.getOwnPropertyDescriptor;
var Gg = Object.getOwnPropertyNames;
var Rg = Object.getPrototypeOf;
var Vg = Object.prototype.hasOwnProperty;
var Ls = (n, r) => () => (r || n((r = { exports: {} }).exports, r), r.exports);
var jg = (n, r) => {
  for (var e in r)
    Ul(n, e, { get: r[e], enumerable: true });
};
var Fg = (n, r, e, t) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let o of Gg(r))
      !Vg.call(n, o) && o !== e && Ul(n, o, { get: () => r[o], enumerable: !(t = Dg(r, o)) || t.enumerable });
  return n;
};
var Bs = (n, r, e) => (e = n != null ? Bg(Rg(n)) : {}, Fg(r || !n || !n.__esModule ? Ul(e, "default", { value: n, enumerable: true }) : e, n));
var Tm = Ls((xc, _m) => {
  (function(n, r) {
    typeof xc == "object" ? _m.exports = r() : typeof define == "function" && define.amd ? define(r) : n.Alea = r();
  })(xc, function() {
    "use strict";
    return n.importState = function(e) {
      var t = new n();
      return t.importState(e), t;
    }, n;
    function n() {
      return function(e) {
        var t = 0, o = 0, i = 0, s = 1;
        e.length == 0 && (e = [+/* @__PURE__ */ new Date()]);
        var l = r();
        t = l(" "), o = l(" "), i = l(" ");
        for (var c = 0; c < e.length; c++)
          t -= l(e[c]), t < 0 && (t += 1), o -= l(e[c]), o < 0 && (o += 1), i -= l(e[c]), i < 0 && (i += 1);
        l = null;
        var u = function() {
          var a = 2091639 * t + s * 23283064365386963e-26;
          return t = o, o = i, i = a - (s = a | 0);
        };
        return u.next = u, u.uint32 = function() {
          return u() * 4294967296;
        }, u.fract53 = function() {
          return u() + (u() * 2097152 | 0) * 11102230246251565e-32;
        }, u.version = "Alea 0.9", u.args = e, u.exportState = function() {
          return [t, o, i, s];
        }, u.importState = function(a) {
          t = +a[0] || 0, o = +a[1] || 0, i = +a[2] || 0, s = +a[3] || 0;
        }, u;
      }(Array.prototype.slice.call(arguments));
    }
    function r() {
      var e = 4022871197, t = function(o) {
        o = o.toString();
        for (var i = 0; i < o.length; i++) {
          e += o.charCodeAt(i);
          var s = 0.02519603282416938 * e;
          e = s >>> 0, s -= e, s *= e, e = s >>> 0, s -= e, e += s * 4294967296;
        }
        return (e >>> 0) * 23283064365386963e-26;
      };
      return t.version = "Mash 0.9", t;
    }
  });
});
var Cm = Ls((ja, Im) => {
  (function(n, r) {
    typeof ja == "object" && typeof Im < "u" ? r(ja) : typeof define == "function" && define.amd ? define(["exports"], r) : r((n = typeof globalThis < "u" ? globalThis : n || self).SVDJS = {});
  })(ja, function(n) {
    "use strict";
    n.SVD = function(r, e, t, o, i) {
      if (e = e === void 0 || e, t = t === void 0 || t, i = 1e-64 / (o = o || Math.pow(2, -52)), !r)
        throw new TypeError("Matrix a is not defined");
      var s, l, c, u, a, d, p, f, m, h, y, g, v = r[0].length, S = r.length;
      if (S < v)
        throw new TypeError("Invalid matrix: m < n");
      for (var w = [], b = [], T = [], _ = e === "f" ? S : v, x = h = p = 0; x < S; x++)
        b[x] = new Array(_).fill(0);
      for (x = 0; x < v; x++)
        T[x] = new Array(v).fill(0);
      var C, P = new Array(v).fill(0);
      for (x = 0; x < S; x++)
        for (s = 0; s < v; s++)
          b[x][s] = r[x][s];
      for (x = 0; x < v; x++) {
        for (w[x] = p, m = 0, c = x + 1, s = x; s < S; s++)
          m += Math.pow(b[s][x], 2);
        if (m < i)
          p = 0;
        else
          for (f = (d = b[x][x]) * (p = d < 0 ? Math.sqrt(m) : -Math.sqrt(m)) - m, b[x][x] = d - p, s = c; s < v; s++) {
            for (m = 0, l = x; l < S; l++)
              m += b[l][x] * b[l][s];
            for (d = m / f, l = x; l < S; l++)
              b[l][s] = b[l][s] + d * b[l][x];
          }
        for (P[x] = p, m = 0, s = c; s < v; s++)
          m += Math.pow(b[x][s], 2);
        if (m < i)
          p = 0;
        else {
          for (f = (d = b[x][x + 1]) * (p = d < 0 ? Math.sqrt(m) : -Math.sqrt(m)) - m, b[x][x + 1] = d - p, s = c; s < v; s++)
            w[s] = b[x][s] / f;
          for (s = c; s < S; s++) {
            for (m = 0, l = c; l < v; l++)
              m += b[s][l] * b[x][l];
            for (l = c; l < v; l++)
              b[s][l] = b[s][l] + m * w[l];
          }
        }
        h < (y = Math.abs(P[x]) + Math.abs(w[x])) && (h = y);
      }
      if (t)
        for (x = v - 1; 0 <= x; x--) {
          if (p !== 0) {
            for (f = b[x][x + 1] * p, s = c; s < v; s++)
              T[s][x] = b[x][s] / f;
            for (s = c; s < v; s++) {
              for (m = 0, l = c; l < v; l++)
                m += b[x][l] * T[l][s];
              for (l = c; l < v; l++)
                T[l][s] = T[l][s] + m * T[l][x];
            }
          }
          for (s = c; s < v; s++)
            T[x][s] = 0, T[s][x] = 0;
          T[x][x] = 1, p = w[x], c = x;
        }
      if (e) {
        if (e === "f")
          for (x = v; x < S; x++) {
            for (s = v; s < S; s++)
              b[x][s] = 0;
            b[x][x] = 1;
          }
        for (x = v - 1; 0 <= x; x--) {
          for (c = x + 1, p = P[x], s = c; s < _; s++)
            b[x][s] = 0;
          if (p !== 0) {
            for (f = b[x][x] * p, s = c; s < _; s++) {
              for (m = 0, l = c; l < S; l++)
                m += b[l][x] * b[l][s];
              for (d = m / f, l = x; l < S; l++)
                b[l][s] = b[l][s] + d * b[l][x];
            }
            for (s = x; s < S; s++)
              b[s][x] = b[s][x] / p;
          } else
            for (s = x; s < S; s++)
              b[s][x] = 0;
          b[x][x] = b[x][x] + 1;
        }
      }
      for (o *= h, l = v - 1; 0 <= l; l--)
        for (var I = 0; I < 50; I++) {
          for (C = false, c = l; 0 <= c; c--) {
            if (Math.abs(w[c]) <= o) {
              C = true;
              break;
            }
            if (Math.abs(P[c - 1]) <= o)
              break;
          }
          if (!C) {
            for (a = 0, u = c - (m = 1), x = c; x < l + 1 && (d = m * w[x], w[x] = a * w[x], !(Math.abs(d) <= o)); x++)
              if (p = P[x], P[x] = Math.sqrt(d * d + p * p), a = p / (f = P[x]), m = -d / f, e)
                for (s = 0; s < S; s++)
                  y = b[s][u], g = b[s][x], b[s][u] = y * a + g * m, b[s][x] = -y * m + g * a;
          }
          if (g = P[l], c === l) {
            if (g < 0 && (P[l] = -g, t))
              for (s = 0; s < v; s++)
                T[s][l] = -T[s][l];
            break;
          }
          for (h = P[c], d = (((y = P[l - 1]) - g) * (y + g) + ((p = w[l - 1]) - (f = w[l])) * (p + f)) / (2 * f * y), p = Math.sqrt(d * d + 1), d = ((h - g) * (h + g) + f * (y / (d < 0 ? d - p : d + p) - f)) / h, x = c + (m = a = 1); x < l + 1; x++) {
            if (p = w[x], y = P[x], f = m * p, p *= a, g = Math.sqrt(d * d + f * f), d = h * (a = d / (w[x - 1] = g)) + p * (m = f / g), p = -h * m + p * a, f = y * m, y *= a, t)
              for (s = 0; s < v; s++)
                h = T[s][x - 1], g = T[s][x], T[s][x - 1] = h * a + g * m, T[s][x] = -h * m + g * a;
            if (g = Math.sqrt(d * d + f * f), d = (a = d / (P[x - 1] = g)) * p + (m = f / g) * y, h = -m * p + a * y, e)
              for (s = 0; s < S; s++)
                y = b[s][x - 1], g = b[s][x], b[s][x - 1] = y * a + g * m, b[s][x] = -y * m + g * a;
          }
          w[c] = 0, w[l] = d, P[l] = h;
        }
      for (x = 0; x < v; x++)
        P[x] < o && (P[x] = 0);
      return { u: b, q: P, v: T };
    }, n.VERSION = "1.1.1", Object.defineProperty(n, "__esModule", { value: true });
  });
});
var py = Ls((bl) => {
  (function() {
    "use strict";
    var n = function() {
      this.init();
    };
    n.prototype = { init: function() {
      var a = this || r;
      return a._counter = 1e3, a._html5AudioPool = [], a.html5PoolSize = 10, a._codecs = {}, a._howls = [], a._muted = false, a._volume = 1, a._canPlayEvent = "canplaythrough", a._navigator = typeof window < "u" && window.navigator ? window.navigator : null, a.masterGain = null, a.noAudio = false, a.usingWebAudio = true, a.autoSuspend = true, a.ctx = null, a.autoUnlock = true, a._setup(), a;
    }, volume: function(a) {
      var d = this || r;
      if (a = parseFloat(a), d.ctx || u(), typeof a < "u" && a >= 0 && a <= 1) {
        if (d._volume = a, d._muted)
          return d;
        d.usingWebAudio && d.masterGain.gain.setValueAtTime(a, r.ctx.currentTime);
        for (var p = 0; p < d._howls.length; p++)
          if (!d._howls[p]._webAudio)
            for (var f = d._howls[p]._getSoundIds(), m = 0; m < f.length; m++) {
              var h = d._howls[p]._soundById(f[m]);
              h && h._node && (h._node.volume = h._volume * a);
            }
        return d;
      }
      return d._volume;
    }, mute: function(a) {
      var d = this || r;
      d.ctx || u(), d._muted = a, d.usingWebAudio && d.masterGain.gain.setValueAtTime(a ? 0 : d._volume, r.ctx.currentTime);
      for (var p = 0; p < d._howls.length; p++)
        if (!d._howls[p]._webAudio)
          for (var f = d._howls[p]._getSoundIds(), m = 0; m < f.length; m++) {
            var h = d._howls[p]._soundById(f[m]);
            h && h._node && (h._node.muted = a ? true : h._muted);
          }
      return d;
    }, stop: function() {
      for (var a = this || r, d = 0; d < a._howls.length; d++)
        a._howls[d].stop();
      return a;
    }, unload: function() {
      for (var a = this || r, d = a._howls.length - 1; d >= 0; d--)
        a._howls[d].unload();
      return a.usingWebAudio && a.ctx && typeof a.ctx.close < "u" && (a.ctx.close(), a.ctx = null, u()), a;
    }, codecs: function(a) {
      return (this || r)._codecs[a.replace(/^x-/, "")];
    }, _setup: function() {
      var a = this || r;
      if (a.state = a.ctx && a.ctx.state || "suspended", a._autoSuspend(), !a.usingWebAudio)
        if (typeof Audio < "u")
          try {
            var d = new Audio();
            typeof d.oncanplaythrough > "u" && (a._canPlayEvent = "canplay");
          } catch {
            a.noAudio = true;
          }
        else
          a.noAudio = true;
      try {
        var d = new Audio();
        d.muted && (a.noAudio = true);
      } catch {
      }
      return a.noAudio || a._setupCodecs(), a;
    }, _setupCodecs: function() {
      var a = this || r, d = null;
      try {
        d = typeof Audio < "u" ? new Audio() : null;
      } catch {
        return a;
      }
      if (!d || typeof d.canPlayType != "function")
        return a;
      var p = d.canPlayType("audio/mpeg;").replace(/^no$/, ""), f = a._navigator ? a._navigator.userAgent : "", m = f.match(/OPR\/([0-6].)/g), h = m && parseInt(m[0].split("/")[1], 10) < 33, y = f.indexOf("Safari") !== -1 && f.indexOf("Chrome") === -1, g = f.match(/Version\/(.*?) /), v = y && g && parseInt(g[1], 10) < 15;
      return a._codecs = { mp3: !!(!h && (p || d.canPlayType("audio/mp3;").replace(/^no$/, ""))), mpeg: !!p, opus: !!d.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(d.canPlayType('audio/wav; codecs="1"') || d.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!d.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!d.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(d.canPlayType("audio/x-m4a;") || d.canPlayType("audio/m4a;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(d.canPlayType("audio/x-m4b;") || d.canPlayType("audio/m4b;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(d.canPlayType("audio/x-mp4;") || d.canPlayType("audio/mp4;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!(!v && d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !!(!v && d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!d.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(d.canPlayType("audio/x-flac;") || d.canPlayType("audio/flac;")).replace(/^no$/, "") }, a;
    }, _unlockAudio: function() {
      var a = this || r;
      if (!(a._audioUnlocked || !a.ctx)) {
        a._audioUnlocked = false, a.autoUnlock = false, !a._mobileUnloaded && a.ctx.sampleRate !== 44100 && (a._mobileUnloaded = true, a.unload()), a._scratchBuffer = a.ctx.createBuffer(1, 1, 22050);
        var d = function(p) {
          for (; a._html5AudioPool.length < a.html5PoolSize; )
            try {
              var f = new Audio();
              f._unlocked = true, a._releaseHtml5Audio(f);
            } catch {
              a.noAudio = true;
              break;
            }
          for (var m = 0; m < a._howls.length; m++)
            if (!a._howls[m]._webAudio)
              for (var h = a._howls[m]._getSoundIds(), y = 0; y < h.length; y++) {
                var g = a._howls[m]._soundById(h[y]);
                g && g._node && !g._node._unlocked && (g._node._unlocked = true, g._node.load());
              }
          a._autoResume();
          var v = a.ctx.createBufferSource();
          v.buffer = a._scratchBuffer, v.connect(a.ctx.destination), typeof v.start > "u" ? v.noteOn(0) : v.start(0), typeof a.ctx.resume == "function" && a.ctx.resume(), v.onended = function() {
            v.disconnect(0), a._audioUnlocked = true, document.removeEventListener("touchstart", d, true), document.removeEventListener("touchend", d, true), document.removeEventListener("click", d, true), document.removeEventListener("keydown", d, true);
            for (var S = 0; S < a._howls.length; S++)
              a._howls[S]._emit("unlock");
          };
        };
        return document.addEventListener("touchstart", d, true), document.addEventListener("touchend", d, true), document.addEventListener("click", d, true), document.addEventListener("keydown", d, true), a;
      }
    }, _obtainHtml5Audio: function() {
      var a = this || r;
      if (a._html5AudioPool.length)
        return a._html5AudioPool.pop();
      var d = new Audio().play();
      return d && typeof Promise < "u" && (d instanceof Promise || typeof d.then == "function") && d.catch(function() {
        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
      }), new Audio();
    }, _releaseHtml5Audio: function(a) {
      var d = this || r;
      return a._unlocked && d._html5AudioPool.push(a), d;
    }, _autoSuspend: function() {
      var a = this;
      if (!(!a.autoSuspend || !a.ctx || typeof a.ctx.suspend > "u" || !r.usingWebAudio)) {
        for (var d = 0; d < a._howls.length; d++)
          if (a._howls[d]._webAudio) {
            for (var p = 0; p < a._howls[d]._sounds.length; p++)
              if (!a._howls[d]._sounds[p]._paused)
                return a;
          }
        return a._suspendTimer && clearTimeout(a._suspendTimer), a._suspendTimer = setTimeout(function() {
          if (!!a.autoSuspend) {
            a._suspendTimer = null, a.state = "suspending";
            var f = function() {
              a.state = "suspended", a._resumeAfterSuspend && (delete a._resumeAfterSuspend, a._autoResume());
            };
            a.ctx.suspend().then(f, f);
          }
        }, 3e4), a;
      }
    }, _autoResume: function() {
      var a = this;
      if (!(!a.ctx || typeof a.ctx.resume > "u" || !r.usingWebAudio))
        return a.state === "running" && a.ctx.state !== "interrupted" && a._suspendTimer ? (clearTimeout(a._suspendTimer), a._suspendTimer = null) : a.state === "suspended" || a.state === "running" && a.ctx.state === "interrupted" ? (a.ctx.resume().then(function() {
          a.state = "running";
          for (var d = 0; d < a._howls.length; d++)
            a._howls[d]._emit("resume");
        }), a._suspendTimer && (clearTimeout(a._suspendTimer), a._suspendTimer = null)) : a.state === "suspending" && (a._resumeAfterSuspend = true), a;
    } };
    var r = new n(), e = function(a) {
      var d = this;
      if (!a.src || a.src.length === 0) {
        console.error("An array of source files must be passed with any new Howl.");
        return;
      }
      d.init(a);
    };
    e.prototype = { init: function(a) {
      var d = this;
      return r.ctx || u(), d._autoplay = a.autoplay || false, d._format = typeof a.format != "string" ? a.format : [a.format], d._html5 = a.html5 || false, d._muted = a.mute || false, d._loop = a.loop || false, d._pool = a.pool || 5, d._preload = typeof a.preload == "boolean" || a.preload === "metadata" ? a.preload : true, d._rate = a.rate || 1, d._sprite = a.sprite || {}, d._src = typeof a.src != "string" ? a.src : [a.src], d._volume = a.volume !== void 0 ? a.volume : 1, d._xhr = { method: a.xhr && a.xhr.method ? a.xhr.method : "GET", headers: a.xhr && a.xhr.headers ? a.xhr.headers : null, withCredentials: a.xhr && a.xhr.withCredentials ? a.xhr.withCredentials : false }, d._duration = 0, d._state = "unloaded", d._sounds = [], d._endTimers = {}, d._queue = [], d._playLock = false, d._onend = a.onend ? [{ fn: a.onend }] : [], d._onfade = a.onfade ? [{ fn: a.onfade }] : [], d._onload = a.onload ? [{ fn: a.onload }] : [], d._onloaderror = a.onloaderror ? [{ fn: a.onloaderror }] : [], d._onplayerror = a.onplayerror ? [{ fn: a.onplayerror }] : [], d._onpause = a.onpause ? [{ fn: a.onpause }] : [], d._onplay = a.onplay ? [{ fn: a.onplay }] : [], d._onstop = a.onstop ? [{ fn: a.onstop }] : [], d._onmute = a.onmute ? [{ fn: a.onmute }] : [], d._onvolume = a.onvolume ? [{ fn: a.onvolume }] : [], d._onrate = a.onrate ? [{ fn: a.onrate }] : [], d._onseek = a.onseek ? [{ fn: a.onseek }] : [], d._onunlock = a.onunlock ? [{ fn: a.onunlock }] : [], d._onresume = [], d._webAudio = r.usingWebAudio && !d._html5, typeof r.ctx < "u" && r.ctx && r.autoUnlock && r._unlockAudio(), r._howls.push(d), d._autoplay && d._queue.push({ event: "play", action: function() {
        d.play();
      } }), d._preload && d._preload !== "none" && d.load(), d;
    }, load: function() {
      var a = this, d = null;
      if (r.noAudio) {
        a._emit("loaderror", null, "No audio support.");
        return;
      }
      typeof a._src == "string" && (a._src = [a._src]);
      for (var p = 0; p < a._src.length; p++) {
        var f, m;
        if (a._format && a._format[p])
          f = a._format[p];
        else {
          if (m = a._src[p], typeof m != "string") {
            a._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
            continue;
          }
          f = /^data:audio\/([^;,]+);/i.exec(m), f || (f = /\.([^.]+)$/.exec(m.split("?", 1)[0])), f && (f = f[1].toLowerCase());
        }
        if (f || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), f && r.codecs(f)) {
          d = a._src[p];
          break;
        }
      }
      if (!d) {
        a._emit("loaderror", null, "No codec support for selected audio sources.");
        return;
      }
      return a._src = d, a._state = "loading", window.location.protocol === "https:" && d.slice(0, 5) === "http:" && (a._html5 = true, a._webAudio = false), new t(a), a._webAudio && i(a), a;
    }, play: function(a, d) {
      var p = this, f = null;
      if (typeof a == "number")
        f = a, a = null;
      else {
        if (typeof a == "string" && p._state === "loaded" && !p._sprite[a])
          return null;
        if (typeof a > "u" && (a = "__default", !p._playLock)) {
          for (var m = 0, h = 0; h < p._sounds.length; h++)
            p._sounds[h]._paused && !p._sounds[h]._ended && (m++, f = p._sounds[h]._id);
          m === 1 ? a = null : f = null;
        }
      }
      var y = f ? p._soundById(f) : p._inactiveSound();
      if (!y)
        return null;
      if (f && !a && (a = y._sprite || "__default"), p._state !== "loaded") {
        y._sprite = a, y._ended = false;
        var g = y._id;
        return p._queue.push({ event: "play", action: function() {
          p.play(g);
        } }), g;
      }
      if (f && !y._paused)
        return d || p._loadQueue("play"), y._id;
      p._webAudio && r._autoResume();
      var v = Math.max(0, y._seek > 0 ? y._seek : p._sprite[a][0] / 1e3), S = Math.max(0, (p._sprite[a][0] + p._sprite[a][1]) / 1e3 - v), w = S * 1e3 / Math.abs(y._rate), b = p._sprite[a][0] / 1e3, T = (p._sprite[a][0] + p._sprite[a][1]) / 1e3;
      y._sprite = a, y._ended = false;
      var _ = function() {
        y._paused = false, y._seek = v, y._start = b, y._stop = T, y._loop = !!(y._loop || p._sprite[a][2]);
      };
      if (v >= T) {
        p._ended(y);
        return;
      }
      var x = y._node;
      if (p._webAudio) {
        var C = function() {
          p._playLock = false, _(), p._refreshBuffer(y);
          var A = y._muted || p._muted ? 0 : y._volume;
          x.gain.setValueAtTime(A, r.ctx.currentTime), y._playStart = r.ctx.currentTime, typeof x.bufferSource.start > "u" ? y._loop ? x.bufferSource.noteGrainOn(0, v, 86400) : x.bufferSource.noteGrainOn(0, v, S) : y._loop ? x.bufferSource.start(0, v, 86400) : x.bufferSource.start(0, v, S), w !== 1 / 0 && (p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), w)), d || setTimeout(function() {
            p._emit("play", y._id), p._loadQueue();
          }, 0);
        };
        r.state === "running" && r.ctx.state !== "interrupted" ? C() : (p._playLock = true, p.once("resume", C), p._clearTimer(y._id));
      } else {
        var P = function() {
          x.currentTime = v, x.muted = y._muted || p._muted || r._muted || x.muted, x.volume = y._volume * r.volume(), x.playbackRate = y._rate;
          try {
            var A = x.play();
            if (A && typeof Promise < "u" && (A instanceof Promise || typeof A.then == "function") ? (p._playLock = true, _(), A.then(function() {
              p._playLock = false, x._unlocked = true, d ? p._loadQueue() : p._emit("play", y._id);
            }).catch(function() {
              p._playLock = false, p._emit("playerror", y._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), y._ended = true, y._paused = true;
            })) : d || (p._playLock = false, _(), p._emit("play", y._id)), x.playbackRate = y._rate, x.paused) {
              p._emit("playerror", y._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
              return;
            }
            a !== "__default" || y._loop ? p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), w) : (p._endTimers[y._id] = function() {
              p._ended(y), x.removeEventListener("ended", p._endTimers[y._id], false);
            }, x.addEventListener("ended", p._endTimers[y._id], false));
          } catch (G) {
            p._emit("playerror", y._id, G);
          }
        };
        x.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (x.src = p._src, x.load());
        var I = window && window.ejecta || !x.readyState && r._navigator.isCocoonJS;
        if (x.readyState >= 3 || I)
          P();
        else {
          p._playLock = true, p._state = "loading";
          var O = function() {
            p._state = "loaded", P(), x.removeEventListener(r._canPlayEvent, O, false);
          };
          x.addEventListener(r._canPlayEvent, O, false), p._clearTimer(y._id);
        }
      }
      return y._id;
    }, pause: function(a) {
      var d = this;
      if (d._state !== "loaded" || d._playLock)
        return d._queue.push({ event: "pause", action: function() {
          d.pause(a);
        } }), d;
      for (var p = d._getSoundIds(a), f = 0; f < p.length; f++) {
        d._clearTimer(p[f]);
        var m = d._soundById(p[f]);
        if (m && !m._paused && (m._seek = d.seek(p[f]), m._rateSeek = 0, m._paused = true, d._stopFade(p[f]), m._node))
          if (d._webAudio) {
            if (!m._node.bufferSource)
              continue;
            typeof m._node.bufferSource.stop > "u" ? m._node.bufferSource.noteOff(0) : m._node.bufferSource.stop(0), d._cleanBuffer(m._node);
          } else
            (!isNaN(m._node.duration) || m._node.duration === 1 / 0) && m._node.pause();
        arguments[1] || d._emit("pause", m ? m._id : null);
      }
      return d;
    }, stop: function(a, d) {
      var p = this;
      if (p._state !== "loaded" || p._playLock)
        return p._queue.push({ event: "stop", action: function() {
          p.stop(a);
        } }), p;
      for (var f = p._getSoundIds(a), m = 0; m < f.length; m++) {
        p._clearTimer(f[m]);
        var h = p._soundById(f[m]);
        h && (h._seek = h._start || 0, h._rateSeek = 0, h._paused = true, h._ended = true, p._stopFade(f[m]), h._node && (p._webAudio ? h._node.bufferSource && (typeof h._node.bufferSource.stop > "u" ? h._node.bufferSource.noteOff(0) : h._node.bufferSource.stop(0), p._cleanBuffer(h._node)) : (!isNaN(h._node.duration) || h._node.duration === 1 / 0) && (h._node.currentTime = h._start || 0, h._node.pause(), h._node.duration === 1 / 0 && p._clearSound(h._node))), d || p._emit("stop", h._id));
      }
      return p;
    }, mute: function(a, d) {
      var p = this;
      if (p._state !== "loaded" || p._playLock)
        return p._queue.push({ event: "mute", action: function() {
          p.mute(a, d);
        } }), p;
      if (typeof d > "u")
        if (typeof a == "boolean")
          p._muted = a;
        else
          return p._muted;
      for (var f = p._getSoundIds(d), m = 0; m < f.length; m++) {
        var h = p._soundById(f[m]);
        h && (h._muted = a, h._interval && p._stopFade(h._id), p._webAudio && h._node ? h._node.gain.setValueAtTime(a ? 0 : h._volume, r.ctx.currentTime) : h._node && (h._node.muted = r._muted ? true : a), p._emit("mute", h._id));
      }
      return p;
    }, volume: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        return a._volume;
      if (d.length === 1 || d.length === 2 && typeof d[1] > "u") {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : p = parseFloat(d[0]);
      } else
        d.length >= 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      var y;
      if (typeof p < "u" && p >= 0 && p <= 1) {
        if (a._state !== "loaded" || a._playLock)
          return a._queue.push({ event: "volume", action: function() {
            a.volume.apply(a, d);
          } }), a;
        typeof f > "u" && (a._volume = p), f = a._getSoundIds(f);
        for (var g = 0; g < f.length; g++)
          y = a._soundById(f[g]), y && (y._volume = p, d[2] || a._stopFade(f[g]), a._webAudio && y._node && !y._muted ? y._node.gain.setValueAtTime(p, r.ctx.currentTime) : y._node && !y._muted && (y._node.volume = p * r.volume()), a._emit("volume", y._id));
      } else
        return y = f ? a._soundById(f) : a._sounds[0], y ? y._volume : 0;
      return a;
    }, fade: function(a, d, p, f) {
      var m = this;
      if (m._state !== "loaded" || m._playLock)
        return m._queue.push({ event: "fade", action: function() {
          m.fade(a, d, p, f);
        } }), m;
      a = Math.min(Math.max(0, parseFloat(a)), 1), d = Math.min(Math.max(0, parseFloat(d)), 1), p = parseFloat(p), m.volume(a, f);
      for (var h = m._getSoundIds(f), y = 0; y < h.length; y++) {
        var g = m._soundById(h[y]);
        if (g) {
          if (f || m._stopFade(h[y]), m._webAudio && !g._muted) {
            var v = r.ctx.currentTime, S = v + p / 1e3;
            g._volume = a, g._node.gain.setValueAtTime(a, v), g._node.gain.linearRampToValueAtTime(d, S);
          }
          m._startFadeInterval(g, a, d, p, h[y], typeof f > "u");
        }
      }
      return m;
    }, _startFadeInterval: function(a, d, p, f, m, h) {
      var y = this, g = d, v = p - d, S = Math.abs(v / 0.01), w = Math.max(4, S > 0 ? f / S : f), b = Date.now();
      a._fadeTo = p, a._interval = setInterval(function() {
        var T = (Date.now() - b) / f;
        b = Date.now(), g += v * T, g = Math.round(g * 100) / 100, v < 0 ? g = Math.max(p, g) : g = Math.min(p, g), y._webAudio ? a._volume = g : y.volume(g, a._id, true), h && (y._volume = g), (p < d && g <= p || p > d && g >= p) && (clearInterval(a._interval), a._interval = null, a._fadeTo = null, y.volume(p, a._id), y._emit("fade", a._id));
      }, w);
    }, _stopFade: function(a) {
      var d = this, p = d._soundById(a);
      return p && p._interval && (d._webAudio && p._node.gain.cancelScheduledValues(r.ctx.currentTime), clearInterval(p._interval), p._interval = null, d.volume(p._fadeTo, a), p._fadeTo = null, d._emit("fade", a)), d;
    }, loop: function() {
      var a = this, d = arguments, p, f, m;
      if (d.length === 0)
        return a._loop;
      if (d.length === 1)
        if (typeof d[0] == "boolean")
          p = d[0], a._loop = p;
        else
          return m = a._soundById(parseInt(d[0], 10)), m ? m._loop : false;
      else
        d.length === 2 && (p = d[0], f = parseInt(d[1], 10));
      for (var h = a._getSoundIds(f), y = 0; y < h.length; y++)
        m = a._soundById(h[y]), m && (m._loop = p, a._webAudio && m._node && m._node.bufferSource && (m._node.bufferSource.loop = p, p && (m._node.bufferSource.loopStart = m._start || 0, m._node.bufferSource.loopEnd = m._stop, a.playing(h[y]) && (a.pause(h[y], true), a.play(h[y], true)))));
      return a;
    }, rate: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        f = a._sounds[0]._id;
      else if (d.length === 1) {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : p = parseFloat(d[0]);
      } else
        d.length === 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      var y;
      if (typeof p == "number") {
        if (a._state !== "loaded" || a._playLock)
          return a._queue.push({ event: "rate", action: function() {
            a.rate.apply(a, d);
          } }), a;
        typeof f > "u" && (a._rate = p), f = a._getSoundIds(f);
        for (var g = 0; g < f.length; g++)
          if (y = a._soundById(f[g]), y) {
            a.playing(f[g]) && (y._rateSeek = a.seek(f[g]), y._playStart = a._webAudio ? r.ctx.currentTime : y._playStart), y._rate = p, a._webAudio && y._node && y._node.bufferSource ? y._node.bufferSource.playbackRate.setValueAtTime(p, r.ctx.currentTime) : y._node && (y._node.playbackRate = p);
            var v = a.seek(f[g]), S = (a._sprite[y._sprite][0] + a._sprite[y._sprite][1]) / 1e3 - v, w = S * 1e3 / Math.abs(y._rate);
            (a._endTimers[f[g]] || !y._paused) && (a._clearTimer(f[g]), a._endTimers[f[g]] = setTimeout(a._ended.bind(a, y), w)), a._emit("rate", y._id);
          }
      } else
        return y = a._soundById(f), y ? y._rate : a._rate;
      return a;
    }, seek: function() {
      var a = this, d = arguments, p, f;
      if (d.length === 0)
        a._sounds.length && (f = a._sounds[0]._id);
      else if (d.length === 1) {
        var m = a._getSoundIds(), h = m.indexOf(d[0]);
        h >= 0 ? f = parseInt(d[0], 10) : a._sounds.length && (f = a._sounds[0]._id, p = parseFloat(d[0]));
      } else
        d.length === 2 && (p = parseFloat(d[0]), f = parseInt(d[1], 10));
      if (typeof f > "u")
        return 0;
      if (typeof p == "number" && (a._state !== "loaded" || a._playLock))
        return a._queue.push({ event: "seek", action: function() {
          a.seek.apply(a, d);
        } }), a;
      var y = a._soundById(f);
      if (y)
        if (typeof p == "number" && p >= 0) {
          var g = a.playing(f);
          g && a.pause(f, true), y._seek = p, y._ended = false, a._clearTimer(f), !a._webAudio && y._node && !isNaN(y._node.duration) && (y._node.currentTime = p);
          var v = function() {
            g && a.play(f, true), a._emit("seek", f);
          };
          if (g && !a._webAudio) {
            var S = function() {
              a._playLock ? setTimeout(S, 0) : v();
            };
            setTimeout(S, 0);
          } else
            v();
        } else if (a._webAudio) {
          var w = a.playing(f) ? r.ctx.currentTime - y._playStart : 0, b = y._rateSeek ? y._rateSeek - y._seek : 0;
          return y._seek + (b + w * Math.abs(y._rate));
        } else
          return y._node.currentTime;
      return a;
    }, playing: function(a) {
      var d = this;
      if (typeof a == "number") {
        var p = d._soundById(a);
        return p ? !p._paused : false;
      }
      for (var f = 0; f < d._sounds.length; f++)
        if (!d._sounds[f]._paused)
          return true;
      return false;
    }, duration: function(a) {
      var d = this, p = d._duration, f = d._soundById(a);
      return f && (p = d._sprite[f._sprite][1] / 1e3), p;
    }, state: function() {
      return this._state;
    }, unload: function() {
      for (var a = this, d = a._sounds, p = 0; p < d.length; p++)
        d[p]._paused || a.stop(d[p]._id), a._webAudio || (a._clearSound(d[p]._node), d[p]._node.removeEventListener("error", d[p]._errorFn, false), d[p]._node.removeEventListener(r._canPlayEvent, d[p]._loadFn, false), d[p]._node.removeEventListener("ended", d[p]._endFn, false), r._releaseHtml5Audio(d[p]._node)), delete d[p]._node, a._clearTimer(d[p]._id);
      var f = r._howls.indexOf(a);
      f >= 0 && r._howls.splice(f, 1);
      var m = true;
      for (p = 0; p < r._howls.length; p++)
        if (r._howls[p]._src === a._src || a._src.indexOf(r._howls[p]._src) >= 0) {
          m = false;
          break;
        }
      return o && m && delete o[a._src], r.noAudio = false, a._state = "unloaded", a._sounds = [], a = null, null;
    }, on: function(a, d, p, f) {
      var m = this, h = m["_on" + a];
      return typeof d == "function" && h.push(f ? { id: p, fn: d, once: f } : { id: p, fn: d }), m;
    }, off: function(a, d, p) {
      var f = this, m = f["_on" + a], h = 0;
      if (typeof d == "number" && (p = d, d = null), d || p)
        for (h = 0; h < m.length; h++) {
          var y = p === m[h].id;
          if (d === m[h].fn && y || !d && y) {
            m.splice(h, 1);
            break;
          }
        }
      else if (a)
        f["_on" + a] = [];
      else {
        var g = Object.keys(f);
        for (h = 0; h < g.length; h++)
          g[h].indexOf("_on") === 0 && Array.isArray(f[g[h]]) && (f[g[h]] = []);
      }
      return f;
    }, once: function(a, d, p) {
      var f = this;
      return f.on(a, d, p, 1), f;
    }, _emit: function(a, d, p) {
      for (var f = this, m = f["_on" + a], h = m.length - 1; h >= 0; h--)
        (!m[h].id || m[h].id === d || a === "load") && (setTimeout(function(y) {
          y.call(this, d, p);
        }.bind(f, m[h].fn), 0), m[h].once && f.off(a, m[h].fn, m[h].id));
      return f._loadQueue(a), f;
    }, _loadQueue: function(a) {
      var d = this;
      if (d._queue.length > 0) {
        var p = d._queue[0];
        p.event === a && (d._queue.shift(), d._loadQueue()), a || p.action();
      }
      return d;
    }, _ended: function(a) {
      var d = this, p = a._sprite;
      if (!d._webAudio && a._node && !a._node.paused && !a._node.ended && a._node.currentTime < a._stop)
        return setTimeout(d._ended.bind(d, a), 100), d;
      var f = !!(a._loop || d._sprite[p][2]);
      if (d._emit("end", a._id), !d._webAudio && f && d.stop(a._id, true).play(a._id), d._webAudio && f) {
        d._emit("play", a._id), a._seek = a._start || 0, a._rateSeek = 0, a._playStart = r.ctx.currentTime;
        var m = (a._stop - a._start) * 1e3 / Math.abs(a._rate);
        d._endTimers[a._id] = setTimeout(d._ended.bind(d, a), m);
      }
      return d._webAudio && !f && (a._paused = true, a._ended = true, a._seek = a._start || 0, a._rateSeek = 0, d._clearTimer(a._id), d._cleanBuffer(a._node), r._autoSuspend()), !d._webAudio && !f && d.stop(a._id, true), d;
    }, _clearTimer: function(a) {
      var d = this;
      if (d._endTimers[a]) {
        if (typeof d._endTimers[a] != "function")
          clearTimeout(d._endTimers[a]);
        else {
          var p = d._soundById(a);
          p && p._node && p._node.removeEventListener("ended", d._endTimers[a], false);
        }
        delete d._endTimers[a];
      }
      return d;
    }, _soundById: function(a) {
      for (var d = this, p = 0; p < d._sounds.length; p++)
        if (a === d._sounds[p]._id)
          return d._sounds[p];
      return null;
    }, _inactiveSound: function() {
      var a = this;
      a._drain();
      for (var d = 0; d < a._sounds.length; d++)
        if (a._sounds[d]._ended)
          return a._sounds[d].reset();
      return new t(a);
    }, _drain: function() {
      var a = this, d = a._pool, p = 0, f = 0;
      if (!(a._sounds.length < d)) {
        for (f = 0; f < a._sounds.length; f++)
          a._sounds[f]._ended && p++;
        for (f = a._sounds.length - 1; f >= 0; f--) {
          if (p <= d)
            return;
          a._sounds[f]._ended && (a._webAudio && a._sounds[f]._node && a._sounds[f]._node.disconnect(0), a._sounds.splice(f, 1), p--);
        }
      }
    }, _getSoundIds: function(a) {
      var d = this;
      if (typeof a > "u") {
        for (var p = [], f = 0; f < d._sounds.length; f++)
          p.push(d._sounds[f]._id);
        return p;
      } else
        return [a];
    }, _refreshBuffer: function(a) {
      var d = this;
      return a._node.bufferSource = r.ctx.createBufferSource(), a._node.bufferSource.buffer = o[d._src], a._panner ? a._node.bufferSource.connect(a._panner) : a._node.bufferSource.connect(a._node), a._node.bufferSource.loop = a._loop, a._loop && (a._node.bufferSource.loopStart = a._start || 0, a._node.bufferSource.loopEnd = a._stop || 0), a._node.bufferSource.playbackRate.setValueAtTime(a._rate, r.ctx.currentTime), d;
    }, _cleanBuffer: function(a) {
      var d = this, p = r._navigator && r._navigator.vendor.indexOf("Apple") >= 0;
      if (r._scratchBuffer && a.bufferSource && (a.bufferSource.onended = null, a.bufferSource.disconnect(0), p))
        try {
          a.bufferSource.buffer = r._scratchBuffer;
        } catch {
        }
      return a.bufferSource = null, d;
    }, _clearSound: function(a) {
      var d = /MSIE |Trident\//.test(r._navigator && r._navigator.userAgent);
      d || (a.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
    } };
    var t = function(a) {
      this._parent = a, this.init();
    };
    t.prototype = { init: function() {
      var a = this, d = a._parent;
      return a._muted = d._muted, a._loop = d._loop, a._volume = d._volume, a._rate = d._rate, a._seek = 0, a._paused = true, a._ended = true, a._sprite = "__default", a._id = ++r._counter, d._sounds.push(a), a.create(), a;
    }, create: function() {
      var a = this, d = a._parent, p = r._muted || a._muted || a._parent._muted ? 0 : a._volume;
      return d._webAudio ? (a._node = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(), a._node.gain.setValueAtTime(p, r.ctx.currentTime), a._node.paused = true, a._node.connect(r.masterGain)) : r.noAudio || (a._node = r._obtainHtml5Audio(), a._errorFn = a._errorListener.bind(a), a._node.addEventListener("error", a._errorFn, false), a._loadFn = a._loadListener.bind(a), a._node.addEventListener(r._canPlayEvent, a._loadFn, false), a._endFn = a._endListener.bind(a), a._node.addEventListener("ended", a._endFn, false), a._node.src = d._src, a._node.preload = d._preload === true ? "auto" : d._preload, a._node.volume = p * r.volume(), a._node.load()), a;
    }, reset: function() {
      var a = this, d = a._parent;
      return a._muted = d._muted, a._loop = d._loop, a._volume = d._volume, a._rate = d._rate, a._seek = 0, a._rateSeek = 0, a._paused = true, a._ended = true, a._sprite = "__default", a._id = ++r._counter, a;
    }, _errorListener: function() {
      var a = this;
      a._parent._emit("loaderror", a._id, a._node.error ? a._node.error.code : 0), a._node.removeEventListener("error", a._errorFn, false);
    }, _loadListener: function() {
      var a = this, d = a._parent;
      d._duration = Math.ceil(a._node.duration * 10) / 10, Object.keys(d._sprite).length === 0 && (d._sprite = { __default: [0, d._duration * 1e3] }), d._state !== "loaded" && (d._state = "loaded", d._emit("load"), d._loadQueue()), a._node.removeEventListener(r._canPlayEvent, a._loadFn, false);
    }, _endListener: function() {
      var a = this, d = a._parent;
      d._duration === 1 / 0 && (d._duration = Math.ceil(a._node.duration * 10) / 10, d._sprite.__default[1] === 1 / 0 && (d._sprite.__default[1] = d._duration * 1e3), d._ended(a)), a._node.removeEventListener("ended", a._endFn, false);
    } };
    var o = {}, i = function(a) {
      var d = a._src;
      if (o[d]) {
        a._duration = o[d].duration, c(a);
        return;
      }
      if (/^data:[^;]+;base64,/.test(d)) {
        for (var p = atob(d.split(",")[1]), f = new Uint8Array(p.length), m = 0; m < p.length; ++m)
          f[m] = p.charCodeAt(m);
        l(f.buffer, a);
      } else {
        var h = new XMLHttpRequest();
        h.open(a._xhr.method, d, true), h.withCredentials = a._xhr.withCredentials, h.responseType = "arraybuffer", a._xhr.headers && Object.keys(a._xhr.headers).forEach(function(y) {
          h.setRequestHeader(y, a._xhr.headers[y]);
        }), h.onload = function() {
          var y = (h.status + "")[0];
          if (y !== "0" && y !== "2" && y !== "3") {
            a._emit("loaderror", null, "Failed loading audio file with status: " + h.status + ".");
            return;
          }
          l(h.response, a);
        }, h.onerror = function() {
          a._webAudio && (a._html5 = true, a._webAudio = false, a._sounds = [], delete o[d], a.load());
        }, s(h);
      }
    }, s = function(a) {
      try {
        a.send();
      } catch {
        a.onerror();
      }
    }, l = function(a, d) {
      var p = function() {
        d._emit("loaderror", null, "Decoding audio data failed.");
      }, f = function(m) {
        m && d._sounds.length > 0 ? (o[d._src] = m, c(d, m)) : p();
      };
      typeof Promise < "u" && r.ctx.decodeAudioData.length === 1 ? r.ctx.decodeAudioData(a).then(f).catch(p) : r.ctx.decodeAudioData(a, f, p);
    }, c = function(a, d) {
      d && !a._duration && (a._duration = d.duration), Object.keys(a._sprite).length === 0 && (a._sprite = { __default: [0, a._duration * 1e3] }), a._state !== "loaded" && (a._state = "loaded", a._emit("load"), a._loadQueue());
    }, u = function() {
      if (!!r.usingWebAudio) {
        try {
          typeof AudioContext < "u" ? r.ctx = new AudioContext() : typeof webkitAudioContext < "u" ? r.ctx = new webkitAudioContext() : r.usingWebAudio = false;
        } catch {
          r.usingWebAudio = false;
        }
        r.ctx || (r.usingWebAudio = false);
        var a = /iP(hone|od|ad)/.test(r._navigator && r._navigator.platform), d = r._navigator && r._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), p = d ? parseInt(d[1], 10) : null;
        if (a && p && p < 9) {
          var f = /safari/.test(r._navigator && r._navigator.userAgent.toLowerCase());
          r._navigator && !f && (r.usingWebAudio = false);
        }
        r.usingWebAudio && (r.masterGain = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(), r.masterGain.gain.setValueAtTime(r._muted ? 0 : r._volume, r.ctx.currentTime), r.masterGain.connect(r.ctx.destination)), r._setup();
      }
    };
    typeof define == "function" && define.amd && define([], function() {
      return { Howler: r, Howl: e };
    }), typeof bl < "u" && (bl.Howler = r, bl.Howl = e), typeof global < "u" ? (global.HowlerGlobal = n, global.Howler = r, global.Howl = e, global.Sound = t) : typeof window < "u" && (window.HowlerGlobal = n, window.Howler = r, window.Howl = e, window.Sound = t);
  })();
  (function() {
    "use strict";
    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(r) {
      var e = this;
      if (!e.ctx || !e.ctx.listener)
        return e;
      for (var t = e._howls.length - 1; t >= 0; t--)
        e._howls[t].stereo(r);
      return e;
    }, HowlerGlobal.prototype.pos = function(r, e, t) {
      var o = this;
      if (!o.ctx || !o.ctx.listener)
        return o;
      if (e = typeof e != "number" ? o._pos[1] : e, t = typeof t != "number" ? o._pos[2] : t, typeof r == "number")
        o._pos = [r, e, t], typeof o.ctx.listener.positionX < "u" ? (o.ctx.listener.positionX.setTargetAtTime(o._pos[0], Howler.ctx.currentTime, 0.1), o.ctx.listener.positionY.setTargetAtTime(o._pos[1], Howler.ctx.currentTime, 0.1), o.ctx.listener.positionZ.setTargetAtTime(o._pos[2], Howler.ctx.currentTime, 0.1)) : o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]);
      else
        return o._pos;
      return o;
    }, HowlerGlobal.prototype.orientation = function(r, e, t, o, i, s) {
      var l = this;
      if (!l.ctx || !l.ctx.listener)
        return l;
      var c = l._orientation;
      if (e = typeof e != "number" ? c[1] : e, t = typeof t != "number" ? c[2] : t, o = typeof o != "number" ? c[3] : o, i = typeof i != "number" ? c[4] : i, s = typeof s != "number" ? c[5] : s, typeof r == "number")
        l._orientation = [r, e, t, o, i, s], typeof l.ctx.listener.forwardX < "u" ? (l.ctx.listener.forwardX.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), l.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, 0.1), l.ctx.listener.forwardZ.setTargetAtTime(t, Howler.ctx.currentTime, 0.1), l.ctx.listener.upX.setTargetAtTime(o, Howler.ctx.currentTime, 0.1), l.ctx.listener.upY.setTargetAtTime(i, Howler.ctx.currentTime, 0.1), l.ctx.listener.upZ.setTargetAtTime(s, Howler.ctx.currentTime, 0.1)) : l.ctx.listener.setOrientation(r, e, t, o, i, s);
      else
        return c;
      return l;
    }, Howl.prototype.init = function(r) {
      return function(e) {
        var t = this;
        return t._orientation = e.orientation || [1, 0, 0], t._stereo = e.stereo || null, t._pos = e.pos || null, t._pannerAttr = { coneInnerAngle: typeof e.coneInnerAngle < "u" ? e.coneInnerAngle : 360, coneOuterAngle: typeof e.coneOuterAngle < "u" ? e.coneOuterAngle : 360, coneOuterGain: typeof e.coneOuterGain < "u" ? e.coneOuterGain : 0, distanceModel: typeof e.distanceModel < "u" ? e.distanceModel : "inverse", maxDistance: typeof e.maxDistance < "u" ? e.maxDistance : 1e4, panningModel: typeof e.panningModel < "u" ? e.panningModel : "HRTF", refDistance: typeof e.refDistance < "u" ? e.refDistance : 1, rolloffFactor: typeof e.rolloffFactor < "u" ? e.rolloffFactor : 1 }, t._onstereo = e.onstereo ? [{ fn: e.onstereo }] : [], t._onpos = e.onpos ? [{ fn: e.onpos }] : [], t._onorientation = e.onorientation ? [{ fn: e.onorientation }] : [], r.call(this, e);
      };
    }(Howl.prototype.init), Howl.prototype.stereo = function(r, e) {
      var t = this;
      if (!t._webAudio)
        return t;
      if (t._state !== "loaded")
        return t._queue.push({ event: "stereo", action: function() {
          t.stereo(r, e);
        } }), t;
      var o = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
      if (typeof e > "u")
        if (typeof r == "number")
          t._stereo = r, t._pos = [r, 0, 0];
        else
          return t._stereo;
      for (var i = t._getSoundIds(e), s = 0; s < i.length; s++) {
        var l = t._soundById(i[s]);
        if (l)
          if (typeof r == "number")
            l._stereo = r, l._pos = [r, 0, 0], l._node && (l._pannerAttr.panningModel = "equalpower", (!l._panner || !l._panner.pan) && n(l, o), o === "spatial" ? typeof l._panner.positionX < "u" ? (l._panner.positionX.setValueAtTime(r, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : l._panner.setPosition(r, 0, 0) : l._panner.pan.setValueAtTime(r, Howler.ctx.currentTime)), t._emit("stereo", l._id);
          else
            return l._stereo;
      }
      return t;
    }, Howl.prototype.pos = function(r, e, t, o) {
      var i = this;
      if (!i._webAudio)
        return i;
      if (i._state !== "loaded")
        return i._queue.push({ event: "pos", action: function() {
          i.pos(r, e, t, o);
        } }), i;
      if (e = typeof e != "number" ? 0 : e, t = typeof t != "number" ? -0.5 : t, typeof o > "u")
        if (typeof r == "number")
          i._pos = [r, e, t];
        else
          return i._pos;
      for (var s = i._getSoundIds(o), l = 0; l < s.length; l++) {
        var c = i._soundById(s[l]);
        if (c)
          if (typeof r == "number")
            c._pos = [r, e, t], c._node && ((!c._panner || c._panner.pan) && n(c, "spatial"), typeof c._panner.positionX < "u" ? (c._panner.positionX.setValueAtTime(r, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(e, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(t, Howler.ctx.currentTime)) : c._panner.setPosition(r, e, t)), i._emit("pos", c._id);
          else
            return c._pos;
      }
      return i;
    }, Howl.prototype.orientation = function(r, e, t, o) {
      var i = this;
      if (!i._webAudio)
        return i;
      if (i._state !== "loaded")
        return i._queue.push({ event: "orientation", action: function() {
          i.orientation(r, e, t, o);
        } }), i;
      if (e = typeof e != "number" ? i._orientation[1] : e, t = typeof t != "number" ? i._orientation[2] : t, typeof o > "u")
        if (typeof r == "number")
          i._orientation = [r, e, t];
        else
          return i._orientation;
      for (var s = i._getSoundIds(o), l = 0; l < s.length; l++) {
        var c = i._soundById(s[l]);
        if (c)
          if (typeof r == "number")
            c._orientation = [r, e, t], c._node && (c._panner || (c._pos || (c._pos = i._pos || [0, 0, -0.5]), n(c, "spatial")), typeof c._panner.orientationX < "u" ? (c._panner.orientationX.setValueAtTime(r, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(e, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(t, Howler.ctx.currentTime)) : c._panner.setOrientation(r, e, t)), i._emit("orientation", c._id);
          else
            return c._orientation;
      }
      return i;
    }, Howl.prototype.pannerAttr = function() {
      var r = this, e = arguments, t, o, i;
      if (!r._webAudio)
        return r;
      if (e.length === 0)
        return r._pannerAttr;
      if (e.length === 1)
        if (typeof e[0] == "object")
          t = e[0], typeof o > "u" && (t.pannerAttr || (t.pannerAttr = { coneInnerAngle: t.coneInnerAngle, coneOuterAngle: t.coneOuterAngle, coneOuterGain: t.coneOuterGain, distanceModel: t.distanceModel, maxDistance: t.maxDistance, refDistance: t.refDistance, rolloffFactor: t.rolloffFactor, panningModel: t.panningModel }), r._pannerAttr = { coneInnerAngle: typeof t.pannerAttr.coneInnerAngle < "u" ? t.pannerAttr.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: typeof t.pannerAttr.coneOuterAngle < "u" ? t.pannerAttr.coneOuterAngle : r._coneOuterAngle, coneOuterGain: typeof t.pannerAttr.coneOuterGain < "u" ? t.pannerAttr.coneOuterGain : r._coneOuterGain, distanceModel: typeof t.pannerAttr.distanceModel < "u" ? t.pannerAttr.distanceModel : r._distanceModel, maxDistance: typeof t.pannerAttr.maxDistance < "u" ? t.pannerAttr.maxDistance : r._maxDistance, refDistance: typeof t.pannerAttr.refDistance < "u" ? t.pannerAttr.refDistance : r._refDistance, rolloffFactor: typeof t.pannerAttr.rolloffFactor < "u" ? t.pannerAttr.rolloffFactor : r._rolloffFactor, panningModel: typeof t.pannerAttr.panningModel < "u" ? t.pannerAttr.panningModel : r._panningModel });
        else
          return i = r._soundById(parseInt(e[0], 10)), i ? i._pannerAttr : r._pannerAttr;
      else
        e.length === 2 && (t = e[0], o = parseInt(e[1], 10));
      for (var s = r._getSoundIds(o), l = 0; l < s.length; l++)
        if (i = r._soundById(s[l]), i) {
          var c = i._pannerAttr;
          c = { coneInnerAngle: typeof t.coneInnerAngle < "u" ? t.coneInnerAngle : c.coneInnerAngle, coneOuterAngle: typeof t.coneOuterAngle < "u" ? t.coneOuterAngle : c.coneOuterAngle, coneOuterGain: typeof t.coneOuterGain < "u" ? t.coneOuterGain : c.coneOuterGain, distanceModel: typeof t.distanceModel < "u" ? t.distanceModel : c.distanceModel, maxDistance: typeof t.maxDistance < "u" ? t.maxDistance : c.maxDistance, refDistance: typeof t.refDistance < "u" ? t.refDistance : c.refDistance, rolloffFactor: typeof t.rolloffFactor < "u" ? t.rolloffFactor : c.rolloffFactor, panningModel: typeof t.panningModel < "u" ? t.panningModel : c.panningModel };
          var u = i._panner;
          u ? (u.coneInnerAngle = c.coneInnerAngle, u.coneOuterAngle = c.coneOuterAngle, u.coneOuterGain = c.coneOuterGain, u.distanceModel = c.distanceModel, u.maxDistance = c.maxDistance, u.refDistance = c.refDistance, u.rolloffFactor = c.rolloffFactor, u.panningModel = c.panningModel) : (i._pos || (i._pos = r._pos || [0, 0, -0.5]), n(i, "spatial"));
        }
      return r;
    }, Sound.prototype.init = function(r) {
      return function() {
        var e = this, t = e._parent;
        e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, r.call(this), e._stereo ? t.stereo(e._stereo) : e._pos && t.pos(e._pos[0], e._pos[1], e._pos[2], e._id);
      };
    }(Sound.prototype.init), Sound.prototype.reset = function(r) {
      return function() {
        var e = this, t = e._parent;
        return e._orientation = t._orientation, e._stereo = t._stereo, e._pos = t._pos, e._pannerAttr = t._pannerAttr, e._stereo ? t.stereo(e._stereo) : e._pos ? t.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, t._refreshBuffer(e)), r.call(this);
      };
    }(Sound.prototype.reset);
    var n = function(r, e) {
      e = e || "spatial", e === "spatial" ? (r._panner = Howler.ctx.createPanner(), r._panner.coneInnerAngle = r._pannerAttr.coneInnerAngle, r._panner.coneOuterAngle = r._pannerAttr.coneOuterAngle, r._panner.coneOuterGain = r._pannerAttr.coneOuterGain, r._panner.distanceModel = r._pannerAttr.distanceModel, r._panner.maxDistance = r._pannerAttr.maxDistance, r._panner.refDistance = r._pannerAttr.refDistance, r._panner.rolloffFactor = r._pannerAttr.rolloffFactor, r._panner.panningModel = r._pannerAttr.panningModel, typeof r._panner.positionX < "u" ? (r._panner.positionX.setValueAtTime(r._pos[0], Howler.ctx.currentTime), r._panner.positionY.setValueAtTime(r._pos[1], Howler.ctx.currentTime), r._panner.positionZ.setValueAtTime(r._pos[2], Howler.ctx.currentTime)) : r._panner.setPosition(r._pos[0], r._pos[1], r._pos[2]), typeof r._panner.orientationX < "u" ? (r._panner.orientationX.setValueAtTime(r._orientation[0], Howler.ctx.currentTime), r._panner.orientationY.setValueAtTime(r._orientation[1], Howler.ctx.currentTime), r._panner.orientationZ.setValueAtTime(r._orientation[2], Howler.ctx.currentTime)) : r._panner.setOrientation(r._orientation[0], r._orientation[1], r._orientation[2])) : (r._panner = Howler.ctx.createStereoPanner(), r._panner.pan.setValueAtTime(r._stereo, Howler.ctx.currentTime)), r._panner.connect(r._node), r._paused || r._parent.pause(r._id, true).play(r._id, true);
    };
  })();
});
var Tg = Ls((MX, _g) => {
  _g.exports = function(r, e) {
    for (var t = r.split("."), o = e.split("."), i = 0; i < 3; i++) {
      var s = Number(t[i]), l = Number(o[i]);
      if (s > l)
        return 1;
      if (l > s)
        return -1;
      if (!isNaN(s) && isNaN(l))
        return 1;
      if (isNaN(s) && !isNaN(l))
        return -1;
    }
    return 0;
  };
});
var Ie = class {
  modifyById(r, e) {
    let t = this;
    if (t[r] === void 0)
      throw new Error("not expected");
    {
      let i = { ...t, [r]: e };
      return Object.setPrototypeOf(i, Ie.prototype), i;
    }
  }
  add(r, e) {
    var _a2;
    return ((_a2 = this.runOp({ type: 1, id: r, data: e })) == null ? void 0 : _a2.data) ?? this;
  }
  runOp(r) {
    let e = this;
    if (r.type === 1) {
      let t = e[r.id], o;
      t === void 0 ? o = { type: 2, id: r.id } : o = { type: 1, id: r.id, data: t };
      let { id: i, data: s } = r, l = { ...e, [i]: s };
      return Object.setPrototypeOf(l, Ie.prototype), { data: l, actual: r, reverse: o };
    } else if (r.type === 2) {
      let { id: t } = r, o = e[t];
      if (o === void 0)
        return null;
      {
        let i = { ...e };
        return Object.setPrototypeOf(i, Ie.prototype), delete i[t], { data: i, actual: r, reverse: { type: 1, id: t, data: o } };
      }
    }
    return null;
  }
};
function vi(n) {
  if (n.deepFreeze !== void 0) {
    n.deepFreeze(n);
    return;
  }
  let r = Object.getOwnPropertyNames(n);
  for (let e of r) {
    let t = n[e];
    t && typeof t == "object" && vi(t);
  }
  return Object.freeze(n);
}
function ou(n, r) {
  let e = 0;
  for (; e < n.length && e < r.length; ) {
    if (n[e] < r[e])
      return -1;
    if (n[e] > r[e])
      return 1;
    e += 1;
  }
  return e !== r.length ? -1 : e !== n.length ? 1 : 0;
}
var qo = class extends Error {
};
function Ds(n) {
  let r = { ...n };
  return Object.setPrototypeOf(r, Object.getPrototypeOf(n)), r;
}
function lr(n, r, e) {
  if (n === void 0 ? r === void 0 ? (n = 0, r = 10) : n = r - 10 : r === void 0 && (r = n + 10), n > r) {
    let i = n;
    n = r, r = i;
  }
  let t = [], o = 1 / (e + 1);
  for (let i = 0; i < e; i++) {
    let s = n + (r - n) * (i + 0.75 + Math.random() * 0.5) * o;
    t.push(s);
  }
  return t;
}
function $o(n) {
  return n instanceof Uint8Array || n instanceof Uint16Array || n instanceof Uint32Array || n instanceof Int8Array || n instanceof Int16Array || n instanceof Int32Array || n instanceof Float32Array || n instanceof Float64Array;
}
function nu() {
  return typeof process < "u";
}
function iu(n, r) {
  for (let e of n)
    r(e.id, e.data) !== true && iu(e.children, r);
}
function su(n, r) {
  if (r(n.id, n.data) !== true)
    for (let e of n.children)
      su(e, r);
}
var ze = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, ze.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      vi(this[e]), e++;
  }
  fillCaches0(e, t) {
    this.objCaches.set(e.id, e), this.parentCaches.set(e.id, t);
    for (let o of e.children)
      this.fillCaches0(o, e.id);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = /* @__PURE__ */ new Map(), this.parentCaches = /* @__PURE__ */ new Map();
      for (let e of this)
        this.fillCaches0(e, null);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  nonExistOrDescendantOf(e, t) {
    if (!this.has(e))
      return true;
    for (; e; ) {
      let o = this.parent(e);
      if (o === t)
        return true;
      e = o;
    }
    return false;
  }
  isDescendantOf(e, t) {
    for (; e; ) {
      let o = this.parent(e);
      if (o === t)
        return true;
      e = o;
    }
    return false;
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  has(e) {
    return this.childrenOf(e) !== void 0;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  childrenOf(e) {
    var _a2;
    return e === null ? this : (_a2 = this.get(e)) == null ? void 0 : _a2.children;
  }
  traverseFrom(e, t) {
    if (e === null)
      this.traverse(t);
    else {
      let o = this.get(e);
      o && su(o, t);
    }
  }
  traverse(e) {
    iu(this, e);
  }
  totalSize() {
    return this.fillCaches(), this.objCaches.size;
  }
  parent(e) {
    return this.fillCaches(), this.parentCaches.get(e);
  }
  childrenArray(e) {
    return e === null ? this : this.get(e).children;
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let i = this.parent(e), s = this.childrenArray(i), l = s.findIndex((a) => a.id === e);
      if (l < 0)
        throw new Error("not expected");
      let c = s[l];
      return s = [...s], s[l] = { ...c, data: t }, this.modifyArrayBy(i, s);
    }
  }
  modifyArrayBy(e, t) {
    let o = e, i = t;
    for (; o !== null; ) {
      let l = i, c = o;
      if (o = this.parent(o), o === void 0)
        throw new Error();
      i = this.childrenArray(o);
      let u = i.findIndex((a) => a.id === c);
      if (u < 0)
        throw new Error();
      i = [...i], i[u] = { ...i[u], children: l };
    }
    Object.setPrototypeOf(i, ze.prototype);
    let s = i;
    return s.fillCaches(), s;
  }
  runOp(e) {
    switch (e.type) {
      case 7:
        return this.addOp(e);
      case 8:
        return this.deleteOp(e);
      case 9:
        return this.moveOp(e);
    }
    return null;
  }
  checkDuplicatedIdRec({ id: e, children: t }) {
    if (this.get(e) !== void 0)
      return true;
    for (let o of t)
      if (this.checkDuplicatedIdRec(o))
        return true;
    return false;
  }
  addOp(e) {
    let { parent: t, fi: o, id: i, data: s, children: l } = e;
    if (t !== null && this.get(t) === void 0)
      return null;
    if (this.checkDuplicatedIdRec(e))
      return null;
    {
      let c = t, u = this.childrenArray(c), a = { fi: o, id: i, data: s, children: l };
      return u = [...u, a], u.sort((p, f) => p.fi - f.fi), e.localIndex = u.indexOf(a), { data: this.modifyArrayBy(c, u), actual: e, reverse: { type: 8, id: i } };
    }
  }
  deleteOp(e) {
    let { id: t } = e;
    if (this.get(t) === null)
      return null;
    {
      let o = this.parent(t);
      if (o === void 0)
        return null;
      let i = this.childrenArray(o), s = i.findIndex((u) => u.id === t);
      e.localIndex = s, i = [...i];
      let l = i.splice(s, 1)[0];
      return { data: this.modifyArrayBy(o, i), actual: e, reverse: { type: 7, ...l, parent: o } };
    }
  }
  moveOp(e) {
    let { parent: t, fi: o, id: i } = e;
    if (t !== null && this.get(t) === void 0)
      return this.deleteOp({ type: 8, id: i });
    if (t !== null) {
      let f = t;
      for (; f !== null; ) {
        if (f === void 0)
          throw new Error();
        if (f === i)
          throw new qo("cyclic tree");
        f = this.parent(f);
      }
    }
    let s = this.parent(i);
    if (s === void 0)
      return null;
    let l = s, c = this.childrenArray(s), u = c.findIndex((f) => f.id === i);
    c = [...c];
    let a = c.splice(u, 1)[0], d = this.modifyArrayBy(s, c);
    s = t, c = d.childrenArray(s);
    let p = a.fi;
    return a = { ...a, fi: o }, c = [...c, a], c.sort((f, m) => f.fi - m.fi), e.localIndex = c.indexOf(a), d = d.modifyArrayBy(s, c), { data: d, actual: e, reverse: { type: 9, parent: l, fi: p, id: i } };
  }
  previous(e, t) {
    if (t === null) {
      let i = this.childrenArray(e);
      return i.length === 0 ? null : i[i.length - 1].id;
    }
    let o = null;
    for (let i of this.childrenArray(e)) {
      if (i.id === t)
        return o;
      o = i.id;
    }
    return null;
  }
  traverseSortNext(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), i = o.findIndex((s) => s.id === e) + 1;
      if (i < o.length)
        return o[i].id;
      if (t)
        return this.traverseSortNext(t);
    }
  }
  sortNext(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? t[0].id : this.traverseSortNext(e);
  }
  traverseSortPrevious(e) {
    let t = this.childrenArray(e);
    return t.length > 0 ? this.traverseSortPrevious(t[t.length - 1].id) : e;
  }
  sortPrevious(e) {
    let t = this.parent(e);
    if (t !== void 0) {
      let o = this.childrenArray(t), i = o.findIndex((s) => s.id === e) - 1;
      return i >= 0 ? this.traverseSortPrevious(o[i].id) : t;
    }
  }
  getAllSorted(e) {
    let t = [];
    for (let o of e) {
      let i = this.getWithSortKey(o.id);
      i !== void 0 && t.push({ ...o, ...i });
    }
    t.sort((o, i) => ou(o.sortKey, i.sortKey));
    for (let o of t)
      delete o.sortKey;
    return t;
  }
  getWithSortKey(e) {
    var t = e;
    let o = [], i = this.get(t), s = i;
    if (i !== void 0) {
      for (; t; )
        o.splice(0, 0, i.fi), t = this.parent(t), t !== null && (i = this.get(t));
      return { ...s, sortKey: o };
    }
  }
  insertBeforeHelper(e, t, o) {
    return this.insertAfterHelper(e, this.previous(e, t), o);
  }
  insertAfterHelper(e, t, o) {
    let i = this.childrenArray(e);
    if (t === null) {
      if (i.length === 0)
        return lr(0, o, o);
      {
        let s = i[0].fi;
        return lr(s - o, s, o);
      }
    } else {
      let s = this.get(t);
      if (s === void 0 || this.parent(t) !== e)
        throw new Error("illegal args");
      let l = i.find((c) => c.fi > s.fi);
      if (l === void 0) {
        let c = i[i.length - 1].fi;
        return lr(c, c + o, o);
      } else
        return lr(s.fi, l.fi, o);
    }
  }
};
var Yo;
((r) => {
  function n(e, t) {
    if (t.type !== 0)
      return null;
    if (Array.isArray(e)) {
      let o = t.props, i = {}, s = [...e], l = false;
      if (o)
        for (let c of Object.keys(o)) {
          let u = parseInt(c);
          if (isNaN(u))
            throw new Error("wrong index");
          i[c] = s[u], s[u] = o[c], l = true;
        }
      return l ? { data: s, actual: t, reverse: { type: 0, props: i } } : null;
    } else {
      let o = t.props, i = {}, s = { ...e }, l = false;
      if (o)
        for (let c of Object.keys(o)) {
          i[c] = s[c];
          let u = o[c];
          u === void 0 ? delete s[c] : s[c] = u, l = true;
        }
      return l ? { data: s, actual: t, reverse: { type: 0, props: i } } : null;
    }
  }
  r.runOp = n;
})(Yo || (Yo = {}));
var he = class extends Array {
  constructor(...e) {
    super(...e);
    Object.setPrototypeOf(this, he.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; )
      vi(this[e]), e++;
  }
  fillCaches0(e) {
    this.objCaches.set(e.id, e);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      this.objCaches = /* @__PURE__ */ new Map(), Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = false;
      for (let e of this)
        this.fillCaches0(e);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  data(e) {
    var _a2;
    return (_a2 = this.get(e)) == null ? void 0 : _a2.data;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  modifyById(e, t) {
    if (this.get(e) === void 0)
      throw new Error("not expected");
    {
      let i = this, s = i.findIndex((u) => u.id === e);
      if (s < 0)
        throw new Error("not expected");
      let l = i[s];
      return i = [...i], i[s] = { ...l, data: t }, this.modifyArrayBy(i);
    }
  }
  modifyArrayBy(e) {
    Object.setPrototypeOf(e, he.prototype);
    let t = e;
    return nu() || t.fillCaches(), t;
  }
  runOp(e) {
    switch (e.type) {
      case 4:
        return this.addOp(e);
      case 5:
        return this.deleteOp(e);
      case 6:
        return this.moveOp(e);
    }
    return null;
  }
  addOp(e) {
    let { fi: t, id: o, data: i } = e, s = this, l = { fi: t, id: o, data: i };
    return s = [...s, l], s.sort((u, a) => u.fi - a.fi), e.localIndex = s.indexOf(l), { data: this.modifyArrayBy(s), actual: e, reverse: { type: 5, id: o } };
  }
  deleteOp(e) {
    let { id: t } = e, o = this, i = o.findIndex((c) => c.id === t);
    if (i === -1)
      return null;
    e.localIndex = i, o = [...o];
    let s = o.splice(i, 1)[0];
    return { data: this.modifyArrayBy(o), actual: e, reverse: { type: 4, ...s } };
  }
  moveOp(e) {
    let { fi: t, id: o } = e, i = this;
    i = [...i];
    let s = i.findIndex((a) => a.id === o);
    if (s === -1)
      return null;
    let l = i[s].fi, c = { ...i[s], fi: t };
    return i[s] = c, i.sort((a, d) => a.fi - d.fi), e.localIndex = i.indexOf(c), { data: this.modifyArrayBy(i), actual: e, reverse: { type: 6, fi: l, id: o } };
  }
  previous(e) {
    if (e === null)
      return this.length === 0 ? null : this[this.length - 1].id;
    let t = null;
    for (let o of this) {
      if (o.id === e)
        return t;
      t = o.id;
    }
    return null;
  }
  insertBeforeHelper(e, t) {
    return this.insertAfterHelper(this.previous(e), t);
  }
  insertAfterHelper(e, t) {
    let o = this;
    if (e === null) {
      if (o.length === 0)
        return lr(0, t, t);
      {
        let i = o[0].fi;
        return lr(i - t, i, t);
      }
    } else {
      let i = this.get(e);
      if (i === void 0)
        throw new Error("illegal args");
      let s = o.find((l) => l.fi > i.fi);
      if (s === void 0) {
        let l = o[o.length - 1].fi;
        return lr(l, l + t, t);
      } else
        return lr(i.fi, s.fi, t);
    }
  }
};
function Xo(n) {
  return n && typeof n == "object" && n instanceof Be;
}
var Be = class {
  unusedFunOverridesTable(r) {
  }
  runOp(r) {
    let e = [], t = this, o = 0, i = {};
    for (; o < r.path.length; ) {
      if (e.push(t), t = t === void 0 ? void 0 : t[r.path[o]], t !== void 0 && !Xo(t))
        return null;
      o += 1;
    }
    t = t ? Ds(t) : new Be();
    for (let [c, u] of Object.entries(r.props)) {
      let a = t[c];
      i[c] = a, u === void 0 ? delete t[c] : t[c] = u;
    }
    for (; o > 0; ) {
      if (Object.keys(t).length === 0) {
        let c = e[o - 1];
        c && (t = Ds(c), delete t[r.path[o - 1]]);
      } else {
        let c = e[o - 1];
        if (c) {
          let u = Ds(c);
          u[r.path[o - 1]] = t, t = u;
        } else {
          let u = new Be();
          u[r.path[o - 1]] = t, t = u;
        }
      }
      o -= 1;
    }
    let s = Object.setPrototypeOf(t, Be.prototype), l = { ...r, props: i };
    return { data: s, actual: r, reverse: l };
  }
};
var Er;
((t) => {
  function n(o, i) {
    return bi(o, i) ?? o;
  }
  t.apply = n;
  function r(o, i) {
    return Hl(o, i);
  }
  t.merge = r;
  function e(o, i) {
    let s = 0, l = i.path, c = o;
    for (; s < l.length && c !== void 0; ) {
      if (c = ut.zoomOnce(c, l[s]), c === void 0)
        return i;
      if (!Xo(c))
        return;
      s += 1;
    }
    if (c === void 0)
      return i;
    if (!!Xo(c))
      if (i.type === 0) {
        let u = { ...i.props };
        for (let a of Object.keys(c))
          delete u[a];
        return { ...i, props: u };
      } else if (i.type === 1 || i.type === 4 || i.type === 7) {
        let u = kl([i], c);
        return u ? (console.log(u), u) : i;
      } else
        return i;
  }
  t.filterOp = e;
})(Er || (Er = {}));
function kl(n, r) {
  if (r === void 0)
    return;
  let e = false, t = n.map((o) => {
    let i = o.id, s = bi(o.data, r[i]);
    if (e = e || s !== void 0, s === void 0 && (s = o.data), o.children) {
      let l = kl(o.children, r);
      return l !== void 0 ? e = true : l = o.children, { ...o, id: i, data: s, children: l };
    } else
      return { ...o, id: i, data: s };
  });
  if (e)
    return t;
}
function zg(n, r) {
  if (r === void 0)
    return;
  let e = false, t = n.map((o) => {
    let i = o.id, s = bi(o.data, r[i]);
    return e = e || s !== void 0, s === void 0 && (s = o.data), { ...o, id: i, data: s };
  });
  if (e)
    return Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t;
}
function bi(n, r) {
  if (!Xo(r))
    return r;
  if (n instanceof ze) {
    let e = kl(n, r);
    return e !== void 0 && Object.setPrototypeOf(e, Object.getPrototypeOf(n)), e;
  } else {
    if (n instanceof he)
      return zg(n, r);
    if (Array.isArray(n)) {
      let e = false, t = n.map((o, i) => {
        let s = bi(o, r[i]);
        return e = e || s !== void 0, s === void 0 && (s = o), s;
      });
      return e ? (Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t) : void 0;
    } else {
      if (n instanceof Be)
        return Hl(n, r);
      if (n && typeof n == "object") {
        let e = {}, t = false;
        for (let [o, i] of Object.entries(n)) {
          let s = bi(i, r[o]);
          t = t || s !== void 0, s === void 0 && (s = i), e[o] = s;
        }
        return t ? (Object.setPrototypeOf(e, Object.getPrototypeOf(n)), e) : void 0;
      }
    }
  }
}
function Hl(n, r) {
  if (n === void 0)
    return r;
  if (r === void 0)
    return n;
  if (!Xo(r))
    return r;
  if (!Xo(n))
    return Er.apply(n, r);
  let e = /* @__PURE__ */ new Set();
  for (let o of Object.keys(n))
    e.add(o);
  for (let o of Object.keys(r))
    e.add(o);
  let t = new Be();
  for (let o of e) {
    let i = Hl(n === void 0 ? void 0 : n[o], r === void 0 ? void 0 : r[o]);
    t[o] = i;
  }
  return t;
}
function au(n, r) {
  let e = { cur: [], result: [], len: 0 };
  return n = Si(n, r, e) ?? n, [n, e.result];
}
function Gs(n, r) {
  return n === null ? null : (n.cur[n.len] = r, n.len += 1, n);
}
function Rs(n) {
  n && (n.len -= 1);
}
function Ug(n) {
  if (n === null)
    return null;
  n.result.push(n.cur.slice(0, n.len));
}
function lu(n, r, e) {
  let t = false, o = n.map((i) => {
    let s = i.id, l = r[s];
    if (l !== void 0 && typeof l == "string" && (t = true, s = l, e !== null))
      throw new Error("not supported");
    let c = Si(i.data, r, Gs(e, s));
    Rs(e), t = t || c !== void 0, c === void 0 && (c = i.data);
    let u = lu(i.children, r, e);
    return u !== void 0 ? t = true : u = i.children, { ...i, id: s, data: c, children: u };
  });
  if (t)
    return o;
}
function kg(n, r, e) {
  let t = false, o = n.map((i) => {
    let s = i.id, l = r[s];
    if (l !== void 0 && typeof l == "string" && (t = true, s = l, e !== null))
      throw new Error("not supported");
    let c = Si(i.data, r, Gs(e, s));
    return Rs(e), t = t || c !== void 0, c === void 0 && (c = i.data), { ...i, id: s, data: c };
  });
  if (t)
    return Object.setPrototypeOf(o, Object.getPrototypeOf(n)), o;
}
function Si(n, r, e) {
  if (n instanceof ze) {
    let t = lu(n, r, e);
    return t !== void 0 && Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t;
  } else {
    if (n instanceof he)
      return kg(n, r, e);
    if (Array.isArray(n)) {
      let t = false, o = n.map((i, s) => {
        let l = Si(i, r, Gs(e, s));
        return Rs(e), t = t || l !== void 0, l === void 0 && (l = i), l;
      });
      return t ? (Object.setPrototypeOf(o, Object.getPrototypeOf(n)), o) : void 0;
    } else if (n && typeof n == "object" && !$o(n)) {
      let t = {}, o = false;
      for (let [i, s] of Object.entries(n))
        if (i !== "name" && i !== "text") {
          let l = r[i];
          if (typeof l == "string") {
            if (e !== null)
              throw new Error("not supported");
            o = true, i = l;
          }
          let c = Si(s, r, Gs(e, i));
          Rs(e), o = o || c !== void 0, c === void 0 && (c = s), t[i] = c;
        } else
          t[i] = s;
      return o ? (Object.setPrototypeOf(t, Object.getPrototypeOf(n)), t) : void 0;
    } else if (typeof n == "string") {
      let t = r[n];
      if (t !== void 0) {
        if (n.length !== 36)
          throw new Error("for now you should only call this method when the key is a uuid");
        Ug(e);
      }
      return t;
    } else
      return;
  }
}
var Vs;
((r) => {
  function n(e, t) {
    let o = ut.zoom(t, e.path);
    if (typeof o == "object") {
      let i = {};
      for (let s of Object.keys(e.props))
        i[s] = o[s];
      return { ...e, props: i };
    } else
      return { ...e, props: {} };
  }
  r.replaceProps = n;
})(Vs || (Vs = {}));
var rt;
((l) => {
  function n(c, u) {
    return { ...c, path: c.path.slice(u) };
  }
  l.drop = n;
  function r(c, u) {
    var _a2;
    return ((_a2 = e(c, u)) == null ? void 0 : _a2.data) ?? c;
  }
  l.applySimple = r;
  function e(c, u) {
    var _a2, _b2;
    let a = u.path;
    for (var d = []; ; ) {
      let p;
      if (c instanceof Be && u.type === 0 && (p = c.runOp({ ...u, path: a.slice(d.length) }), p === null && (p = void 0)), d.length === a.length && (c instanceof ze || c instanceof he || c instanceof Ie ? p = c.runOp(u) : p = Yo.runOp(c, u)), p !== void 0)
        if (p !== null) {
          let h = p.data;
          for (let y = d.length - 1; y >= 0; y--) {
            let g = a[y], v = d[y];
            if (v instanceof ze) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof he) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof Ie) {
              if (typeof g == "number")
                throw new Error("illegal arg");
              h = v.modifyById(g, h);
            } else if (v instanceof Be) {
              let S = { ...v, [g]: h };
              h = Object.setPrototypeOf(S, Be.prototype);
            } else if (typeof v == "object")
              if (Array.isArray(v)) {
                if (typeof g == "string" && (g = parseInt(g), isNaN(g)))
                  throw new Error("Invalid path");
                let S = h;
                h = [...v], h[g] = S;
              } else
                h = { ...v, [g]: h };
            else
              return null;
          }
          return { data: h, actual: { ...p.actual, path: a }, reverse: { ...p.reverse, path: a } };
        } else
          return null;
      let f = a[d.length], m;
      if (c instanceof ze) {
        if (typeof f == "number")
          throw new Error("");
        m = (_a2 = c.get(f)) == null ? void 0 : _a2.data;
      } else if (c instanceof he) {
        if (typeof f == "number")
          throw new Error("");
        m = (_b2 = c.get(f)) == null ? void 0 : _b2.data;
      } else
        c !== null && (m = c[f]);
      if (m !== void 0)
        d.push(c), c = m;
      else
        return null;
    }
  }
  l.apply = e;
  function t(c, u) {
    for (let a = 0; a < c.length && a < u.length; a++)
      if (c[a] !== u[a])
        return true;
    return false;
  }
  l.pathDisjoint = t;
  function o(c, u) {
    if (c.length !== u.length)
      return false;
    for (let a = 0; a < c.length; a++)
      if (c[a] !== u[a])
        return false;
    return true;
  }
  l.pathEq = o;
  function i(c, u) {
    return t(c.path, u.path);
  }
  l.commutative = i;
  function s(c, u) {
    return c.type === 0 && u.type === 0 && o(c.path, u.path) ? Object.keys(c.props).every((a) => u.props[a] !== void 0) : false;
  }
  l.subsumed = s;
})(rt || (rt = {}));
var Wl;
((c) => {
  function n() {
    return [];
  }
  c.empty = n;
  function r(u, a) {
    let d = [];
    for (let p of u) {
      let [f, ...m] = p.path;
      f === a && d.push({ ...p, path: m });
    }
    return d;
  }
  c.removePrefix = r;
  function e(u, a) {
    return u.map((d) => ({ ...d, path: [a, ...d.path] }));
  }
  c.addPrefix = e;
  function t(u, a) {
    return [...u, ...a];
  }
  c.concat = t;
  function o(u, a) {
    return [...u.filter((p) => !a.some((f) => rt.subsumed(p, f))), ...a];
  }
  c.compress = o;
  function i(u, a) {
    return u.every((d) => a.every((p) => rt.commutative(d, p)));
  }
  c.commutative = i;
  function s(u, a) {
    for (let d of a) {
      let p = l(u, d);
      p !== null && (u = p.data);
    }
    return u;
  }
  c.applyAll = s;
  function l(u, a) {
    var d = u;
    let p = [], f = [];
    for (let m of a)
      try {
        if (m.type === 3) {
          let h = ut.zoom(d, [...m.path, m.id]), y = rt.apply(d, { ...m, type: 2 });
          if (y !== null) {
            d = y.data;
            let [g, v] = au(d, { [m.id]: h });
            d = g;
            for (let S of v) {
              let w = S[S.length - 1];
              S.splice(S.length - 1, 1), p.push({ type: 0, path: S, props: { [w]: h } }), f.push({ type: 0, path: S, props: { [w]: m.id } });
            }
            f.push(y.reverse), p.push(y.actual);
          }
        } else {
          let h = rt.apply(d, m);
          h !== null && (p.push(h.actual), d = h.data, f.push(h.reverse));
        }
      } catch (h) {
        if (h instanceof qo)
          return null;
        throw h;
      }
    return { data: d, actual: p, reverse: f.reverse() };
  }
  c.apply = l;
})(Wl || (Wl = {}));
var cu = Symbol();
var Hg = Symbol();
var Fs = Symbol();
var go = class {
  reportOp(r, e, t = []) {
    let o = this;
    if (e === null)
      return;
    o._current = e.data;
    let i = t;
    for (; !(o instanceof js); ) {
      let s = o._path, l = o._current;
      if (s !== "" && i.splice(0, 0, s), o = o._parent, o === null)
        return;
      o.update(s, l);
    }
    o.push(i, r, e.actual, e.reverse);
  }
  deleteChildren(r) {
    if (this._children) {
      let e = this._children[r];
      if (e) {
        let t = e[Fs];
        t && t(), delete this._children[r];
      }
    }
  }
};
var $l = class extends go {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    if (Array.isArray(this._current)) {
      if (typeof r == "string" && (r = parseInt(r), isNaN(r)))
        throw new Error("Invalid path");
      this._current = [...this._current], this._current[r] = e;
    } else
      this._current = { ...this._current, [r]: e };
  }
  runOp(r) {
    this.reportOp(r, Yo.runOp(this._current, r), r.path);
  }
};
var Yl = class extends go {
  constructor(r, e, t) {
    super(), this._parent = r, this._path = e, this._current = t;
  }
  update(r, e) {
    this._current = { ...this._current, [r]: e }, Object.setPrototypeOf(this._current, Ie.prototype);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
};
var du = { get(n, r) {
  if (r === Fs)
    return () => {
      n._parent = null;
    };
  if (r === cu)
    return n._current;
  if (r === Hg)
    return n;
  let { _current: e, _children: t } = n;
  if (r === "push" && Array.isArray(e))
    throw new Error("not supported to expand array");
  let o = t === void 0 ? void 0 : t[r];
  if (o !== void 0)
    return o;
  let i = e[r], s = zs(n, r, i);
  return s !== i ? (t === void 0 && (t = {}, n._children = t), t[r] = s, s) : i;
}, has(n, r) {
  return r in n._current;
}, ownKeys(n) {
  return Reflect.ownKeys(n._current);
}, defineProperty() {
  throw Error("not supported");
}, getPrototypeOf(n) {
  return Object.getPrototypeOf(n._current);
}, setPrototypeOf() {
  throw Error("not supported");
}, getOwnPropertyDescriptor(n, r) {
  let e = n._current, t = Reflect.getOwnPropertyDescriptor(e, r);
  return t && { writable: true, configurable: true, enumerable: t.enumerable, value: e[r] };
} };
var Wg = { ...du, set(n, r, e) {
  let t = { type: 0, props: { [r]: Ye(e) ?? e } };
  return n.deleteChildren(r), n.runOp(t), true;
}, deleteProperty(n, r) {
  let e = { type: 0, props: { [r]: void 0 } };
  return n.deleteChildren(r), n.runOp(e), true;
} };
var qg = { ...du, set(n, r, e) {
  return e === void 0 ? this.deleteProperty(n, r) : (n.deleteChildren(r), n.runOp({ type: 1, id: r, data: e })), true;
}, deleteProperty(n, r) {
  return n.runOp({ type: 2, id: r }), true;
} };
var Ko = class extends go {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[Fs] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  randomId() {
    return this._current.randomId();
  }
  isDescendantOf(r, e) {
    return this._current.isDescendantOf(r, e);
  }
  childrenOf(r) {
    return this._current.childrenOf(r);
  }
  traverse(r) {
    return this._current.traverse(r);
  }
  get(r) {
    return this._current.get(r);
  }
  parent(r) {
    return this._current.parent(r);
  }
  traverse(r) {
    this._current.traverse((e, t) => {
      r(e, this.data(e));
    });
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let i = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = zs(this, r, i);
    return s !== i ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : i;
  }
  add(r, e, t, o, i) {
    this.runOp({ type: 7, parent: r, fi: e, id: t, data: o, children: i });
  }
  move(r, e, t) {
    this.runOp({ type: 9, parent: r, fi: e, id: t });
  }
  insertAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.add(r, o[i], s.id, s.data, s.children);
    }
  }
  insertBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.add(r, o[i], s.id, s.data, s.children);
    }
  }
  moveAfter(r, e, t) {
    let o = this._current.insertAfterHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.move(r, o[i], s);
    }
  }
  moveBefore(r, e, t) {
    let o = this._current.insertBeforeHelper(r, e, t.length);
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      this.move(r, o[i], s);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 8, id: r });
  }
  sortNext(r) {
    return this._current.sortNext(r);
  }
  sortPrevious(r) {
    return this._current.sortPrevious(r);
  }
  getAllSorted(r) {
    return this._current.getAllSorted(r);
  }
};
var Zo = class extends go {
  constructor(r, e, t) {
    super(), this._children = {}, this._parent = r, this._path = e, this._current = t, this[Fs] = () => {
      this._parent = null;
    };
  }
  unproxy() {
    return this._current;
  }
  get length() {
    return this._current.length;
  }
  forEach(r) {
    let e = this.length;
    for (let t = 0; t < e; t++) {
      let o = this._current[t].id, i = this._current[t].fi;
      r(this.data(this._current[t].id), o, i);
    }
  }
  find(r) {
    let e = this.length;
    for (let t = 0; t < e; t++) {
      let o = this._current[t].id;
      if (r(this.data(o), o))
        return this.get(o);
    }
  }
  update(r, e) {
    this._current = this._current.modifyById(r, e);
  }
  randomId() {
    return this._current.randomId();
  }
  get(r) {
    return { ...this._current.get(r), data: this.data(r) };
  }
  data(r) {
    var _a2;
    let { _current: e, _children: t } = this, o = t === void 0 ? void 0 : t[r];
    if (o !== void 0)
      return o;
    let i = (_a2 = e.get(r)) == null ? void 0 : _a2.data, s = zs(this, r, i);
    return s !== i ? (t === void 0 && (t = {}, this._children = t), t[r] = s, s) : i;
  }
  runOp(r) {
    this.reportOp(r, this._current.runOp(r));
  }
  add(r, e, t) {
    this.runOp({ type: 4, fi: r, id: e, data: t });
  }
  move(r, e) {
    this.runOp({ type: 6, fi: r, id: e });
  }
  insertAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.add(t[o], i.id, i.data);
    }
  }
  insertBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.add(t[o], i.id, i.data);
    }
  }
  moveAfter(r, e) {
    let t = this._current.insertAfterHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.move(t[o], i);
    }
  }
  moveBefore(r, e) {
    let t = this._current.insertBeforeHelper(r, e.length);
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      this.move(t[o], i);
    }
  }
  delete(r) {
    this.deleteChildren(r), this.runOp({ type: 5, id: r });
  }
};
function ql(n, r, e) {
  if (n.length > 0) {
    let t = n[n.length - 1];
    if (t.type === 0 && r.type === 0 && ut.equal(t.path, e)) {
      Object.assign(t.props, r.props);
      return;
    }
  }
  n.push({ ...r, path: e });
}
var js = class extends go {
  constructor(r) {
    super(), this.ts = [], this.actual = [], this.reverse = [], this._current = r;
  }
  update(r, e) {
    if (r !== "")
      throw new Error("");
    this._current = e;
  }
  push(r, e, t, o) {
    ql(this.ts, e, r), ql(this.actual, t, r), ql(this.reverse, o, r);
  }
  result() {
    return { data: this._current, ts: this.ts, actual: this.actual, reverse: this.reverse.reverse() };
  }
};
function zs(n, r, e) {
  return e instanceof ze ? new Ko(n, r, e) : e instanceof he ? new Zo(n, r, e) : e instanceof Ie ? new Proxy(new Yl(n, r, e), qg) : e !== null && typeof e == "object" ? $o(e) ? e : new Proxy(new $l(n, r, e), Wg) : e;
}
function Xl(n) {
  let r = new js(n);
  return [zs(r, "", n), r];
}
function Qo(n, r) {
  let [e, t] = Xl(n);
  return r(e), t.result();
}
function Ye(n) {
  return n instanceof Ko || n instanceof Zo ? n._current : n !== null && typeof n == "object" ? n[cu] : n;
}
var ut;
((o) => {
  function n(i, s) {
    if (s.length === i.length)
      for (var l = 0; l < i.length; ) {
        if (i[l] !== s[l])
          return false;
        l += 1;
      }
    else
      return false;
    return true;
  }
  o.equal = n;
  function r(i, s, l) {
    let c = t(l, i);
    if (c !== void 0 && typeof c == "object" && c !== null) {
      let u = { ...s };
      return Object.keys(c).forEach((a) => {
        delete u[a];
      }), u;
    } else
      return s;
  }
  o.removeOverridden = r;
  function e(i, s) {
    if ((i instanceof ze || i instanceof Ko) && typeof s == "string")
      return i.data(s);
    if ((i instanceof he || i instanceof Zo) && typeof s == "string")
      return i.data(s);
    if (typeof s == "number" && Array.isArray(i))
      return i[s];
    if (typeof s == "string" && typeof i == "object" && i !== null)
      return i[s];
  }
  o.zoomOnce = e;
  function t(i, s, l = 0) {
    for (; l < s.length && i !== void 0; )
      i = e(i, s[l]), l += 1;
    return i;
  }
  o.zoom = t;
})(ut || (ut = {}));
function uu(n, r) {
  let e = [];
  if (r.length === n.length)
    for (var t = 0; t < n.length; ) {
      if (r[t] === "*")
        e.push(n[t]);
      else if (n[t] !== r[t])
        return null;
      t += 1;
    }
  else
    return null;
  return e;
}
function qt(n, r) {
  let e = [];
  if (r.length <= n.length)
    for (var t = 0; t < r.length; ) {
      if (r[t] === "*")
        e.push(n[t]);
      else if (n[t] !== r[t])
        return null;
      t += 1;
    }
  else
    return null;
  return e;
}
var Us = class {
};
var wi = class extends Us {
  constructor(e) {
    super();
    this.id = e;
  }
};
var _i = class extends Us {
  constructor(e) {
    super();
    this.data = e;
  }
};
var Zl;
try {
  Zl = new TextDecoder();
} catch {
}
var ne;
var Yr;
var N = 0;
var vu = [];
var Ql = vu;
var Jl = 0;
var bt = {};
var we;
var $r;
var Rt = 0;
var cr = 0;
var Nt;
var Mr;
var pt = [];
var Oe;
var pu = { useRecords: false, mapsAsObjects: true };
var Ti = class {
};
var tc = new Ti();
tc.name = "MessagePack 0xC1";
var Jo = false;
var dr = class {
  constructor(r) {
    r && (r.useRecords === false && r.mapsAsObjects === void 0 && (r.mapsAsObjects = true), r.structures ? r.structures.sharedLength = r.structures.length : r.getStructures && ((r.structures = []).uninitialized = true, r.structures.sharedLength = 0)), Object.assign(this, r);
  }
  unpack(r, e) {
    if (ne)
      return Tu(() => (Hs(), this ? this.unpack(r, e) : dr.prototype.unpack.call(pu, r, e)));
    Yr = e > -1 ? e : r.length, N = 0, Jl = 0, cr = 0, $r = null, Ql = vu, Nt = null, ne = r;
    try {
      Oe = r.dataView || (r.dataView = new DataView(r.buffer, r.byteOffset, r.byteLength));
    } catch (t) {
      throw ne = null, r instanceof Uint8Array ? t : new Error("Source must be a Uint8Array or Buffer but was a " + (r && typeof r == "object" ? r.constructor.name : typeof r));
    }
    if (this instanceof dr) {
      if (bt = this, this.structures)
        return we = this.structures, ks();
      (!we || we.length > 0) && (we = []);
    } else
      bt = pu, (!we || we.length > 0) && (we = []);
    return ks();
  }
  unpackMultiple(r, e) {
    let t, o = 0;
    try {
      Jo = true;
      let i = r.length, s = this ? this.unpack(r, i) : $s.unpack(r, i);
      if (e) {
        for (e(s); N < i; )
          if (o = N, e(ks()) === false)
            return;
      } else {
        for (t = [s]; N < i; )
          o = N, t.push(ks());
        return t;
      }
    } catch (i) {
      throw i.lastPosition = o, i.values = t, i;
    } finally {
      Jo = false, Hs();
    }
  }
  _mergeStructures(r, e) {
    r = r || [];
    for (let t = 0, o = r.length; t < o; t++) {
      let i = r[t];
      i && (i.isShared = true, t >= 32 && (i.highByte = t - 32 >> 5));
    }
    r.sharedLength = r.length;
    for (let t in e || [])
      if (t >= 0) {
        let o = r[t], i = e[t];
        i && (o && ((r.restoreStructures || (r.restoreStructures = []))[t] = o), r[t] = i);
      }
    return this.structures = r;
  }
  decode(r, e) {
    return this.unpack(r, e);
  }
};
function ks() {
  try {
    if (!bt.trusted && !Jo) {
      let r = we.sharedLength || 0;
      r < we.length && (we.length = r);
    }
    let n = Re();
    if (N == Yr)
      we.restoreStructures && fu(), we = null, ne = null, Mr && (Mr = null);
    else if (N > Yr) {
      let r = new Error("Unexpected end of MessagePack data");
      throw r.incomplete = true, r;
    } else if (!Jo)
      throw new Error("Data read, but end of buffer not reached");
    return n;
  } catch (n) {
    throw we.restoreStructures && fu(), Hs(), (n instanceof RangeError || n.message.startsWith("Unexpected end of buffer")) && (n.incomplete = true), n;
  }
}
function fu() {
  for (let n in we.restoreStructures)
    we[n] = we.restoreStructures[n];
  we.restoreStructures = null;
}
function Re() {
  let n = ne[N++];
  if (n < 160)
    if (n < 128) {
      if (n < 64)
        return n;
      {
        let r = we[n & 63] || bt.getStructures && bu()[n & 63];
        return r ? (r.read || (r.read = rc(r, n & 63)), r.read()) : n;
      }
    } else if (n < 144)
      if (n -= 128, bt.mapsAsObjects) {
        let r = {};
        for (let e = 0; e < n; e++)
          r[wu()] = Re();
        return r;
      } else {
        let r = /* @__PURE__ */ new Map();
        for (let e = 0; e < n; e++)
          r.set(Re(), Re());
        return r;
      }
    else {
      n -= 144;
      let r = new Array(n);
      for (let e = 0; e < n; e++)
        r[e] = Re();
      return r;
    }
  else if (n < 192) {
    let r = n - 160;
    if (cr >= N)
      return $r.slice(N - Rt, (N += r) - Rt);
    if (cr == 0 && Yr < 140) {
      let e = r < 16 ? oc(r) : Su(r);
      if (e != null)
        return e;
    }
    return ec(r);
  } else {
    let r;
    switch (n) {
      case 192:
        return null;
      case 193:
        return Nt ? (r = Re(), r > 0 ? Nt[1].slice(Nt.position1, Nt.position1 += r) : Nt[0].slice(Nt.position0, Nt.position0 -= r)) : tc;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        return Kl(ne[N++]);
      case 197:
        return r = Oe.getUint16(N), N += 2, Kl(r);
      case 198:
        return r = Oe.getUint32(N), N += 4, Kl(r);
      case 199:
        return xo(ne[N++]);
      case 200:
        return r = Oe.getUint16(N), N += 2, xo(r);
      case 201:
        return r = Oe.getUint32(N), N += 4, xo(r);
      case 202:
        if (r = Oe.getFloat32(N), bt.useFloat32 > 2) {
          let e = qs[(ne[N] & 127) << 1 | ne[N + 1] >> 7];
          return N += 4, (e * r + (r > 0 ? 0.5 : -0.5) >> 0) / e;
        }
        return N += 4, r;
      case 203:
        return r = Oe.getFloat64(N), N += 8, r;
      case 204:
        return ne[N++];
      case 205:
        return r = Oe.getUint16(N), N += 2, r;
      case 206:
        return r = Oe.getUint32(N), N += 4, r;
      case 207:
        return bt.int64AsNumber ? (r = Oe.getUint32(N) * 4294967296, r += Oe.getUint32(N + 4)) : r = Oe.getBigUint64(N), N += 8, r;
      case 208:
        return Oe.getInt8(N++);
      case 209:
        return r = Oe.getInt16(N), N += 2, r;
      case 210:
        return r = Oe.getInt32(N), N += 4, r;
      case 211:
        return bt.int64AsNumber ? (r = Oe.getInt32(N) * 4294967296, r += Oe.getUint32(N + 4)) : r = Oe.getBigInt64(N), N += 8, r;
      case 212:
        if (r = ne[N++], r == 114)
          return xu(ne[N++] & 63);
        {
          let e = pt[r];
          if (e)
            return e.read ? (N++, e.read(Re())) : e.noBuffer ? (N++, e()) : e(ne.subarray(N, ++N));
          throw new Error("Unknown extension " + r);
        }
      case 213:
        return r = ne[N], r == 114 ? (N++, xu(ne[N++] & 63, ne[N++])) : xo(2);
      case 214:
        return xo(4);
      case 215:
        return xo(8);
      case 216:
        return xo(16);
      case 217:
        return r = ne[N++], cr >= N ? $r.slice(N - Rt, (N += r) - Rt) : Yg(r);
      case 218:
        return r = Oe.getUint16(N), N += 2, cr >= N ? $r.slice(N - Rt, (N += r) - Rt) : Xg(r);
      case 219:
        return r = Oe.getUint32(N), N += 4, cr >= N ? $r.slice(N - Rt, (N += r) - Rt) : Kg(r);
      case 220:
        return r = Oe.getUint16(N), N += 2, hu(r);
      case 221:
        return r = Oe.getUint32(N), N += 4, hu(r);
      case 222:
        return r = Oe.getUint16(N), N += 2, yu(r);
      case 223:
        return r = Oe.getUint32(N), N += 4, yu(r);
      default:
        if (n >= 224)
          return n - 256;
        if (n === void 0) {
          let e = new Error("Unexpected end of MessagePack data");
          throw e.incomplete = true, e;
        }
        throw new Error("Unknown MessagePack token " + n);
    }
  }
}
var $g = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function rc(n, r) {
  function e() {
    if (e.count++ > 2) {
      let o = n.read = new Function("r", "return function(){return {" + n.map((i) => $g.test(i) ? i + ":r()" : "[" + JSON.stringify(i) + "]:r()").join(",") + "}}")(Re);
      return n.highByte === 0 && (n.read = mu(r, n.read)), o();
    }
    let t = {};
    for (let o = 0, i = n.length; o < i; o++) {
      let s = n[o];
      t[s] = Re();
    }
    return t;
  }
  return e.count = 0, n.highByte === 0 ? mu(r, e) : e;
}
var mu = (n, r) => function() {
  let e = ne[N++];
  if (e === 0)
    return r();
  let t = n < 32 ? -(n + (e << 5)) : n + (e << 5), o = we[t] || bu()[t];
  if (!o)
    throw new Error("Record id is not defined for " + t);
  return o.read || (o.read = rc(o, n)), o.read();
};
function bu() {
  let n = Tu(() => (ne = null, bt.getStructures()));
  return we = bt._mergeStructures(n, we);
}
var ec = Ws;
var Yg = Ws;
var Xg = Ws;
var Kg = Ws;
function Ws(n) {
  let r;
  if (n < 16 && (r = oc(n)))
    return r;
  if (n > 64 && Zl)
    return Zl.decode(ne.subarray(N, N += n));
  let e = N + n, t = [];
  for (r = ""; N < e; ) {
    let o = ne[N++];
    if ((o & 128) === 0)
      t.push(o);
    else if ((o & 224) === 192) {
      let i = ne[N++] & 63;
      t.push((o & 31) << 6 | i);
    } else if ((o & 240) === 224) {
      let i = ne[N++] & 63, s = ne[N++] & 63;
      t.push((o & 31) << 12 | i << 6 | s);
    } else if ((o & 248) === 240) {
      let i = ne[N++] & 63, s = ne[N++] & 63, l = ne[N++] & 63, c = (o & 7) << 18 | i << 12 | s << 6 | l;
      c > 65535 && (c -= 65536, t.push(c >>> 10 & 1023 | 55296), c = 56320 | c & 1023), t.push(c);
    } else
      t.push(o);
    t.length >= 4096 && (r += Xe.apply(String, t), t.length = 0);
  }
  return t.length > 0 && (r += Xe.apply(String, t)), r;
}
function hu(n) {
  let r = new Array(n);
  for (let e = 0; e < n; e++)
    r[e] = Re();
  return r;
}
function yu(n) {
  if (bt.mapsAsObjects) {
    let r = {};
    for (let e = 0; e < n; e++)
      r[wu()] = Re();
    return r;
  } else {
    let r = /* @__PURE__ */ new Map();
    for (let e = 0; e < n; e++)
      r.set(Re(), Re());
    return r;
  }
}
var Xe = String.fromCharCode;
function Su(n) {
  let r = N, e = new Array(n);
  for (let t = 0; t < n; t++) {
    let o = ne[N++];
    if ((o & 128) > 0) {
      N = r;
      return;
    }
    e[t] = o;
  }
  return Xe.apply(String, e);
}
function oc(n) {
  if (n < 4)
    if (n < 2) {
      if (n === 0)
        return "";
      {
        let r = ne[N++];
        if ((r & 128) > 1) {
          N -= 1;
          return;
        }
        return Xe(r);
      }
    } else {
      let r = ne[N++], e = ne[N++];
      if ((r & 128) > 0 || (e & 128) > 0) {
        N -= 2;
        return;
      }
      if (n < 3)
        return Xe(r, e);
      let t = ne[N++];
      if ((t & 128) > 0) {
        N -= 3;
        return;
      }
      return Xe(r, e, t);
    }
  else {
    let r = ne[N++], e = ne[N++], t = ne[N++], o = ne[N++];
    if ((r & 128) > 0 || (e & 128) > 0 || (t & 128) > 0 || (o & 128) > 0) {
      N -= 4;
      return;
    }
    if (n < 6) {
      if (n === 4)
        return Xe(r, e, t, o);
      {
        let i = ne[N++];
        if ((i & 128) > 0) {
          N -= 5;
          return;
        }
        return Xe(r, e, t, o, i);
      }
    } else if (n < 8) {
      let i = ne[N++], s = ne[N++];
      if ((i & 128) > 0 || (s & 128) > 0) {
        N -= 6;
        return;
      }
      if (n < 7)
        return Xe(r, e, t, o, i, s);
      let l = ne[N++];
      if ((l & 128) > 0) {
        N -= 7;
        return;
      }
      return Xe(r, e, t, o, i, s, l);
    } else {
      let i = ne[N++], s = ne[N++], l = ne[N++], c = ne[N++];
      if ((i & 128) > 0 || (s & 128) > 0 || (l & 128) > 0 || (c & 128) > 0) {
        N -= 8;
        return;
      }
      if (n < 10) {
        if (n === 8)
          return Xe(r, e, t, o, i, s, l, c);
        {
          let u = ne[N++];
          if ((u & 128) > 0) {
            N -= 9;
            return;
          }
          return Xe(r, e, t, o, i, s, l, c, u);
        }
      } else if (n < 12) {
        let u = ne[N++], a = ne[N++];
        if ((u & 128) > 0 || (a & 128) > 0) {
          N -= 10;
          return;
        }
        if (n < 11)
          return Xe(r, e, t, o, i, s, l, c, u, a);
        let d = ne[N++];
        if ((d & 128) > 0) {
          N -= 11;
          return;
        }
        return Xe(r, e, t, o, i, s, l, c, u, a, d);
      } else {
        let u = ne[N++], a = ne[N++], d = ne[N++], p = ne[N++];
        if ((u & 128) > 0 || (a & 128) > 0 || (d & 128) > 0 || (p & 128) > 0) {
          N -= 12;
          return;
        }
        if (n < 14) {
          if (n === 12)
            return Xe(r, e, t, o, i, s, l, c, u, a, d, p);
          {
            let f = ne[N++];
            if ((f & 128) > 0) {
              N -= 13;
              return;
            }
            return Xe(r, e, t, o, i, s, l, c, u, a, d, p, f);
          }
        } else {
          let f = ne[N++], m = ne[N++];
          if ((f & 128) > 0 || (m & 128) > 0) {
            N -= 14;
            return;
          }
          if (n < 15)
            return Xe(r, e, t, o, i, s, l, c, u, a, d, p, f, m);
          let h = ne[N++];
          if ((h & 128) > 0) {
            N -= 15;
            return;
          }
          return Xe(r, e, t, o, i, s, l, c, u, a, d, p, f, m, h);
        }
      }
    }
  }
}
function Kl(n) {
  return bt.copyBuffers ? Uint8Array.prototype.slice.call(ne, N, N += n) : ne.subarray(N, N += n);
}
function xo(n) {
  let r = ne[N++];
  if (pt[r])
    return pt[r](ne.subarray(N, N += n));
  throw new Error("Unknown extension type " + r);
}
var gu = new Array(4096);
function wu() {
  let n = ne[N++];
  if (n >= 160 && n < 192) {
    if (n = n - 160, cr >= N)
      return $r.slice(N - Rt, (N += n) - Rt);
    if (!(cr == 0 && Yr < 180))
      return ec(n);
  } else
    return N--, Re();
  let r = (n << 5 ^ (n > 1 ? Oe.getUint16(N) : n > 0 ? ne[N] : 0)) & 4095, e = gu[r], t = N, o = N + n - 3, i, s = 0;
  if (e && e.bytes == n) {
    for (; t < o; ) {
      if (i = Oe.getUint32(t), i != e[s++]) {
        t = 1879048192;
        break;
      }
      t += 4;
    }
    for (o += 3; t < o; )
      if (i = ne[t++], i != e[s++]) {
        t = 1879048192;
        break;
      }
    if (t === o)
      return N = t, e.string;
    o -= 3, t = N;
  }
  for (e = [], gu[r] = e, e.bytes = n; t < o; )
    i = Oe.getUint32(t), e.push(i), t += 4;
  for (o += 3; t < o; )
    i = ne[t++], e.push(i);
  let l = n < 16 ? oc(n) : Su(n);
  return l != null ? e.string = l : e.string = ec(n);
}
var xu = (n, r) => {
  var e = Re();
  let t = n;
  r !== void 0 && (n = n < 32 ? -((r << 5) + n) : (r << 5) + n, e.highByte = r);
  let o = we[n];
  return o && o.isShared && ((we.restoreStructures || (we.restoreStructures = []))[n] = o), we[n] = e, e.read = rc(e, t), e.read();
};
var _u = typeof self == "object" ? self : global;
pt[0] = () => {
};
pt[0].noBuffer = true;
pt[101] = () => {
  let n = Re();
  return (_u[n[0]] || Error)(n[1]);
};
pt[105] = (n) => {
  let r = Oe.getUint32(N - 4);
  Mr || (Mr = /* @__PURE__ */ new Map());
  let e = ne[N], t;
  e >= 144 && e < 160 || e == 220 || e == 221 ? t = [] : t = {};
  let o = { target: t };
  Mr.set(r, o);
  let i = Re();
  return o.used ? Object.assign(t, i) : (o.target = i, i);
};
pt[112] = (n) => {
  let r = Oe.getUint32(N - 4), e = Mr.get(r);
  return e.used = true, e.target;
};
pt[115] = () => new Set(Re());
var nc = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((n) => n + "Array");
pt[116] = (n) => {
  let r = n[0], e = nc[r];
  if (!e)
    throw new Error("Could not find typed array for code " + r);
  return new _u[e](Uint8Array.prototype.slice.call(n, 1).buffer);
};
pt[120] = () => {
  let n = Re();
  return new RegExp(n[0], n[1]);
};
pt[98] = (n) => {
  let r = (n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3], e = N;
  N += r - 4, Nt = [Re(), Re()], Nt.position0 = 0, Nt.position1 = 0;
  let t = N;
  N = e;
  try {
    return Re();
  } finally {
    N = t;
  }
};
pt[255] = (n) => n.length == 4 ? new Date((n[0] * 16777216 + (n[1] << 16) + (n[2] << 8) + n[3]) * 1e3) : n.length == 8 ? new Date(((n[0] << 22) + (n[1] << 14) + (n[2] << 6) + (n[3] >> 2)) / 1e6 + ((n[3] & 3) * 4294967296 + n[4] * 16777216 + (n[5] << 16) + (n[6] << 8) + n[7]) * 1e3) : n.length == 12 ? new Date(((n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]) / 1e6 + ((n[4] & 128 ? -281474976710656 : 0) + n[6] * 1099511627776 + n[7] * 4294967296 + n[8] * 16777216 + (n[9] << 16) + (n[10] << 8) + n[11]) * 1e3) : /* @__PURE__ */ new Date("invalid");
function Tu(n) {
  let r = Yr, e = N, t = Jl, o = Rt, i = cr, s = $r, l = Ql, c = Mr, u = Nt, a = new Uint8Array(ne.slice(0, Yr)), d = we, p = we.slice(0, we.length), f = bt, m = Jo, h = n();
  return Yr = r, N = e, Jl = t, Rt = o, cr = i, $r = s, Ql = l, Mr = c, Nt = u, ne = a, Jo = m, we = d, we.splice(0, we.length, ...p), bt = f, Oe = new DataView(ne.buffer, ne.byteOffset, ne.byteLength), h;
}
function Hs() {
  ne = null, Mr = null, we = null;
}
function Pu(n) {
  n.unpack ? pt[n.type] = n.unpack : pt[n.type] = n;
}
var qs = new Array(147);
for (let n = 0; n < 256; n++)
  qs[n] = +("1e" + Math.floor(45.15 - n * 0.30103));
var $s = new dr({ useRecords: false });
var Zg = $s.unpack;
var Qg = $s.unpackMultiple;
var Jg = $s.unpack;
var Ys = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 };
var ex = new Float32Array(1);
var wI = new Uint8Array(ex.buffer, 0, 4);
var Xs;
try {
  Xs = new TextEncoder();
} catch {
}
var Ks;
var sc;
var Zs = typeof Buffer < "u";
var ic = Zs ? Buffer.allocUnsafeSlow : Uint8Array;
var Cu = Zs ? Buffer : Uint8Array;
var Ou = Zs ? 4294967296 : 2144337920;
var V;
var je;
var M = 0;
var ur;
var pr = null;
var tx = /[\u0080-\uFFFF]/;
var Pi = Symbol("record-id");
var vo = class extends dr {
  constructor(r) {
    super(r), this.offset = 0;
    let e, t, o, i, s, l, c = 0, u = Cu.prototype.utf8Write ? function(x, C, P) {
      return V.utf8Write(x, C, P);
    } : Xs && Xs.encodeInto ? function(x, C) {
      return Xs.encodeInto(x, V.subarray(C)).written;
    } : false, a = this;
    r || (r = {});
    let d = r && r.sequential, p = r.structures || r.saveStructures, f = r.maxSharedStructures;
    if (f == null && (f = p ? 32 : 0), f > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    let m = r.maxOwnStructures;
    m == null && (m = p ? 32 : 64), d && !r.saveStructures && (this.structures = []);
    let h = f > 32 || m + f > 64, y = f + 64, g = f + m + 64;
    if (g > 8256)
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    let v = [], S = 0, w = 0;
    this.pack = this.encode = function(x, C) {
      if (V || (V = new ic(8192), je = new DataView(V.buffer, 0, 8192), M = 0), ur = V.length - 10, ur - M < 2048 ? (V = new ic(V.length), je = new DataView(V.buffer, 0, V.length), ur = V.length - 10, M = 0) : M = M + 7 & 2147483640, t = M, l = a.structuredClone ? /* @__PURE__ */ new Map() : null, a.bundleStrings ? (pr = ["", ""], V[M++] = 214, V[M++] = 98, pr.position = M - t, M += 4) : pr = null, o = a.structures, o) {
        o.uninitialized && (o = a._mergeStructures(a.getStructures()));
        let P = o.sharedLength || 0;
        if (P > f)
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + o.sharedLength);
        if (!o.transitions) {
          o.transitions = /* @__PURE__ */ Object.create(null);
          for (let I = 0; I < P; I++) {
            let O = o[I];
            if (!O)
              continue;
            let A, G = o.transitions;
            for (let z = 0, $ = O.length; z < $; z++) {
              let te = O[z];
              A = G[te], A || (A = G[te] = /* @__PURE__ */ Object.create(null)), G = A;
            }
            G[Pi] = I + 64;
          }
          c = P;
        }
        d || (o.nextId = P + 64);
      }
      i && (i = false), s = o || [];
      try {
        if (b(x), pr) {
          je.setUint32(pr.position + t, M - pr.position - t);
          let P = pr;
          pr = null, b(P[0]), b(P[1]);
        }
        if (a.offset = M, l && l.idsToInsert) {
          M += l.idsToInsert.length * 6, M > ur && _(M), a.offset = M;
          let P = ox(V.subarray(t, M), l.idsToInsert);
          return l = null, P;
        }
        return C & Eu ? (V.start = t, V.end = M, V) : V.subarray(t, M);
      } finally {
        if (o) {
          if (w < 10 && w++, S > 1e4)
            o.transitions = null, w = 0, S = 0, v.length > 0 && (v = []);
          else if (v.length > 0 && !d) {
            for (let P = 0, I = v.length; P < I; P++)
              v[P][Pi] = 0;
            v = [];
          }
          if (i && a.saveStructures) {
            let P = o.sharedLength || f;
            o.length > P && (o = o.slice(0, P));
            let I = V.subarray(t, M);
            return a.saveStructures(o, c) === false ? (a._mergeStructures(a.getStructures()), a.pack(x)) : (c = P, I);
          }
        }
        C & dx && (M = t);
      }
    };
    let b = (x) => {
      M > ur && (V = _(M));
      var C = typeof x, P;
      if (C === "string") {
        let I = x.length;
        if (pr && I >= 8 && I < 4096) {
          let G = tx.test(x);
          pr[G ? 0 : 1] += x, V[M++] = 193, b(G ? -I : I);
          return;
        }
        let O;
        I < 32 ? O = 1 : I < 256 ? O = 2 : I < 65536 ? O = 3 : O = 5;
        let A = I * 3;
        if (M + A > ur && (V = _(M + A)), I < 64 || !u) {
          let G, z, $, te = M + O;
          for (G = 0; G < I; G++)
            z = x.charCodeAt(G), z < 128 ? V[te++] = z : z < 2048 ? (V[te++] = z >> 6 | 192, V[te++] = z & 63 | 128) : (z & 64512) === 55296 && (($ = x.charCodeAt(G + 1)) & 64512) === 56320 ? (z = 65536 + ((z & 1023) << 10) + ($ & 1023), G++, V[te++] = z >> 18 | 240, V[te++] = z >> 12 & 63 | 128, V[te++] = z >> 6 & 63 | 128, V[te++] = z & 63 | 128) : (V[te++] = z >> 12 | 224, V[te++] = z >> 6 & 63 | 128, V[te++] = z & 63 | 128);
          P = te - M - O;
        } else
          P = u(x, M + O, A);
        P < 32 ? V[M++] = 160 | P : P < 256 ? (O < 2 && V.copyWithin(M + 2, M + 1, M + 1 + P), V[M++] = 217, V[M++] = P) : P < 65536 ? (O < 3 && V.copyWithin(M + 3, M + 2, M + 2 + P), V[M++] = 218, V[M++] = P >> 8, V[M++] = P & 255) : (O < 5 && V.copyWithin(M + 5, M + 3, M + 3 + P), V[M++] = 219, je.setUint32(M, P), M += 4), M += P;
      } else if (C === "number")
        if (x >>> 0 === x)
          x < 64 ? V[M++] = x : x < 256 ? (V[M++] = 204, V[M++] = x) : x < 65536 ? (V[M++] = 205, V[M++] = x >> 8, V[M++] = x & 255) : (V[M++] = 206, je.setUint32(M, x), M += 4);
        else if (x >> 0 === x)
          x >= -32 ? V[M++] = 256 + x : x >= -128 ? (V[M++] = 208, V[M++] = x + 256) : x >= -32768 ? (V[M++] = 209, je.setInt16(M, x), M += 2) : (V[M++] = 210, je.setInt32(M, x), M += 4);
        else {
          let I;
          if ((I = this.useFloat32) > 0 && x < 4294967296 && x >= -2147483648) {
            V[M++] = 202, je.setFloat32(M, x);
            let O;
            if (I < 4 || (O = x * qs[(V[M] & 127) << 1 | V[M + 1] >> 7]) >> 0 === O) {
              M += 4;
              return;
            } else
              M--;
          }
          V[M++] = 203, je.setFloat64(M, x), M += 8;
        }
      else if (C === "object")
        if (!x)
          V[M++] = 192;
        else {
          if (l) {
            let O = l.get(x);
            if (O) {
              if (!O.id) {
                let A = l.idsToInsert || (l.idsToInsert = []);
                O.id = A.push(O);
              }
              V[M++] = 214, V[M++] = 112, je.setUint32(M, O.id), M += 4;
              return;
            } else
              l.set(x, { offset: M - t });
          }
          let I = x.constructor;
          if (I === Object)
            T(x, true);
          else if (I === Array) {
            P = x.length, P < 16 ? V[M++] = 144 | P : P < 65536 ? (V[M++] = 220, V[M++] = P >> 8, V[M++] = P & 255) : (V[M++] = 221, je.setUint32(M, P), M += 4);
            for (let O = 0; O < P; O++)
              b(x[O]);
          } else if (I === Map) {
            P = x.size, P < 16 ? V[M++] = 128 | P : P < 65536 ? (V[M++] = 222, V[M++] = P >> 8, V[M++] = P & 255) : (V[M++] = 223, je.setUint32(M, P), M += 4);
            for (let [O, A] of x)
              b(O), b(A);
          } else {
            for (let O = 0, A = Ks.length; O < A; O++) {
              let G = sc[O];
              if (x instanceof G) {
                let z = Ks[O];
                if (z.write) {
                  z.type && (V[M++] = 212, V[M++] = z.type, V[M++] = 0), b(z.write.call(this, x));
                  return;
                }
                let $ = V, te = je, K = M;
                V = null;
                let q;
                try {
                  q = z.pack.call(this, x, (k) => (V = $, $ = null, M += k, M > ur && _(M), { target: V, targetView: je, position: M - k }), b);
                } finally {
                  $ && (V = $, je = te, M = K, ur = V.length - 10);
                }
                q && (q.length + M > ur && _(q.length + M), M = rx(q, V, M, z.type));
                return;
              }
            }
            T(x, !x.hasOwnProperty);
          }
        }
      else if (C === "boolean")
        V[M++] = x ? 195 : 194;
      else if (C === "bigint") {
        if (x < BigInt(1) << BigInt(63) && x >= -(BigInt(1) << BigInt(63)))
          V[M++] = 211, je.setBigInt64(M, x);
        else if (x < BigInt(1) << BigInt(64) && x > 0)
          V[M++] = 207, je.setBigUint64(M, x);
        else if (this.largeBigIntToFloat)
          V[M++] = 203, je.setFloat64(M, Number(x));
        else
          throw new RangeError(x + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");
        M += 8;
      } else if (C === "undefined")
        this.encodeUndefinedAsNil ? V[M++] = 192 : (V[M++] = 212, V[M++] = 0, V[M++] = 0);
      else if (C === "function")
        b(this.writeFunction && this.writeFunction());
      else
        throw new Error("Unknown type: " + C);
    }, T = this.useRecords === false ? this.variableMapSize ? (x) => {
      let C = Object.keys(x), P = C.length;
      P < 16 ? V[M++] = 128 | P : P < 65536 ? (V[M++] = 222, V[M++] = P >> 8, V[M++] = P & 255) : (V[M++] = 223, je.setUint32(M, P), M += 4);
      let I;
      for (let O = 0; O < P; O++)
        b(I = C[O]), b(x[I]);
    } : (x, C) => {
      V[M++] = 222;
      let P = M - t;
      M += 2;
      let I = 0;
      for (let O in x)
        (C || x.hasOwnProperty(O)) && (b(O), b(x[O]), I++);
      V[P++ + t] = I >> 8, V[P + t] = I & 255;
    } : (x) => {
      let C = Object.keys(x), P, I = s.transitions || (s.transitions = /* @__PURE__ */ Object.create(null)), O = 0;
      for (let G = 0, z = C.length; G < z; G++) {
        let $ = C[G];
        P = I[$], P || (P = I[$] = /* @__PURE__ */ Object.create(null), O++), I = P;
      }
      let A = I[Pi];
      if (A)
        A >= 96 && h ? (V[M++] = ((A -= 96) & 31) + 96, V[M++] = A >> 5) : V[M++] = A;
      else {
        A = s.nextId, A || (A = 64), A < y && this.shouldShareStructure && !this.shouldShareStructure(C) ? (A = s.nextOwnId, A < g || (A = y), s.nextOwnId = A + 1) : (A >= g && (A = y), s.nextId = A + 1);
        let G = C.highByte = A >= 96 && h ? A - 96 >> 5 : -1;
        I[Pi] = A, s[A - 64] = C, A < y ? (C.isShared = true, s.sharedLength = A - 63, i = true, G >= 0 ? (V[M++] = (A & 31) + 96, V[M++] = G) : V[M++] = A) : (G >= 0 ? (V[M++] = 213, V[M++] = 114, V[M++] = (A & 31) + 96, V[M++] = G) : (V[M++] = 212, V[M++] = 114, V[M++] = A), O && (S += w * O), v.length >= m && (v.shift()[Pi] = 0), v.push(I), b(C));
      }
      for (let G = 0, z = C.length; G < z; G++)
        b(x[C[G]]);
    }, _ = (x) => {
      let C;
      if (x > 16777216) {
        if (x - t > Ou)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        C = Math.min(Ou, Math.round(Math.max((x - t) * (x > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
      } else
        C = (Math.max(x - t << 2, V.length - 1) >> 12) + 1 << 12;
      let P = new ic(C);
      return je = new DataView(P.buffer, 0, C), V.copy ? V.copy(P, 0, t, x) : P.set(V.slice(t, x)), M -= t, t = 0, ur = P.length - 10, V = P;
    };
  }
  useBuffer(r) {
    V = r, je = new DataView(V.buffer, V.byteOffset, V.byteLength), M = 0;
  }
};
sc = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, Ti];
Ks = [{ pack(n, r, e) {
  let t = n.getTime() / 1e3;
  if ((this.useTimestamp32 || n.getMilliseconds() === 0) && t >= 0 && t < 4294967296) {
    let { target: o, targetView: i, position: s } = r(6);
    o[s++] = 214, o[s++] = 255, i.setUint32(s, t);
  } else if (t > 0 && t < 17179869184) {
    let { target: o, targetView: i, position: s } = r(10);
    o[s++] = 215, o[s++] = 255, i.setUint32(s, n.getMilliseconds() * 4e6 + (t / 1e3 / 4294967296 >> 0)), i.setUint32(s + 4, t);
  } else if (isNaN(t)) {
    if (this.onInvalidDate)
      return r(0), e(this.onInvalidDate());
    let { target: o, targetView: i, position: s } = r(3);
    o[s++] = 212, o[s++] = 255, o[s++] = 255;
  } else {
    let { target: o, targetView: i, position: s } = r(15);
    o[s++] = 199, o[s++] = 12, o[s++] = 255, i.setUint32(s, n.getMilliseconds() * 1e6), i.setBigInt64(s + 4, BigInt(Math.floor(t)));
  }
} }, { pack(n, r, e) {
  let t = Array.from(n), { target: o, position: i } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (o[i++] = 212, o[i++] = 115, o[i++] = 0), e(t);
} }, { pack(n, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 101, t[o++] = 0), e([n.name, n.message]);
} }, { pack(n, r, e) {
  let { target: t, position: o } = r(this.structuredClone ? 3 : 0);
  this.structuredClone && (t[o++] = 212, t[o++] = 120, t[o++] = 0), e([n.source, n.flags]);
} }, { pack(n, r) {
  this.structuredClone ? Au(n, 16, r) : Iu(Zs ? Buffer.from(n) : new Uint8Array(n), r);
} }, { pack(n, r) {
  let e = n.constructor;
  e !== Cu && this.structuredClone ? Au(n, nc.indexOf(e.name), r) : Iu(n, r);
} }, { pack(n, r) {
  let { target: e, position: t } = r(1);
  e[t] = 193;
} }];
function Au(n, r, e, t) {
  let o = n.byteLength;
  if (o + 1 < 256) {
    var { target: i, position: s } = e(4 + o);
    i[s++] = 199, i[s++] = o + 1;
  } else if (o + 1 < 65536) {
    var { target: i, position: s } = e(5 + o);
    i[s++] = 200, i[s++] = o + 1 >> 8, i[s++] = o + 1 & 255;
  } else {
    var { target: i, position: s, targetView: l } = e(7 + o);
    i[s++] = 201, l.setUint32(s, o + 1), s += 4;
  }
  i[s++] = 116, i[s++] = r, i.set(new Uint8Array(n.buffer, n.byteOffset, n.byteLength), s);
}
function Iu(n, r) {
  let e = n.byteLength;
  var t, o;
  if (e < 256) {
    var { target: t, position: o } = r(e + 2);
    t[o++] = 196, t[o++] = e;
  } else if (e < 65536) {
    var { target: t, position: o } = r(e + 3);
    t[o++] = 197, t[o++] = e >> 8, t[o++] = e & 255;
  } else {
    var { target: t, position: o, targetView: i } = r(e + 5);
    t[o++] = 198, i.setUint32(o, e), o += 4;
  }
  t.set(n, o);
}
function rx(n, r, e, t) {
  let o = n.length;
  switch (o) {
    case 1:
      r[e++] = 212;
      break;
    case 2:
      r[e++] = 213;
      break;
    case 4:
      r[e++] = 214;
      break;
    case 8:
      r[e++] = 215;
      break;
    case 16:
      r[e++] = 216;
      break;
    default:
      o < 256 ? (r[e++] = 199, r[e++] = o) : o < 65536 ? (r[e++] = 200, r[e++] = o >> 8, r[e++] = o & 255) : (r[e++] = 201, r[e++] = o >> 24, r[e++] = o >> 16 & 255, r[e++] = o >> 8 & 255, r[e++] = o & 255);
  }
  return r[e++] = t, r.set(n, e), e += o, e;
}
function ox(n, r) {
  let e, t = r.length * 6, o = n.length - t;
  for (r.sort((i, s) => i.offset > s.offset ? 1 : -1); e = r.pop(); ) {
    let i = e.offset, s = e.id;
    n.copyWithin(i + t, i, o), t -= 6;
    let l = i + t;
    n[l++] = 214, n[l++] = 105, n[l++] = s >> 24, n[l++] = s >> 16 & 255, n[l++] = s >> 8 & 255, n[l++] = s & 255, o = i;
  }
  return n;
}
function Xr(n) {
  if (n.Class) {
    if (!n.pack && !n.write)
      throw new Error("Extension has no pack or write function");
    if (n.pack && !n.type)
      throw new Error("Extension has no type (numeric code to identify the extension)");
    sc.unshift(n.Class), Ks.unshift(n);
  }
  Pu(n);
}
var Nu = new vo({ useRecords: false });
var nx = Nu.pack;
var ix = Nu.pack;
var { NEVER: sx, ALWAYS: ax, DECIMAL_ROUND: lx, DECIMAL_FIT: cx } = Ys;
var Eu = 512;
var dx = 1024;
var Mu = new vo({ structuredClone: true });
Xr({ Class: Ie.prototype.constructor, type: 1, write(n) {
  return { ...n };
}, read(n) {
  return Object.setPrototypeOf(n, Ie.prototype), n;
} });
Xr({ Class: he.prototype.constructor, type: 2, write(n) {
  return [...n];
}, read(n) {
  return Object.setPrototypeOf(n, he.prototype), n;
} });
Xr({ Class: ze.prototype.constructor, type: 3, write(n) {
  return [...n];
}, read(n) {
  return Object.setPrototypeOf(n, ze.prototype), n;
} });
Xr({ Class: wi.prototype.constructor, type: 4, write(n) {
  return n.id;
}, read(n) {
  return new wi(n);
} });
Xr({ Class: _i.prototype.constructor, type: 5, write(n) {
  return n.data;
}, read(n) {
  return new _i(n);
} });
Xr({ Class: Be.prototype.constructor, type: 6, write(n) {
  return { ...n };
}, read(n) {
  return Object.setPrototypeOf(n, Be.prototype), n;
} });
function ux(n) {
  var r = 0;
  if (n.length === 0)
    return r;
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    r = (r << 5) - r + t, r = r & r;
  }
  return r;
}
function ac(n) {
  if ($o(n))
    return n;
  if (Array.isArray(n))
    return n.map(ac);
  if (typeof n == "object" && n !== null) {
    let r = {};
    for (let e of Object.keys(n).sort())
      r[e] = ac(n[e]);
    return Object.setPrototypeOf(r, Object.getPrototypeOf(n)), r;
  } else
    return n;
}
var Qs;
((t) => {
  function n(o) {
    return Mu.pack(o);
  }
  t.serialize = n;
  function r(o) {
    return Mu.unpack(o);
  }
  t.deserialize = r;
  function e(o) {
    return ux(n(ac(o))).toString();
  }
  t.checksum = e;
})(Qs || (Qs = {}));
var Lu;
((e) => {
  function n(t, o) {
    return t[0] === o[0] && t[1] === o[1];
  }
  e.isEqual = n;
  function r(t, o, i) {
    return [t[0] + (o[0] - t[0]) * i, t[1] + (o[1] - t[1]) * i];
  }
  e.lerp = r;
})(Lu || (Lu = {}));
var Kr;
((l) => {
  function n(c, u) {
    return c[0] === u[0] && c[1] === u[1] && c[2] === u[2];
  }
  l.isEqual = n;
  function r(c, u) {
    return [c[0] + u[0], c[1] + u[1], c[2] + u[2]];
  }
  l.add = r;
  function e(c, u) {
    return [c[0] - u[0], c[1] - u[1], c[2] - u[2]];
  }
  l.sub = e;
  function t(c, u) {
    return [c[0] / u[0], c[1] / u[1], c[2] / u[2]];
  }
  l.div = t;
  function o(c, u) {
    return [c[0] * u[0], c[1] * u[1], c[2] * u[2]];
  }
  l.mul = o;
  function i(c, u) {
    return Math.hypot(c[0] - u[0], c[1] - u[1], c[2] - u[2]);
  }
  l.dist = i;
  function s(c, u, a) {
    return [c[0] + (u[0] - c[0]) * a, c[1] + (u[1] - c[1]) * a, c[2] + (u[2] - c[2]) * a];
  }
  l.lerp = s;
})(Kr || (Kr = {}));
var Bu;
((e) => {
  function n(t, o) {
    return t[0] === o[0] && t[1] === o[1] && t[2] === o[2] && t[3] === o[3];
  }
  e.isEqual = n;
  function r(t, o, i) {
    return [t[0] + (o[0] - t[0]) * i, t[1] + (o[1] - t[1]) * i, t[2] + (o[2] - t[2]) * i, t[3] + (o[3] - t[3]) * i];
  }
  e.lerp = r;
})(Bu || (Bu = {}));
var Zr;
((o) => {
  o.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  function r(i, s) {
    for (let l = 0; l < 16; l++)
      if (i[l] !== s[l])
        return false;
    return true;
  }
  o.isEqual = r;
  function e(i) {
    return i ?? o.identity;
  }
  o.simplify = e;
  function t(i, s) {
    let l = s.slice(0);
    for (var c = 0, u = s.length; c < u; c += 3) {
      let a = i[3] * s[c] + i[7] * s[c + 1] + i[11] * s[c + 2] + i[15];
      l[c] = (i[0] * s[c] + i[4] * s[c + 1] + i[8] * s[c + 2] + i[12]) / a, l[c + 1] = (i[1] * s[c] + i[5] * s[c + 1] + i[9] * s[c + 2] + i[13]) / a, l[c + 2] = (i[2] * s[c] + i[6] * s[c + 1] + i[10] * s[c + 2] + i[14]) / a;
    }
    return l;
  }
  o.applyMatrix4 = t;
})(Zr || (Zr = {}));
var St;
((u) => {
  function n(a) {
    return typeof a == "object" && typeof a.r == "number" && typeof a.g == "number" && typeof a.b == "number";
  }
  u.isRGB = n, u.white = { r: 1, g: 1, b: 1 }, u.red = { r: 1, g: 0, b: 0 }, u.black = { r: 0, g: 0, b: 0 };
  function o(a) {
    return { r: Math.round(a.r * 255), g: Math.round(a.g * 255), b: Math.round(a.b * 255), a: 1 };
  }
  u.toRgb255a1 = o;
  function i(a) {
    return { r: a.r, g: a.g, b: a.b };
  }
  u.clone = i;
  function s(a) {
    return a = Math.floor(a), { r: (a >> 16 & 255) / 255, g: (a >> 8 & 255) / 255, b: (a & 255) / 255 };
  }
  u.fromHex = s;
  function l(a, d) {
    return a.r === d.r && a.g === d.g && a.b === d.b;
  }
  u.equals = l;
  function c(a, d, p) {
    return { r: a.r + (d.r - a.r) * p, g: a.g + (d.g - a.g) * p, b: a.b + (d.b - a.b) * p };
  }
  u.lerp = c;
})(St || (St = {}));
var $t;
((l) => {
  l.white = { ...St.white, a: 1 }, l.transparent = { ...St.white, a: 0 };
  function e(c) {
    return { r: c[0], g: c[1], b: c[2], a: c[3] };
  }
  l.from0to1 = e;
  function t(c, u) {
    return { ...St.fromHex(c), a: u };
  }
  l.fromHexAndA = t;
  function o(c) {
    return { r: Math.round(c.r * 255), g: Math.round(c.g * 255), b: Math.round(c.b * 255), a: c.a };
  }
  l.toRgb255a1 = o;
  function i(c, u) {
    return St.equals(c, u) && c.a === u.a;
  }
  l.equals = i;
  function s(c, u, a) {
    return { r: c.r + (u.r - c.r) * a, g: c.g + (u.g - c.g) * a, b: c.b + (u.b - c.b) * a, a: c.a + (u.a - c.a) * a };
  }
  l.lerp = s;
})($t || ($t = {}));
var Js;
((r) => r.identity = { position: [0, 0, 0], rotation: [0, 0, 0], scale: [1, 1, 1] })(Js || (Js = {}));
var Du;
((r) => r.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 })(Du || (Du = {}));
var Gu;
((r) => r.defaultData = { control1: [0.5, 0.05], control2: [0.1, 0.3] })(Gu || (Gu = {}));
var Yt;
((e) => {
  e.all = ["PerspectiveCamera", "OrthographicCamera"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(Yt || (Yt = {}));
var bo;
((o) => {
  o.DefaultUp = [0, 1, 0], o.DefaultTargetOffset = 1e3, o.defaultData = { far: 1e5, type: "OrthographicCamera", perspective: { near: 70, fov: 45, zoom: 1 }, orthographic: { near: -1e5, zoom: 1, autoZoom: false, autoZoomFrustumSize: 790 }, up: o.DefaultUp, isUpVectorFlipped: false, targetOffset: o.DefaultTargetOffset };
  function t(i) {
    return i.type === "PerspectiveCamera" ? i.perspective.zoom : i.orthographic.zoom;
  }
  o.getZoom = t;
})(bo || (bo = {}));
var fr;
((e) => {
  function n(t, o = 0.1) {
    return { disabled: false, type: "linear", hideBase: false, count: 3, radial: { radius: Math.max(t[0], t[1]) * 2, start: 0, end: 360, alignment: false, axis: "y", scale: [1, 1, 1], rotation: [0, 0, 0], position: [0, 0, 0] }, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, linear: { scale: [1, 1, 1], rotation: [0, 0, 0], position: [t[0] + t[0] * o, 0, 0] }, grid: { count: [2, 2, 2], size: t.map((i) => i * (1 + o)), useCenter: true }, randomness: false, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } };
  }
  e.defaultData = n;
  function r(t, o) {
    let i = { ...t };
    if (px.forEach((s) => {
      Object.assign(i, { [s]: o[s] ?? t[s] });
    }), i.radial = { ...t.radial }, o.radial) {
      let s = t.radial, l = o.radial;
      fx.forEach((c) => {
        Object.assign(i.radial, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.linear = { ...t.linear }, o.linear) {
      let s = t.linear, l = o.linear;
      mx.forEach((c) => {
        Object.assign(i.linear, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.grid = { ...t.grid }, o.grid) {
      let s = t.grid, l = o.grid;
      hx.forEach((c) => {
        Object.assign(i.grid, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.toObject = { ...t.toObject }, o.toObject) {
      let s = t.toObject, l = o.toObject;
      yx.forEach((c) => {
        Object.assign(i.toObject, { [c]: l[c] ?? s[c] });
      });
    }
    if (i.randomnessObject = { ...t.randomnessObject }, o.randomnessObject) {
      let s = t.randomnessObject, l = o.randomnessObject;
      gx.forEach((c) => {
        Object.assign(i.randomnessObject, { [c]: l[c] ?? s[c] });
      });
    }
    return i;
  }
  e.merge = r;
})(fr || (fr = {}));
var ea;
((t) => {
  t.defaultData = { radial: {}, linear: {}, grid: {}, toObject: {}, randomnessObject: {} };
  let r = ["radial", "linear", "grid", "toObject", "randomnessObject"];
  function e(o, i) {
    let s = [];
    o.count !== void 0 && s.push({ type: 0, path: i, props: { count: o.count } });
    for (let l of r) {
      let c = o[l];
      c && Object.keys(c).length > 0 && s.push({ type: 0, path: [...i, l], props: c });
    }
    return s;
  }
  t.toOps = e;
})(ea || (ea = {}));
var px = ["count"];
var fx = ["radius", "start", "end", "position", "scale", "rotation"];
var mx = ["position", "scale", "rotation"];
var hx = ["count", "size"];
var yx = ["count", "position", "scale", "rotation"];
var gx = ["strength", "scale", "rotation", "position", "movement", "seed", "freqScale"];
var ta;
((e) => {
  e.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"];
  function r(t) {
    return e.all.includes(t);
  }
  e.is = r;
})(ta || (ta = {}));
var ra;
((e) => {
  function n(t) {
    return r(t);
  }
  e.defaultData = n;
  function r(t) {
    if (t === "PointLight")
      return { type: t, color: $t.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, shadowResolution: 1024, shadowRadius: 1, depth: 1e5 };
    if (t === "SpotLight")
      return { type: t, color: $t.white, intensity: 1, distance: 2e3, decay: 1, shadows: true, penumbra: 0, angle: 30 / 180 * Math.PI, depth: 1e5, shadowResolution: 1024, shadowRadius: 1 };
    if (t === "DirectionalLight")
      return { type: t, color: $t.white, intensity: 1, shadows: true, size: 1e3, depth: 1e5, shadowResolution: 1024, shadowRadius: 1 };
    throw new Error("not implemented");
  }
})(ra || (ra = {}));
var lc;
((e) => {
  e.defaultData = { castShadow: true, receiveShadow: true };
  function r(t, o) {
    return t.castShadow === o.castShadow && t.receiveShadow === o.receiveShadow;
  }
  e.equals = r;
})(lc || (lc = {}));
var cc;
((e) => {
  e.defaultData = { flatShading: false, wireframe: false, side: 0 };
  function r(t, o) {
    return t.flatShading === o.flatShading && t.side === o.side && t.wireframe === o.wireframe;
  }
  e.equals = r;
})(cc || (cc = {}));
var oa;
((r) => r.defaultData = { ...cc.defaultData, ...lc.defaultData })(oa || (oa = {}));
var en;
((e) => (e.defaultVideo = { data: "", thumb: "/_assets/_videos/catThumb.png", type: "video", name: "Cat video" }, e.maxSize = 3e7))(en || (en = {}));
var Ru = ["mode", "gradientType", "noiseType", "displacementType", "projection", "cnormal", "crop", "axis", "side"];
var Vu = ["wrapping", "image", "video"];
var ft;
((o) => {
  function n(i, s) {
    let { texture: l, ...c } = s;
    if (Object.assign(i, c), l) {
      let u = i.texture;
      u && Object.assign(u, l);
    }
  }
  o.patch = n;
  function r(i, s) {
    return i === "light" && s ? e(s) : t(i);
  }
  o.defaultData = r;
  function e(i) {
    switch (i) {
      case "phong":
        return { category: "phong", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 5, type: "light", alpha: 0.6, visible: true, mode: 0 };
      case "toon":
        return { category: "toon", specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 10, type: "light", alpha: 1, visible: true, mode: 0 };
      case "lambert":
        return { category: "lambert", emissive: { r: 0, g: 0, b: 0 }, type: "light", alpha: 1, visible: true, mode: 0 };
      case "physical":
        return { category: "physical", roughness: 0.2, metalness: 0.2, reflectivity: 0.2, type: "light", alpha: 1, visible: true, mode: 0 };
    }
  }
  function t(i) {
    switch (i) {
      case "texture":
        return { alpha: 1, visible: true, size: [128, 128], mode: 0, axis: "x", side: 2, type: "texture", projection: 0, texture: { image: "image_0", wrapping: 1e3, repeat: [1, 1], offset: [0, 0] }, crop: false };
      case "video":
        return { alpha: 1, visible: true, size: [128, 128], mode: 0, axis: "x", side: 2, type: "video", projection: 0, texture: { video: en.defaultVideo, wrapping: 1001, repeat: [1, 1], offset: [0, 0] }, crop: true };
      case "color":
        return { type: "color", alpha: 1, visible: true, mode: 0, color: St.fromHex(4737101) };
      case "depth":
        return { type: "depth", alpha: 1, visible: true, mode: 0, gradientType: 1, smooth: false, isVector: true, isWorldSpace: false, origin: [0, 0, 0], direction: [1, 0, 0], colors: [[1, 1, 1, 1], [0, 0, 0, 1]], steps: [0, 1], near: 50, far: 200 };
      case "normal":
        return { type: "normal", alpha: 1, visible: true, mode: 0, cnormal: [1, 1, 1] };
      case "gradient":
        return { type: "gradient", alpha: 1, visible: true, mode: 0, gradientType: 0, smooth: false, colors: [[0, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], num: 2, angle: 0, offset: [0, 0], morph: [0, 0] };
      case "noise":
        return { type: "noise", alpha: 1, visible: true, mode: 0, size: [100, 100, 100], noiseType: 0, scale: 1, move: 1, colorA: { ...St.fromHex(6710886), a: 1 }, colorB: { ...St.fromHex(6710886), a: 1 }, colorC: { ...St.fromHex(16777215), a: 1 }, colorD: { ...St.fromHex(16777215), a: 1 }, distortion: [1, 1], fA: [1.7, 9.2], fB: [8.3, 2.8] };
      case "fresnel":
        return { type: "fresnel", alpha: 1, visible: true, mode: 0, color: $t.fromHexAndA(16777215, 1), bias: 0.1, scale: 1, intensity: 2, factor: 1 };
      case "rainbow":
        return { type: "rainbow", alpha: 1, visible: true, mode: 0, filmThickness: 30, movement: 0, wavelengths: [0, 0, 0], noiseStrength: 0, noiseScale: 1, offset: [0, 0, 0] };
      case "toon":
        return { type: "toon", alpha: 1, visible: true, mode: 0, positioning: 2, colors: [[0, 0, 0, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1], num: 4, source: [0, 1e3, 0], isWorldSpace: true, noiseStrength: 0, noiseScale: 1, shadowColor: $t.fromHexAndA(0, 0), offset: [0, 0, 0] };
      case "outline":
        return { type: "outline", alpha: 1, visible: true, mode: 0, outlineColor: $t.fromHexAndA(0, 1), contourColor: $t.fromHexAndA(0, 1), outlineWidth: 2, contourWidth: 5, outlineThreshold: 0.4, contourThreshold: 0, outlineSmoothing: 0, contourFrequency: 10, contourDirection: [0, 1, 0], positionalLines: false, compensation: true };
      case "matcap":
        return { type: "matcap", alpha: 1, visible: true, mode: 0, texture: { image: "matcap_0", wrapping: 1001, repeat: [1, 1], offset: [0, 0] } };
      case "transmission":
        return { type: "transmission", alpha: 1, visible: true, mode: 0, thickness: 10, ior: 1.5, roughness: 1 };
      case "displace":
        return { type: "displace", displacementType: "noise", noiseType: 0, scale: 10, movement: 1, offset: [0, 0, 0], intensity: 8, visible: true };
    }
  }
})(ft || (ft = {}));
var wt;
((c) => {
  function n(u) {
    return !u.layers.some((d) => d.data.type === "texture" && d.data.projection !== 0 || d.data.type === "depth" && !d.data.isWorldSpace || d.data.type === "noise" || d.data.type === "displace");
  }
  c.isMergable = n;
  function r(u) {
    let a = "";
    return u.layers.forEach((d) => {
      Object.entries(d.data).forEach(([p, f]) => {
        a += `${p}${f}`, Array.isArray(f) ? f.forEach((m) => a += `${m}`) : typeof f == "object" ? Object.values(f).forEach((m) => {
          typeof m == "number" ? a += `${m.toFixed(4)}` : a += `${m}`;
        }) : a += `${f}`;
      });
    }), a;
  }
  c.getHash = r;
  function e() {
    return { layers: new he() };
  }
  c.defaultEmptyData = e;
  function t(u = "layer1", a = "layer2") {
    return i("phong", u, a);
  }
  c.defaultData = t;
  function o(u, a) {
    return { ...u, name: a };
  }
  c.withName = o;
  function i(u, a = "layer1", d = "layer2") {
    let p = new he();
    return p.push({ fi: 0, data: ft.defaultData("light", u), id: a }), p.push({ fi: 1, data: ft.defaultData("color"), id: d }), { layers: p };
  }
  c.defaultTwoLayerData = i;
  function s(u, a = "phong", d = "layer1", p = "layer2") {
    let f = ft.defaultData("texture");
    Object.assign(f.texture, { image: u });
    let m = new he();
    return m.push({ fi: 0, data: f, id: d }), m.push({ fi: 1, data: ft.defaultData("light", a), id: p }), { layers: m };
  }
  c.defaultTwoLayerTextureData = s;
  function l(u, a = "phong", d = "layer1", p = "layer2") {
    let f = ft.defaultData("video");
    Object.assign(f.texture, { video: u });
    let m = new he();
    return m.push({ fi: 0, data: f, id: d }), m.push({ fi: 1, data: ft.defaultData("light", a), id: p }), { layers: m };
  }
  c.defaultTwoLayerVideoTextureData = l;
})(wt || (wt = {}));
var tn;
((r) => {
  function n() {
    return { points: new he(), roundness: 0, shapeHoles: [], isClosed: false };
  }
  r.defaultData = n;
})(tn || (tn = {}));
var rn;
((r) => {
  function n() {
    return { points: new he(), lastInsertionPlane: null, subdivisions: 12, isClosed: false };
  }
  r.defaultData = n;
})(rn || (rn = {}));
var dc = { type: "Ellipse", width: 100, height: 100, spikes: 64, angle: 360, innerRadius: 0 };
var na;
((r) => {
  function n(e, t) {
    let o = { ...e };
    return xx.forEach((i) => {
      Object.assign(o, { [i]: t[i] ?? e[i] });
    }), o;
  }
  r.merge = n;
})(na || (na = {}));
var ia = { shape: dc, depth: 1, offset: 0, bevel: 0, bevelSides: 1, angle: 0, twist: 0, startScale: 1, endScale: 1 };
var xx = ["depth", "offset", "angle", "twist", "startScale", "endScale"];
var Oi;
((r) => {
  function n(e) {
    return e === "PolygonGeometry" || e === "RectangleGeometry" || e === "StarGeometry" || e === "TriangleGeometry" || e === "EllipseGeometry";
  }
  r.is2DParametricMesh = n;
})(Oi || (Oi = {}));
var sa;
((r) => {
  function n(e, t) {
    let o = { ...e };
    return Object.assign(o, t), o.type === "PathGeometry" && "extrusion" in t && t.extrusion && (o.extrusion = { ...e.extrusion }, Object.assign(o.extrusion, na.merge(o.extrusion, t.extrusion))), o;
  }
  r.merge = n;
})(sa || (sa = {}));
var Qr;
((r) => {
  function n(e) {
    if (e === "RectangleGeometry")
      return { width: 320, height: 320, type: e, cornerRadius: [0, 0, 0, 0], cornerType: 0, depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "PathGeometry")
      return { type: e, width: 1, height: 1, depth: 1, path: rn.defaultData(), extrusion: ia };
    if (e === "VectorGeometry")
      return { width: 1, height: 1, type: e, subdivisions: 12, shape: tn.defaultData(), depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    if (e === "BooleanGeometry")
      return { type: e, operation: 2, width: 0, height: 0, depth: 0, phongAngle: 35 };
    if (e === "TextGeometry")
      return { type: e, width: 100, height: 100, depth: 0, horizontalAlign: 1, verticalAlign: 1, fontSize: 16, lineHeight: 1.2, letterSpacing: 0, text: "", textTransform: 1, font: "Roboto_regular", extrudeBevelSize: 0, extrudeBevelSegments: 1 };
    throw new Error("not implemented");
  }
  r.defaultData = n;
})(Qr || (Qr = {}));
var ju;
((e) => {
  function n(t) {
    return t === "Component" || t === "Instance";
  }
  e.isComponentRelated = n;
  function r(t) {
    return t === "Empty" || t === "Instance";
  }
  e.isEmptyOrComponent = r;
})(ju || (ju = {}));
var on;
((o) => {
  o.identity = { ...Js.identity, hiddenMatrix: Zr.identity };
  function r(i) {
    return { position: i.position, rotation: i.rotation, scale: i.scale, hiddenMatrix: i.hiddenMatrix };
  }
  o.fromObject = r;
  function e(i, s) {
    return { position: (s == null ? void 0 : s.position) || i.position, rotation: (s == null ? void 0 : s.rotation) || i.rotation, scale: (s == null ? void 0 : s.scale) || i.scale, hiddenMatrix: (s == null ? void 0 : s.hiddenMatrix) || i.hiddenMatrix };
  }
  o.merge = e;
  function t(i, s) {
    return { position: Kr.isEqual(i.position, s.position) ? null : s.position, rotation: Kr.isEqual(i.rotation, s.rotation) ? null : s.rotation, scale: Kr.isEqual(i.scale, s.scale) ? null : s.scale, hiddenMatrix: Zr.isEqual(i.hiddenMatrix, s.hiddenMatrix) ? null : s.hiddenMatrix };
  }
  o.diff = t;
})(on || (on = {}));
var uc;
((r) => r.defaultData = { fusedBody: true, rigidBody: "positioned", density: 1, pointMass: 0, gravityScale: 1, friction: 0.5, damping: 0, restitution: 0.2, colliderType: "convex", enabledRotation: [true, true, true], enabledTranslation: [true, true, true] })(uc || (uc = {}));
var Et;
((r) => r.defaultData = { states: new he(), events: new he(), visible: true, raycastLock: false, physics: null, pathSnapping: { pathId: null, slide: 0, offset: 0, orientation: "tangential" }, ...on.identity, cloner: null })(Et || (Et = {}));
var Fu;
((r) => r.defaultData = { type: "Empty", ...Et.defaultData })(Fu || (Fu = {}));
var zu;
((r) => r.defaultData = { type: "Component", ...Et.defaultData })(zu || (zu = {}));
var So;
((r) => r.defaultData = { type: "Mesh", ...Et.defaultData, ...oa.defaultData })(So || (So = {}));
var nn;
((r) => r.defaultData = { ...Et.defaultData, ...on.identity, ...bo.defaultData })(nn || (nn = {}));
var Uu;
((r) => {
  function n(e) {
    return { ...Et.defaultData, ...ra.defaultData(e) };
  }
  r.defaultData = n;
})(Uu || (Uu = {}));
var sn;
((e) => {
  function n(t, o, i = 0) {
    for (; i < o.length; ) {
      let s = t ? t[o[i]] : void 0;
      if (o.length === i + 1)
        return s;
      if (s)
        t = s.descendants, i += 1;
      else
        return;
    }
  }
  e.resolveWithDes = n;
  function r(t, o, i = 0) {
    let s = n(t, o, i);
    if (s) {
      let l = Object.keys(s);
      if (l.length === 1 && l[0] === "descendants")
        return;
    }
    return s;
  }
  e.resolve = r;
})(sn || (sn = {}));
var Jr;
((i) => {
  i.rootOverrideProps = ["physics"], i.compositeNonOptionalOverrideProps = ["geometry"], i.compositeEntireOverrideOverrideProps = ["material"];
  function t(s, l) {
    return { ...Et.defaultData, ...l, component: s, overrides: new Be(), physics: void 0, type: "Instance" };
  }
  i.ofComponent = t;
  function o(s) {
    let l = on.fromObject(s.data);
    return t(s.id, l);
  }
  i.fromComponentData = o;
})(Jr || (Jr = {}));
var ku;
((i) => (i.defaultCamera = { position: [0, 0, 1e3], scale: [1, 1, 1], rotation: [0, 0, 0], hiddenMatrix: Zr.identity, name: "Play Camera", visible: true, raycastLock: false, physics: uc.defaultData, states: new he(), events: new he(), cloner: null, pathSnapping: { pathId: null, orientation: "tangential", slide: 0, offset: 0 }, ...bo.defaultData }, i.KeysByResetCategory = { States: ["states"], Events: ["events"], Material: ["material", "materials"], Geometry: ["geometry"], Position: ["position"], Rotation: ["rotation"], Scale: ["scale"], Transform: ["position", "scale", "rotation", "hiddenMatrix"], Name: ["name"], Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"], Shadows: ["castShadow", "receiveShadow"], Cloner: ["cloner"], Physics: ["physics"] }, i.defaultMeshObject = { name: "Rectangle", ...Et.defaultData, ...So.defaultData, geometry: Qr.defaultData("RectangleGeometry"), material: wt.defaultTwoLayerData("phong", "layer1", "layer2") }, i.defaultBooleanObject = { name: "Boolean", ...Et.defaultData, ...So.defaultData, geometry: Qr.defaultData("BooleanGeometry"), material: wt.defaultTwoLayerData("phong", "layer1", "layer2") }, i.defaultTextObject = { name: "Text", ...Et.defaultData, ...So.defaultData, geometry: Qr.defaultData("TextGeometry"), material: wt.defaultTwoLayerData("phong", "layer1", "layer2") }))(ku || (ku = {}));
var wo;
((o) => {
  function n(i, s) {
    let l = { name: s };
    return i.type === "Mesh" ? (l.geometry = {}, "material" in i && (l.material = { layers: new Be() }), "materials" in i && (l.materials = i.materials.map((c) => ({ layers: new Be() })))) : Yt.is(i.type) && (l.perspective = {}, l.orthographic = {}), l;
  }
  o.newEmpty = n;
  function r(i, s) {
    if (s === void 0)
      return i;
    let l = { ...i };
    return "material" in l && "material" in s && s.material && (l.material = Qo(l.material, (c) => {
      if (typeof c != "string")
        for (let [u, a] of Object.entries(s.material.layers)) {
          let d = c.layers.data(u);
          d && ft.patch(d, a);
        }
    }).data), l.materials && s.materials && (l.materials = Qo(l.materials, (c) => {
      var _a2, _b2;
      for (let u = 0; u < l.materials.length; u++) {
        let a = s.materials[u];
        if (typeof a != "string")
          for (let [d, p] of Object.entries(a.layers)) {
            let f = (_b2 = (_a2 = c[u]) == null ? void 0 : _a2.layers) == null ? void 0 : _b2.data(d);
            f && ft.patch(f, p);
          }
      }
    }).data), l;
  }
  function e(i, s) {
    let l, c = [], u = { orthographic: 0, perspective: 0, geometry: 0 };
    function a(d, p) {
      for (let [f, m] of Object.entries(p.layers)) {
        let { texture: h, ...y } = m;
        if (h !== void 0 && Object.keys(h).length > 0) {
          let g = { path: [...d, "layers", f, "texture"], props: h, type: 0 };
          c.push(g);
        }
        if (Object.keys(y).length > 0) {
          let g = { path: [...d, "layers", f], props: y, type: 0 };
          c.push(g);
        }
      }
    }
    for (let [d, p] of Object.entries(s))
      if (d !== "name")
        if (d === "cloner")
          c.push(...ea.toOps(p, ["cloner"]));
        else if (d === "pathSnapping")
          c.push({ path: [d], props: { slide: p.slide, offset: p.offset }, type: 0 });
        else if (d === "material")
          a(["material"], p);
        else if (d === "materials")
          for (let [f, m] of Object.entries(p))
            a(["materials", f], m);
        else if (u[d] === 0) {
          if (d === "geometry" && p.extrusion !== void 0) {
            let f = { path: [d, "extrusion"], props: p.extrusion, type: 0 };
            c.push(f), p = { ...p }, delete p.extrusion;
          }
          if (Object.keys(p).length > 0) {
            let f = { path: [d], props: p, type: 0 };
            c.push(f);
          }
        } else
          l === void 0 && (l = { path: [], props: {}, type: 0 }, c.push(l)), l.props[d] = p;
    return c;
  }
  o.toOps = e;
  function t(i, s) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    if (s === void 0)
      return i;
    let l = { ...i };
    if (Object.assign(l, on.merge(l, s)), Object.assign(l, { pathSnapping: Object.assign({}, l.pathSnapping, { slide: ((_a2 = s.pathSnapping) == null ? void 0 : _a2.slide) ?? ((_b2 = l.pathSnapping) == null ? void 0 : _b2.slide) ?? 0, offset: ((_c2 = s.pathSnapping) == null ? void 0 : _c2.offset) ?? ((_d2 = l.pathSnapping) == null ? void 0 : _d2.offset) ?? 0 }) }), Yt.is(i.type)) {
      l.orthographic = { ...l.orthographic }, l.perspective = { ...l.perspective };
      let c = s;
      ((_e2 = c.orthographic) == null ? void 0 : _e2.zoom) !== void 0 && (l.orthographic.zoom = c.orthographic.zoom), ((_f2 = c.perspective) == null ? void 0 : _f2.zoom) !== void 0 && (l.perspective.zoom = c.perspective.zoom), c.isUpVectorFlipped !== void 0 && (l.isUpVectorFlipped = c.isUpVectorFlipped), c.targetOffset !== void 0 && (l.targetOffset = c.targetOffset);
    } else if (i.type === "Mesh")
      "geometry" in s && Object.assign(l, { geometry: sa.merge(l.geometry, s.geometry) }), (s.material || s.materials) && (l = r(l, s)), l.cloner && "cloner" in s && Object.assign(l, { cloner: fr.merge(l.cloner, s.cloner) });
    else if (i.type === "Empty")
      l.cloner && "cloner" in s && Object.assign(l, { cloner: fr.merge(l.cloner, s.cloner) });
    else if (ta.is(i.type)) {
      let c = s;
      c.intensity !== void 0 && (l.intensity = c.intensity), c.color !== void 0 && (typeof c.color == "string" ? l.color = c.color : l.color = St.clone(c.color));
    }
    return l;
  }
  o.patch = t;
})(wo || (wo = {}));
var an;
((r) => r.defaultData = { enablePan: true, enableZoom: true, enableRotate: true, enableDamping: true, rotationLimitsMode: 0, rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationSoftLimit: 2, panLimitsMode: 0, panVerticalOffset: { min: 250, max: 250 }, panHorizontalOffset: { min: 250, max: 250 }, panSoftLimit: 2, zoomLimitsEnabled: false, zoomLimits: { min: 0.1, max: 2 }, autoRotate: false, autoRotateSpeed: 2, autoRotateClockwise: true, hoverRotatePanMode: 0, hoverRotatePanStrength: 20, isTouchZoom: true, orbitTouches: 2, panTouches: 3, resetHoverEffectOnPointerLeave: true, autoZoom: false })(an || (an = {}));
var aa;
((r) => r.defaultData = { orbitControls: an.defaultData, playCamera: null, withBackground: true, preventScroll: false, preventTouchScroll: false, hideCursor: false, mouseEventTarget: "canvas", settings: { image: { format: "jpg", ratio: 1 }, video: { format: "mp4", imageFormat: "jpg", fps: 30, mbps: 80, ratio: typeof window < "u" ? Math.floor(window.devicePixelRatio) : 1, stopMode: "manual", duration: 5e3 }, web: { logo: true, compress: true, preset: 1, preload: true, hint: false } }, stopRaycast: true, joystickSizeAndXYOffset: Array(12).fill(0).map((e, t) => {
  let o = 0, i = 0;
  return t < 5 ? i = -30 : t < 10 && (i = 30), t === 0 || t === 10 || t === 5 ? o = 30 : (t === 4 || t === 11 || t === 9) && (o = -30), [120, [o, i], "show"];
}), gameControlObject: null })(aa || (aa = {}));
function Lr(n, r) {
  return Object.setPrototypeOf(n, r), n;
}
function la(n) {
  return Array.isArray(n) ? n : [n];
}
function Hu(n, r) {
  let e = 0;
  for (; e < n.length && e < r.length; ) {
    if (n[e] < r[e])
      return -1;
    if (n[e] > r[e])
      return 1;
    e += 1;
  }
  return e !== r.length ? -1 : e !== n.length ? 1 : 0;
}
var ln;
((r) => r.emptyImage = { data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=" })(ln || (ln = {}));
var ca;
((t) => {
  function n() {
    let o = {};
    return o["89b10010-844c-11ec-a8a3-0242ac120002"] = { r: 0.5, g: 0.5, b: 0.5, a: 1, name: "Default Color" }, Lr(o, Ie.prototype);
  }
  t.defaultColors = n;
  function r(o) {
    let i = {};
    return (o == null ? void 0 : o.withAITexture) && (i["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = { ...ln.emptyImage, name: "AI generated image" }), Lr(i, Ie.prototype);
  }
  t.defaultImages = r;
  function e() {
    return { materials: new Ie(), images: new Ie(), videos: new Ie(), colors: new Ie(), audios: new Ie(), fonts: new Ie(), penumbraSize: [0.5, 0.5, 0.5] };
  }
  t.emptyData = e;
})(ca || (ca = {}));
var vx = typeof global == "object" && global && global.Object === Object && global;
var da = vx;
var bx = typeof self == "object" && self && self.Object === Object && self;
var Sx = da || bx || Function("return this")();
var Ue = Sx;
var wx = Ue.Symbol;
var Ke = wx;
var Wu = Object.prototype;
var _x = Wu.hasOwnProperty;
var Tx = Wu.toString;
var Ii = Ke ? Ke.toStringTag : void 0;
function Px(n) {
  var r = _x.call(n, Ii), e = n[Ii];
  try {
    n[Ii] = void 0;
    var t = true;
  } catch {
  }
  var o = Tx.call(n);
  return t && (r ? n[Ii] = e : delete n[Ii]), o;
}
var qu = Px;
var Ox = Object.prototype;
var Ax = Ox.toString;
function Ix(n) {
  return Ax.call(n);
}
var $u = Ix;
var Cx = "[object Null]";
var Nx = "[object Undefined]";
var Yu = Ke ? Ke.toStringTag : void 0;
function Ex(n) {
  return n == null ? n === void 0 ? Nx : Cx : Yu && Yu in Object(n) ? qu(n) : $u(n);
}
var Mt = Ex;
function Mx(n) {
  return n != null && typeof n == "object";
}
var ot = Mx;
var Lx = "[object Symbol]";
function Bx(n) {
  return typeof n == "symbol" || ot(n) && Mt(n) == Lx;
}
var cn = Bx;
function Dx(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length, o = Array(t); ++e < t; )
    o[e] = r(n[e], e, n);
  return o;
}
var ua = Dx;
var Gx = Array.isArray;
var Ve = Gx;
var Rx = 1 / 0;
var Xu = Ke ? Ke.prototype : void 0;
var Ku = Xu ? Xu.toString : void 0;
function Zu(n) {
  if (typeof n == "string")
    return n;
  if (Ve(n))
    return ua(n, Zu) + "";
  if (cn(n))
    return Ku ? Ku.call(n) : "";
  var r = n + "";
  return r == "0" && 1 / n == -Rx ? "-0" : r;
}
var Qu = Zu;
function Vx(n) {
  var r = typeof n;
  return n != null && (r == "object" || r == "function");
}
var Lt = Vx;
function jx(n) {
  return n;
}
var Ju = jx;
var Fx = "[object AsyncFunction]";
var zx = "[object Function]";
var Ux = "[object GeneratorFunction]";
var kx = "[object Proxy]";
function Hx(n) {
  if (!Lt(n))
    return false;
  var r = Mt(n);
  return r == zx || r == Ux || r == Fx || r == kx;
}
var pa = Hx;
var Wx = Ue["__core-js_shared__"];
var fa = Wx;
var ep = function() {
  var n = /[^.]+$/.exec(fa && fa.keys && fa.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function qx(n) {
  return !!ep && ep in n;
}
var tp = qx;
var $x = Function.prototype;
var Yx = $x.toString;
function Xx(n) {
  if (n != null) {
    try {
      return Yx.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var Br = Xx;
var Kx = /[\\^$.*+?()[\]{}|]/g;
var Zx = /^\[object .+?Constructor\]$/;
var Qx = Function.prototype;
var Jx = Object.prototype;
var e0 = Qx.toString;
var t0 = Jx.hasOwnProperty;
var r0 = RegExp("^" + e0.call(t0).replace(Kx, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function o0(n) {
  if (!Lt(n) || tp(n))
    return false;
  var r = pa(n) ? r0 : Zx;
  return r.test(Br(n));
}
var rp = o0;
function n0(n, r) {
  return n == null ? void 0 : n[r];
}
var op = n0;
function i0(n, r) {
  var e = op(n, r);
  return rp(e) ? e : void 0;
}
var _t = i0;
var s0 = _t(Ue, "WeakMap");
var ma = s0;
var np = Object.create;
var a0 = function() {
  function n() {
  }
  return function(r) {
    if (!Lt(r))
      return {};
    if (np)
      return np(r);
    n.prototype = r;
    var e = new n();
    return n.prototype = void 0, e;
  };
}();
var ip = a0;
function l0(n, r, e) {
  switch (e.length) {
    case 0:
      return n.call(r);
    case 1:
      return n.call(r, e[0]);
    case 2:
      return n.call(r, e[0], e[1]);
    case 3:
      return n.call(r, e[0], e[1], e[2]);
  }
  return n.apply(r, e);
}
var sp = l0;
function c0(n, r) {
  var e = -1, t = n.length;
  for (r || (r = Array(t)); ++e < t; )
    r[e] = n[e];
  return r;
}
var ap = c0;
var d0 = 800;
var u0 = 16;
var p0 = Date.now;
function f0(n) {
  var r = 0, e = 0;
  return function() {
    var t = p0(), o = u0 - (t - e);
    if (e = t, o > 0) {
      if (++r >= d0)
        return arguments[0];
    } else
      r = 0;
    return n.apply(void 0, arguments);
  };
}
var lp = f0;
function m0(n) {
  return function() {
    return n;
  };
}
var cp = m0;
var h0 = function() {
  try {
    var n = _t(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}();
var dn = h0;
var y0 = dn ? function(n, r) {
  return dn(n, "toString", { configurable: true, enumerable: false, value: cp(r), writable: true });
} : Ju;
var dp = y0;
var g0 = lp(dp);
var up = g0;
function x0(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length; ++e < t && r(n[e], e, n) !== false; )
    ;
  return n;
}
var pp = x0;
var v0 = 9007199254740991;
var b0 = /^(?:0|[1-9]\d*)$/;
function S0(n, r) {
  var e = typeof n;
  return r = r ?? v0, !!r && (e == "number" || e != "symbol" && b0.test(n)) && n > -1 && n % 1 == 0 && n < r;
}
var un = S0;
function w0(n, r, e) {
  r == "__proto__" && dn ? dn(n, r, { configurable: true, enumerable: true, value: e, writable: true }) : n[r] = e;
}
var ha = w0;
function _0(n, r) {
  return n === r || n !== n && r !== r;
}
var pn = _0;
var T0 = Object.prototype;
var P0 = T0.hasOwnProperty;
function O0(n, r, e) {
  var t = n[r];
  (!(P0.call(n, r) && pn(t, e)) || e === void 0 && !(r in n)) && ha(n, r, e);
}
var fn = O0;
function A0(n, r, e, t) {
  var o = !e;
  e || (e = {});
  for (var i = -1, s = r.length; ++i < s; ) {
    var l = r[i], c = t ? t(e[l], n[l], l, e, n) : void 0;
    c === void 0 && (c = n[l]), o ? ha(e, l, c) : fn(e, l, c);
  }
  return e;
}
var mr = A0;
var fp = Math.max;
function I0(n, r, e) {
  return r = fp(r === void 0 ? n.length - 1 : r, 0), function() {
    for (var t = arguments, o = -1, i = fp(t.length - r, 0), s = Array(i); ++o < i; )
      s[o] = t[r + o];
    o = -1;
    for (var l = Array(r + 1); ++o < r; )
      l[o] = t[o];
    return l[r] = e(s), sp(n, this, l);
  };
}
var mp = I0;
var C0 = 9007199254740991;
function N0(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= C0;
}
var mn = N0;
function E0(n) {
  return n != null && mn(n.length) && !pa(n);
}
var ya = E0;
var M0 = Object.prototype;
function L0(n) {
  var r = n && n.constructor, e = typeof r == "function" && r.prototype || M0;
  return n === e;
}
var hn = L0;
function B0(n, r) {
  for (var e = -1, t = Array(n); ++e < n; )
    t[e] = r(e);
  return t;
}
var hp = B0;
var D0 = "[object Arguments]";
function G0(n) {
  return ot(n) && Mt(n) == D0;
}
var pc = G0;
var yp = Object.prototype;
var R0 = yp.hasOwnProperty;
var V0 = yp.propertyIsEnumerable;
var j0 = pc(function() {
  return arguments;
}()) ? pc : function(n) {
  return ot(n) && R0.call(n, "callee") && !V0.call(n, "callee");
};
var yn = j0;
function F0() {
  return false;
}
var gp = F0;
var bp = typeof exports == "object" && exports && !exports.nodeType && exports;
var xp = bp && typeof module == "object" && module && !module.nodeType && module;
var z0 = xp && xp.exports === bp;
var vp = z0 ? Ue.Buffer : void 0;
var U0 = vp ? vp.isBuffer : void 0;
var k0 = U0 || gp;
var _o = k0;
var H0 = "[object Arguments]";
var W0 = "[object Array]";
var q0 = "[object Boolean]";
var $0 = "[object Date]";
var Y0 = "[object Error]";
var X0 = "[object Function]";
var K0 = "[object Map]";
var Z0 = "[object Number]";
var Q0 = "[object Object]";
var J0 = "[object RegExp]";
var ev = "[object Set]";
var tv = "[object String]";
var rv = "[object WeakMap]";
var ov = "[object ArrayBuffer]";
var nv = "[object DataView]";
var iv = "[object Float32Array]";
var sv = "[object Float64Array]";
var av = "[object Int8Array]";
var lv = "[object Int16Array]";
var cv = "[object Int32Array]";
var dv = "[object Uint8Array]";
var uv = "[object Uint8ClampedArray]";
var pv = "[object Uint16Array]";
var fv = "[object Uint32Array]";
var Me = {};
Me[iv] = Me[sv] = Me[av] = Me[lv] = Me[cv] = Me[dv] = Me[uv] = Me[pv] = Me[fv] = true;
Me[H0] = Me[W0] = Me[ov] = Me[q0] = Me[nv] = Me[$0] = Me[Y0] = Me[X0] = Me[K0] = Me[Z0] = Me[Q0] = Me[J0] = Me[ev] = Me[tv] = Me[rv] = false;
function mv(n) {
  return ot(n) && mn(n.length) && !!Me[Mt(n)];
}
var Sp = mv;
function hv(n) {
  return function(r) {
    return n(r);
  };
}
var gn = hv;
var wp = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ci = wp && typeof module == "object" && module && !module.nodeType && module;
var yv = Ci && Ci.exports === wp;
var fc = yv && da.process;
var gv = function() {
  try {
    var n = Ci && Ci.require && Ci.require("util").types;
    return n || fc && fc.binding && fc.binding("util");
  } catch {
  }
}();
var Dr = gv;
var _p = Dr && Dr.isTypedArray;
var xv = _p ? gn(_p) : Sp;
var ga = xv;
var vv = Object.prototype;
var bv = vv.hasOwnProperty;
function Sv(n, r) {
  var e = Ve(n), t = !e && yn(n), o = !e && !t && _o(n), i = !e && !t && !o && ga(n), s = e || t || o || i, l = s ? hp(n.length, String) : [], c = l.length;
  for (var u in n)
    (r || bv.call(n, u)) && !(s && (u == "length" || o && (u == "offset" || u == "parent") || i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || un(u, c))) && l.push(u);
  return l;
}
var xa = Sv;
function wv(n, r) {
  return function(e) {
    return n(r(e));
  };
}
var va = wv;
var _v = va(Object.keys, Object);
var Tp = _v;
var Tv = Object.prototype;
var Pv = Tv.hasOwnProperty;
function Ov(n) {
  if (!hn(n))
    return Tp(n);
  var r = [];
  for (var e in Object(n))
    Pv.call(n, e) && e != "constructor" && r.push(e);
  return r;
}
var Pp = Ov;
function Av(n) {
  return ya(n) ? xa(n) : Pp(n);
}
var xn = Av;
function Iv(n) {
  var r = [];
  if (n != null)
    for (var e in Object(n))
      r.push(e);
  return r;
}
var Op = Iv;
var Cv = Object.prototype;
var Nv = Cv.hasOwnProperty;
function Ev(n) {
  if (!Lt(n))
    return Op(n);
  var r = hn(n), e = [];
  for (var t in n)
    t == "constructor" && (r || !Nv.call(n, t)) || e.push(t);
  return e;
}
var Ap = Ev;
function Mv(n) {
  return ya(n) ? xa(n, true) : Ap(n);
}
var vn = Mv;
var Lv = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var Bv = /^\w*$/;
function Dv(n, r) {
  if (Ve(n))
    return false;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || cn(n) ? true : Bv.test(n) || !Lv.test(n) || r != null && n in Object(r);
}
var Ip = Dv;
var Gv = _t(Object, "create");
var Gr = Gv;
function Rv() {
  this.__data__ = Gr ? Gr(null) : {}, this.size = 0;
}
var Cp = Rv;
function Vv(n) {
  var r = this.has(n) && delete this.__data__[n];
  return this.size -= r ? 1 : 0, r;
}
var Np = Vv;
var jv = "__lodash_hash_undefined__";
var Fv = Object.prototype;
var zv = Fv.hasOwnProperty;
function Uv(n) {
  var r = this.__data__;
  if (Gr) {
    var e = r[n];
    return e === jv ? void 0 : e;
  }
  return zv.call(r, n) ? r[n] : void 0;
}
var Ep = Uv;
var kv = Object.prototype;
var Hv = kv.hasOwnProperty;
function Wv(n) {
  var r = this.__data__;
  return Gr ? r[n] !== void 0 : Hv.call(r, n);
}
var Mp = Wv;
var qv = "__lodash_hash_undefined__";
function $v(n, r) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = Gr && r === void 0 ? qv : r, this;
}
var Lp = $v;
function bn(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
bn.prototype.clear = Cp;
bn.prototype.delete = Np;
bn.prototype.get = Ep;
bn.prototype.has = Mp;
bn.prototype.set = Lp;
var mc = bn;
function Yv() {
  this.__data__ = [], this.size = 0;
}
var Bp = Yv;
function Xv(n, r) {
  for (var e = n.length; e--; )
    if (pn(n[e][0], r))
      return e;
  return -1;
}
var eo = Xv;
var Kv = Array.prototype;
var Zv = Kv.splice;
function Qv(n) {
  var r = this.__data__, e = eo(r, n);
  if (e < 0)
    return false;
  var t = r.length - 1;
  return e == t ? r.pop() : Zv.call(r, e, 1), --this.size, true;
}
var Dp = Qv;
function Jv(n) {
  var r = this.__data__, e = eo(r, n);
  return e < 0 ? void 0 : r[e][1];
}
var Gp = Jv;
function eb(n) {
  return eo(this.__data__, n) > -1;
}
var Rp = eb;
function tb(n, r) {
  var e = this.__data__, t = eo(e, n);
  return t < 0 ? (++this.size, e.push([n, r])) : e[t][1] = r, this;
}
var Vp = tb;
function Sn(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
Sn.prototype.clear = Bp;
Sn.prototype.delete = Dp;
Sn.prototype.get = Gp;
Sn.prototype.has = Rp;
Sn.prototype.set = Vp;
var to = Sn;
var rb = _t(Ue, "Map");
var ro = rb;
function ob() {
  this.size = 0, this.__data__ = { hash: new mc(), map: new (ro || to)(), string: new mc() };
}
var jp = ob;
function nb(n) {
  var r = typeof n;
  return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? n !== "__proto__" : n === null;
}
var Fp = nb;
function ib(n, r) {
  var e = n.__data__;
  return Fp(r) ? e[typeof r == "string" ? "string" : "hash"] : e.map;
}
var oo = ib;
function sb(n) {
  var r = oo(this, n).delete(n);
  return this.size -= r ? 1 : 0, r;
}
var zp = sb;
function ab(n) {
  return oo(this, n).get(n);
}
var Up = ab;
function lb(n) {
  return oo(this, n).has(n);
}
var kp = lb;
function cb(n, r) {
  var e = oo(this, n), t = e.size;
  return e.set(n, r), this.size += e.size == t ? 0 : 1, this;
}
var Hp = cb;
function wn(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++r < e; ) {
    var t = n[r];
    this.set(t[0], t[1]);
  }
}
wn.prototype.clear = jp;
wn.prototype.delete = zp;
wn.prototype.get = Up;
wn.prototype.has = kp;
wn.prototype.set = Hp;
var To = wn;
var db = "Expected a function";
function hc(n, r) {
  if (typeof n != "function" || r != null && typeof r != "function")
    throw new TypeError(db);
  var e = function() {
    var t = arguments, o = r ? r.apply(this, t) : t[0], i = e.cache;
    if (i.has(o))
      return i.get(o);
    var s = n.apply(this, t);
    return e.cache = i.set(o, s) || i, s;
  };
  return e.cache = new (hc.Cache || To)(), e;
}
hc.Cache = To;
var Wp = hc;
var ub = 500;
function pb(n) {
  var r = Wp(n, function(t) {
    return e.size === ub && e.clear(), t;
  }), e = r.cache;
  return r;
}
var qp = pb;
var fb = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var mb = /\\(\\)?/g;
var hb = qp(function(n) {
  var r = [];
  return n.charCodeAt(0) === 46 && r.push(""), n.replace(fb, function(e, t, o, i) {
    r.push(o ? i.replace(mb, "$1") : t || e);
  }), r;
});
var $p = hb;
function yb(n) {
  return n == null ? "" : Qu(n);
}
var Yp = yb;
function gb(n, r) {
  return Ve(n) ? n : Ip(n, r) ? [n] : $p(Yp(n));
}
var Vt = gb;
var xb = 1 / 0;
function vb(n) {
  if (typeof n == "string" || cn(n))
    return n;
  var r = n + "";
  return r == "0" && 1 / n == -xb ? "-0" : r;
}
var no = vb;
function bb(n, r) {
  r = Vt(r, n);
  for (var e = 0, t = r.length; n != null && e < t; )
    n = n[no(r[e++])];
  return e && e == t ? n : void 0;
}
var ba = bb;
function Sb(n, r) {
  for (var e = -1, t = r.length, o = n.length; ++e < t; )
    n[o + e] = r[e];
  return n;
}
var _n = Sb;
var Xp = Ke ? Ke.isConcatSpreadable : void 0;
function wb(n) {
  return Ve(n) || yn(n) || !!(Xp && n && n[Xp]);
}
var Kp = wb;
function Zp(n, r, e, t, o) {
  var i = -1, s = n.length;
  for (e || (e = Kp), o || (o = []); ++i < s; ) {
    var l = n[i];
    r > 0 && e(l) ? r > 1 ? Zp(l, r - 1, e, t, o) : _n(o, l) : t || (o[o.length] = l);
  }
  return o;
}
var Qp = Zp;
function _b(n) {
  var r = n == null ? 0 : n.length;
  return r ? Qp(n, 1) : [];
}
var Jp = _b;
function Tb(n) {
  return up(mp(n, void 0, Jp), n + "");
}
var Sa = Tb;
var Pb = va(Object.getPrototypeOf, Object);
var Tn = Pb;
var Ob = "[object Object]";
var Ab = Function.prototype;
var Ib = Object.prototype;
var ef = Ab.toString;
var Cb = Ib.hasOwnProperty;
var Nb = ef.call(Object);
function Eb(n) {
  if (!ot(n) || Mt(n) != Ob)
    return false;
  var r = Tn(n);
  if (r === null)
    return true;
  var e = Cb.call(r, "constructor") && r.constructor;
  return typeof e == "function" && e instanceof e && ef.call(e) == Nb;
}
var tf = Eb;
function Mb(n, r, e) {
  var t = -1, o = n.length;
  r < 0 && (r = -r > o ? 0 : o + r), e = e > o ? o : e, e < 0 && (e += o), o = r > e ? 0 : e - r >>> 0, r >>>= 0;
  for (var i = Array(o); ++t < o; )
    i[t] = n[t + r];
  return i;
}
var rf = Mb;
function Lb() {
  this.__data__ = new to(), this.size = 0;
}
var of = Lb;
function Bb(n) {
  var r = this.__data__, e = r.delete(n);
  return this.size = r.size, e;
}
var nf = Bb;
function Db(n) {
  return this.__data__.get(n);
}
var sf = Db;
function Gb(n) {
  return this.__data__.has(n);
}
var af = Gb;
var Rb = 200;
function Vb(n, r) {
  var e = this.__data__;
  if (e instanceof to) {
    var t = e.__data__;
    if (!ro || t.length < Rb - 1)
      return t.push([n, r]), this.size = ++e.size, this;
    e = this.__data__ = new To(t);
  }
  return e.set(n, r), this.size = e.size, this;
}
var lf = Vb;
function Pn(n) {
  var r = this.__data__ = new to(n);
  this.size = r.size;
}
Pn.prototype.clear = of;
Pn.prototype.delete = nf;
Pn.prototype.get = sf;
Pn.prototype.has = af;
Pn.prototype.set = lf;
var On = Pn;
function jb(n, r) {
  return n && mr(r, xn(r), n);
}
var cf = jb;
function Fb(n, r) {
  return n && mr(r, vn(r), n);
}
var df = Fb;
var mf = typeof exports == "object" && exports && !exports.nodeType && exports;
var uf = mf && typeof module == "object" && module && !module.nodeType && module;
var zb = uf && uf.exports === mf;
var pf = zb ? Ue.Buffer : void 0;
var ff = pf ? pf.allocUnsafe : void 0;
function Ub(n, r) {
  if (r)
    return n.slice();
  var e = n.length, t = ff ? ff(e) : new n.constructor(e);
  return n.copy(t), t;
}
var hf = Ub;
function kb(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length, o = 0, i = []; ++e < t; ) {
    var s = n[e];
    r(s, e, n) && (i[o++] = s);
  }
  return i;
}
var yf = kb;
function Hb() {
  return [];
}
var wa = Hb;
var Wb = Object.prototype;
var qb = Wb.propertyIsEnumerable;
var gf = Object.getOwnPropertySymbols;
var $b = gf ? function(n) {
  return n == null ? [] : (n = Object(n), yf(gf(n), function(r) {
    return qb.call(n, r);
  }));
} : wa;
var An = $b;
function Yb(n, r) {
  return mr(n, An(n), r);
}
var xf = Yb;
var Xb = Object.getOwnPropertySymbols;
var Kb = Xb ? function(n) {
  for (var r = []; n; )
    _n(r, An(n)), n = Tn(n);
  return r;
} : wa;
var _a = Kb;
function Zb(n, r) {
  return mr(n, _a(n), r);
}
var vf = Zb;
function Qb(n, r, e) {
  var t = r(n);
  return Ve(n) ? t : _n(t, e(n));
}
var Ta = Qb;
function Jb(n) {
  return Ta(n, xn, An);
}
var Ni = Jb;
function eS(n) {
  return Ta(n, vn, _a);
}
var Pa = eS;
var tS = _t(Ue, "DataView");
var Oa = tS;
var rS = _t(Ue, "Promise");
var Aa = rS;
var oS = _t(Ue, "Set");
var Ia = oS;
var bf = "[object Map]";
var nS = "[object Object]";
var Sf = "[object Promise]";
var wf = "[object Set]";
var _f = "[object WeakMap]";
var Tf = "[object DataView]";
var iS = Br(Oa);
var sS = Br(ro);
var aS = Br(Aa);
var lS = Br(Ia);
var cS = Br(ma);
var Po = Mt;
(Oa && Po(new Oa(new ArrayBuffer(1))) != Tf || ro && Po(new ro()) != bf || Aa && Po(Aa.resolve()) != Sf || Ia && Po(new Ia()) != wf || ma && Po(new ma()) != _f) && (Po = function(n) {
  var r = Mt(n), e = r == nS ? n.constructor : void 0, t = e ? Br(e) : "";
  if (t)
    switch (t) {
      case iS:
        return Tf;
      case sS:
        return bf;
      case aS:
        return Sf;
      case lS:
        return wf;
      case cS:
        return _f;
    }
  return r;
});
var Rr = Po;
var dS = Object.prototype;
var uS = dS.hasOwnProperty;
function pS(n) {
  var r = n.length, e = new n.constructor(r);
  return r && typeof n[0] == "string" && uS.call(n, "index") && (e.index = n.index, e.input = n.input), e;
}
var Pf = pS;
var fS = Ue.Uint8Array;
var In = fS;
function mS(n) {
  var r = new n.constructor(n.byteLength);
  return new In(r).set(new In(n)), r;
}
var Cn = mS;
function hS(n, r) {
  var e = r ? Cn(n.buffer) : n.buffer;
  return new n.constructor(e, n.byteOffset, n.byteLength);
}
var Of = hS;
var yS = /\w*$/;
function gS(n) {
  var r = new n.constructor(n.source, yS.exec(n));
  return r.lastIndex = n.lastIndex, r;
}
var Af = gS;
var If = Ke ? Ke.prototype : void 0;
var Cf = If ? If.valueOf : void 0;
function xS(n) {
  return Cf ? Object(Cf.call(n)) : {};
}
var Nf = xS;
function vS(n, r) {
  var e = r ? Cn(n.buffer) : n.buffer;
  return new n.constructor(e, n.byteOffset, n.length);
}
var Ef = vS;
var bS = "[object Boolean]";
var SS = "[object Date]";
var wS = "[object Map]";
var _S = "[object Number]";
var TS = "[object RegExp]";
var PS = "[object Set]";
var OS = "[object String]";
var AS = "[object Symbol]";
var IS = "[object ArrayBuffer]";
var CS = "[object DataView]";
var NS = "[object Float32Array]";
var ES = "[object Float64Array]";
var MS = "[object Int8Array]";
var LS = "[object Int16Array]";
var BS = "[object Int32Array]";
var DS = "[object Uint8Array]";
var GS = "[object Uint8ClampedArray]";
var RS = "[object Uint16Array]";
var VS = "[object Uint32Array]";
function jS(n, r, e) {
  var t = n.constructor;
  switch (r) {
    case IS:
      return Cn(n);
    case bS:
    case SS:
      return new t(+n);
    case CS:
      return Of(n, e);
    case NS:
    case ES:
    case MS:
    case LS:
    case BS:
    case DS:
    case GS:
    case RS:
    case VS:
      return Ef(n, e);
    case wS:
      return new t();
    case _S:
    case OS:
      return new t(n);
    case TS:
      return Af(n);
    case PS:
      return new t();
    case AS:
      return Nf(n);
  }
}
var Mf = jS;
function FS(n) {
  return typeof n.constructor == "function" && !hn(n) ? ip(Tn(n)) : {};
}
var Lf = FS;
var zS = "[object Map]";
function US(n) {
  return ot(n) && Rr(n) == zS;
}
var Bf = US;
var Df = Dr && Dr.isMap;
var kS = Df ? gn(Df) : Bf;
var Gf = kS;
var HS = "[object Set]";
function WS(n) {
  return ot(n) && Rr(n) == HS;
}
var Rf = WS;
var Vf = Dr && Dr.isSet;
var qS = Vf ? gn(Vf) : Rf;
var jf = qS;
var $S = 1;
var YS = 2;
var XS = 4;
var Ff = "[object Arguments]";
var KS = "[object Array]";
var ZS = "[object Boolean]";
var QS = "[object Date]";
var JS = "[object Error]";
var zf = "[object Function]";
var e1 = "[object GeneratorFunction]";
var t1 = "[object Map]";
var r1 = "[object Number]";
var Uf = "[object Object]";
var o1 = "[object RegExp]";
var n1 = "[object Set]";
var i1 = "[object String]";
var s1 = "[object Symbol]";
var a1 = "[object WeakMap]";
var l1 = "[object ArrayBuffer]";
var c1 = "[object DataView]";
var d1 = "[object Float32Array]";
var u1 = "[object Float64Array]";
var p1 = "[object Int8Array]";
var f1 = "[object Int16Array]";
var m1 = "[object Int32Array]";
var h1 = "[object Uint8Array]";
var y1 = "[object Uint8ClampedArray]";
var g1 = "[object Uint16Array]";
var x1 = "[object Uint32Array]";
var Ee = {};
Ee[Ff] = Ee[KS] = Ee[l1] = Ee[c1] = Ee[ZS] = Ee[QS] = Ee[d1] = Ee[u1] = Ee[p1] = Ee[f1] = Ee[m1] = Ee[t1] = Ee[r1] = Ee[Uf] = Ee[o1] = Ee[n1] = Ee[i1] = Ee[s1] = Ee[h1] = Ee[y1] = Ee[g1] = Ee[x1] = true;
Ee[JS] = Ee[zf] = Ee[a1] = false;
function Ca(n, r, e, t, o, i) {
  var s, l = r & $S, c = r & YS, u = r & XS;
  if (e && (s = o ? e(n, t, o, i) : e(n)), s !== void 0)
    return s;
  if (!Lt(n))
    return n;
  var a = Ve(n);
  if (a) {
    if (s = Pf(n), !l)
      return ap(n, s);
  } else {
    var d = Rr(n), p = d == zf || d == e1;
    if (_o(n))
      return hf(n, l);
    if (d == Uf || d == Ff || p && !o) {
      if (s = c || p ? {} : Lf(n), !l)
        return c ? vf(n, df(s, n)) : xf(n, cf(s, n));
    } else {
      if (!Ee[d])
        return o ? n : {};
      s = Mf(n, d, l);
    }
  }
  i || (i = new On());
  var f = i.get(n);
  if (f)
    return f;
  i.set(n, s), jf(n) ? n.forEach(function(y) {
    s.add(Ca(y, r, e, y, n, i));
  }) : Gf(n) && n.forEach(function(y, g) {
    s.set(g, Ca(y, r, e, g, n, i));
  });
  var m = u ? c ? Pa : Ni : c ? vn : xn, h = a ? void 0 : m(n);
  return pp(h || n, function(y, g) {
    h && (g = y, y = n[g]), fn(s, g, Ca(y, r, e, g, n, i));
  }), s;
}
var Na = Ca;
var v1 = 1;
var b1 = 4;
function S1(n) {
  return Na(n, v1 | b1);
}
var Vr = S1;
var w1 = "__lodash_hash_undefined__";
function _1(n) {
  return this.__data__.set(n, w1), this;
}
var kf = _1;
function T1(n) {
  return this.__data__.has(n);
}
var Hf = T1;
function Ea(n) {
  var r = -1, e = n == null ? 0 : n.length;
  for (this.__data__ = new To(); ++r < e; )
    this.add(n[r]);
}
Ea.prototype.add = Ea.prototype.push = kf;
Ea.prototype.has = Hf;
var Wf = Ea;
function P1(n, r) {
  for (var e = -1, t = n == null ? 0 : n.length; ++e < t; )
    if (r(n[e], e, n))
      return true;
  return false;
}
var qf = P1;
function O1(n, r) {
  return n.has(r);
}
var $f = O1;
var A1 = 1;
var I1 = 2;
function C1(n, r, e, t, o, i) {
  var s = e & A1, l = n.length, c = r.length;
  if (l != c && !(s && c > l))
    return false;
  var u = i.get(n), a = i.get(r);
  if (u && a)
    return u == r && a == n;
  var d = -1, p = true, f = e & I1 ? new Wf() : void 0;
  for (i.set(n, r), i.set(r, n); ++d < l; ) {
    var m = n[d], h = r[d];
    if (t)
      var y = s ? t(h, m, d, r, n, i) : t(m, h, d, n, r, i);
    if (y !== void 0) {
      if (y)
        continue;
      p = false;
      break;
    }
    if (f) {
      if (!qf(r, function(g, v) {
        if (!$f(f, v) && (m === g || o(m, g, e, t, i)))
          return f.push(v);
      })) {
        p = false;
        break;
      }
    } else if (!(m === h || o(m, h, e, t, i))) {
      p = false;
      break;
    }
  }
  return i.delete(n), i.delete(r), p;
}
var Ma = C1;
function N1(n) {
  var r = -1, e = Array(n.size);
  return n.forEach(function(t, o) {
    e[++r] = [o, t];
  }), e;
}
var Yf = N1;
function E1(n) {
  var r = -1, e = Array(n.size);
  return n.forEach(function(t) {
    e[++r] = t;
  }), e;
}
var Xf = E1;
var M1 = 1;
var L1 = 2;
var B1 = "[object Boolean]";
var D1 = "[object Date]";
var G1 = "[object Error]";
var R1 = "[object Map]";
var V1 = "[object Number]";
var j1 = "[object RegExp]";
var F1 = "[object Set]";
var z1 = "[object String]";
var U1 = "[object Symbol]";
var k1 = "[object ArrayBuffer]";
var H1 = "[object DataView]";
var Kf = Ke ? Ke.prototype : void 0;
var yc = Kf ? Kf.valueOf : void 0;
function W1(n, r, e, t, o, i, s) {
  switch (e) {
    case H1:
      if (n.byteLength != r.byteLength || n.byteOffset != r.byteOffset)
        return false;
      n = n.buffer, r = r.buffer;
    case k1:
      return !(n.byteLength != r.byteLength || !i(new In(n), new In(r)));
    case B1:
    case D1:
    case V1:
      return pn(+n, +r);
    case G1:
      return n.name == r.name && n.message == r.message;
    case j1:
    case z1:
      return n == r + "";
    case R1:
      var l = Yf;
    case F1:
      var c = t & M1;
      if (l || (l = Xf), n.size != r.size && !c)
        return false;
      var u = s.get(n);
      if (u)
        return u == r;
      t |= L1, s.set(n, r);
      var a = Ma(l(n), l(r), t, o, i, s);
      return s.delete(n), a;
    case U1:
      if (yc)
        return yc.call(n) == yc.call(r);
  }
  return false;
}
var Zf = W1;
var q1 = 1;
var $1 = Object.prototype;
var Y1 = $1.hasOwnProperty;
function X1(n, r, e, t, o, i) {
  var s = e & q1, l = Ni(n), c = l.length, u = Ni(r), a = u.length;
  if (c != a && !s)
    return false;
  for (var d = c; d--; ) {
    var p = l[d];
    if (!(s ? p in r : Y1.call(r, p)))
      return false;
  }
  var f = i.get(n), m = i.get(r);
  if (f && m)
    return f == r && m == n;
  var h = true;
  i.set(n, r), i.set(r, n);
  for (var y = s; ++d < c; ) {
    p = l[d];
    var g = n[p], v = r[p];
    if (t)
      var S = s ? t(v, g, p, r, n, i) : t(g, v, p, n, r, i);
    if (!(S === void 0 ? g === v || o(g, v, e, t, i) : S)) {
      h = false;
      break;
    }
    y || (y = p == "constructor");
  }
  if (h && !y) {
    var w = n.constructor, b = r.constructor;
    w != b && "constructor" in n && "constructor" in r && !(typeof w == "function" && w instanceof w && typeof b == "function" && b instanceof b) && (h = false);
  }
  return i.delete(n), i.delete(r), h;
}
var Qf = X1;
var K1 = 1;
var Jf = "[object Arguments]";
var em = "[object Array]";
var La = "[object Object]";
var Z1 = Object.prototype;
var tm = Z1.hasOwnProperty;
function Q1(n, r, e, t, o, i) {
  var s = Ve(n), l = Ve(r), c = s ? em : Rr(n), u = l ? em : Rr(r);
  c = c == Jf ? La : c, u = u == Jf ? La : u;
  var a = c == La, d = u == La, p = c == u;
  if (p && _o(n)) {
    if (!_o(r))
      return false;
    s = true, a = false;
  }
  if (p && !a)
    return i || (i = new On()), s || ga(n) ? Ma(n, r, e, t, o, i) : Zf(n, r, c, e, t, o, i);
  if (!(e & K1)) {
    var f = a && tm.call(n, "__wrapped__"), m = d && tm.call(r, "__wrapped__");
    if (f || m) {
      var h = f ? n.value() : n, y = m ? r.value() : r;
      return i || (i = new On()), o(h, y, e, t, i);
    }
  }
  return p ? (i || (i = new On()), Qf(n, r, e, t, o, i)) : false;
}
var rm = Q1;
function om(n, r, e, t, o) {
  return n === r ? true : n == null || r == null || !ot(n) && !ot(r) ? n !== n && r !== r : rm(n, r, e, t, om, o);
}
var nm = om;
function J1(n, r) {
  return n != null && r in Object(n);
}
var im = J1;
function ew(n, r, e) {
  r = Vt(r, n);
  for (var t = -1, o = r.length, i = false; ++t < o; ) {
    var s = no(r[t]);
    if (!(i = n != null && e(n, s)))
      break;
    n = n[s];
  }
  return i || ++t != o ? i : (o = n == null ? 0 : n.length, !!o && mn(o) && un(s, o) && (Ve(n) || yn(n)));
}
var sm = ew;
function tw(n, r) {
  return n != null && sm(n, r, im);
}
var am = tw;
function rw(n) {
  var r = n == null ? 0 : n.length;
  return r ? n[r - 1] : void 0;
}
var lm = rw;
function ow(n, r) {
  return r.length < 2 ? n : ba(n, rf(r, 0, -1));
}
var cm = ow;
function nw(n, r) {
  return nm(n, r);
}
var Ei = nw;
function iw(n, r) {
  return r = Vt(r, n), n = cm(n, r), n == null || delete n[no(lm(r))];
}
var dm = iw;
function sw(n) {
  return tf(n) ? void 0 : n;
}
var um = sw;
var aw = 1;
var lw = 2;
var cw = 4;
var dw = Sa(function(n, r) {
  var e = {};
  if (n == null)
    return e;
  var t = false;
  r = ua(r, function(i) {
    return i = Vt(i, n), t || (t = i.length > 1), i;
  }), mr(n, Pa(n), e), t && (e = Na(e, aw | lw | cw, um));
  for (var o = r.length; o--; )
    dm(e, r[o]);
  return e;
});
var Nn = dw;
function uw(n, r, e, t) {
  if (!Lt(n))
    return n;
  r = Vt(r, n);
  for (var o = -1, i = r.length, s = i - 1, l = n; l != null && ++o < i; ) {
    var c = no(r[o]), u = e;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return n;
    if (o != s) {
      var a = l[c];
      u = t ? t(a, c, l) : void 0, u === void 0 && (u = Lt(a) ? a : un(r[o + 1]) ? [] : {});
    }
    fn(l, c, u), l = l[c];
  }
  return n;
}
var pm = uw;
function pw(n, r, e) {
  for (var t = -1, o = r.length, i = {}; ++t < o; ) {
    var s = r[t], l = ba(n, s);
    e(l, s) && pm(i, Vt(s, n), l);
  }
  return i;
}
var fm = pw;
function fw(n, r) {
  return fm(n, r, function(e, t) {
    return am(n, t);
  });
}
var mm = fw;
var mw = Sa(function(n, r) {
  return n == null ? {} : mm(n, r);
});
var En = mw;
function hm(n) {
  n.layers.forEach((r) => {
    if (r.type === "depth" && r.colorA !== void 0) {
      let e = r.colorA, t = r.colorB, o = [[e.r, e.g, e.b, e.a], [t.r, t.g, t.b, t.a]], i = [0, 1];
      for (let l = 2; l < 10; l++)
        o.push(o[1]), i.push(1);
      let s = { ...En(Ye(r), "type", "visible", "isVector", "isWorldSpace", "origin", "alpha", "mode"), near: Math.max(0, r.near), far: Math.max(0, r.far), colors: o, steps: i, num: 2, direction: [1, 0, 0], smooth: false, gradientType: 1 };
      Object.assign(r, s);
    } else if (r.type === "depth" && r.gradientType === 1 && (r.near < 0 || r.far < 0)) {
      let e = { ...Ye(r), near: Math.max(r.near, 0), far: Math.max(r.far, 0) };
      Object.assign(r, e);
    }
  });
}
function Da(n, r) {
  Object.values(n.shared.materials).forEach((e) => r(e));
}
function Ga(n, r) {
  n.scene.objects.traverse((e, t) => {
    "materials" in t ? t.materials.forEach((o) => {
      typeof o != "string" && r(o);
    }) : "material" in t && typeof t.material != "string" && r(t.material);
  });
}
function hw(n) {
  Object.assign(n.scene.publish, { orbitControls: { ...an.defaultData, ...Ye(n.scene.publish.orbitControls) } });
}
function yw(n) {
  Object.assign(n.scene.publish.settings, { video: { ...aa.defaultData.settings.video, ...Ye(n.scene.publish.settings.video) } });
}
function gw(n) {
  function r(e) {
    if (e.layers) {
      for (let t of Object.values(e.layers))
        if (t) {
          for (let [o, i] of Object.entries(t))
            if ((Ru.includes(o) || typeof i == "boolean") && delete t[o], o === "texture")
              for (let [s, l] of Object.entries(i))
                (Vu.includes(s) || typeof l == "boolean") && delete i[s];
        }
    }
  }
  n.scene.objects.traverse((e, t) => {
    t.states.forEach((o) => {
      let i = o;
      i.material ? r(i.material) : i.materials && i.materials.forEach((s) => {
        r(s);
      });
    });
  });
}
function xw(n) {
  n.scene.publish.withBackground = true;
}
function vw(n) {
  n.scene.publish.settings.web = { compress: true, preload: true, preset: 1, logo: true, hint: false };
}
function bw(n) {
  n.scene.objects.traverse((r, e) => {
    let t = e.cloner;
    t && (t.radial.scale = t.radial.scale.map((o) => o + 1), t.linear.scale = t.linear.scale.map((o) => o + 1));
  });
}
function Sw(n) {
  n.scene.objects.traverse((r, e) => {
    let t = e.geometry;
    t && (t.type === "DodecahedronGeometry" || t.type === "IcosahedronGeometry") && (t.detail = Math.round(t.detail));
  });
}
function ww(n) {
  n.scene.objects.traverse((r, e) => {
    let t = n.scene.objects.unproxy().parent(r);
    if (t) {
      let o = Ye(n.scene.objects.data(t));
      o && o.type === "Mesh" && o.geometry.type === "BooleanGeometry" && e.type === "Mesh" && (e.visible = Ye(e).booleanExclude !== true);
    }
  });
}
function _w(n) {
  n.scene.objects.traverse((r, e) => {
    if (e.type === "Mesh") {
      let t = e;
      e.geometry.type === "NonParametricGeometry" ? t.material !== void 0 && delete t.material : t.materials !== void 0 && delete t.materials;
    }
  });
}
function Tw(n) {
  function r(t) {
    Object.setPrototypeOf(t, Be.prototype), t.texture && Object.setPrototypeOf(t.texture, Be.prototype);
  }
  function e(t) {
    Object.setPrototypeOf(t, Be.prototype);
    for (let o in t)
      r(t[o]);
  }
  n.scene.objects.traverse((t, o) => {
    o.states.forEach((i) => {
      let s = i;
      if (s.material) {
        let l = Ye(s.material).layers;
        e(l), s.material.layers = l;
      }
      if (s.materials)
        for (let l = 0; l < s.materials.length; l++) {
          let c = s.materials[l], u = Ye(c).layers;
          e(u), c.layers = u;
        }
    });
  });
}
function ym(n) {
  n.layers === void 0 && Object.assign(n, wt.defaultTwoLayerData("lambert"));
}
function gc(n) {
  !n.layers || n.layers.forEach((r) => {
    if (r.type === "depth" && r.colors.length === 10) {
      let e = [...r.colors];
      e.push(r.colors[9]);
      let t = [...r.steps];
      t.push(r.steps[9]);
      let o = { ...Ye(r), colors: e, steps: t };
      Object.assign(r, o);
    }
  });
}
function Pw(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && (e.geometry.type === "BooleanGeometry" || e.geometry.type === "SubdivGeometry") && (e.geometry.phongAngle = 35);
  });
}
function gm(n) {
  n.scene.objects.traverse((r, e) => {
    "materials" in e ? e.materials.forEach((t) => {
      typeof t != "string" && gc(t);
    }) : "material" in e && typeof e.material != "string" && gc(e.material);
  }), Object.values(n.shared.materials).forEach((r) => gc(r));
}
function Ow(n) {
  n.scene.environment.ambientLight.softShadows = false, n.scene.environment.ambientLight.softShadowQuality = "low", n.scene.objects.traverse((r, e) => {
    (e.type === "DirectionalLight" || e.type === "SpotLight") && (e.shadowResolution = 1024, e.shadowRadius = 1, e.depth = 1e5);
  }), n.shared.penumbraSize = new Array(5).fill(0.5);
}
function Aw(n) {
  n.shared.audios = Lr({}, Ie.prototype);
}
function Iw(n) {
  n.shared.videos = Lr({}, Ie.prototype);
}
function Cw(n) {
  let r = n.shared.materials;
  Object.entries(r).forEach(([e, t]) => {
    if (!t.layers) {
      let o = { name: "Untitled Material", layers: [{ fi: 0, data: { type: "light", category: "phong", alpha: 0.6, visible: true, mode: 0, specular: { r: 0.2, g: 0.2, b: 0.2 }, shininess: 5 }, id: "layer1" }, { fi: 1, data: { type: "color", alpha: 1, visible: true, mode: 0, color: { r: 0.2823529411764706, g: 0.2823529411764706, b: 0.30196078431372547 } }, id: "layer2" }] };
      Object.assign(r, { [e]: o });
    }
  });
}
function Nw(n) {
  Object.entries(Ye(n.shared.images)).filter((t) => t[1].asset === false).map((t) => t[0]).forEach((t) => {
    delete n.shared.images[t];
  }), Object.entries(Ye(n.shared.audios)).filter((t) => t[1].asset === false).map((t) => t[0]).forEach((t) => {
    delete n.shared.audios[t];
  });
}
function Ew(n) {
  n.scene.publish.settings.web.preload = false;
}
function xm(n) {
  n.layers && n.layers.forEach((r) => {
    r.type === "depth" && r.num !== void 0 && (r.colors = r.colors.slice(0, r.num), r.steps = r.steps.slice(0, r.num), delete r.num);
  });
}
function Mw(n) {
  n.shared.fonts = Lr({}, Ie.prototype);
}
function Lw(n) {
  return n.replace(".typeface", "").replace(/optimer/gi, "open sans").replace("space_mono", "space mono").replace(/alma_mono/gi, "varela round").replace(/droid_sans_mono/gi, "noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi, "roboto").replace(/droid_serif/gi, "roboto slab").replace("_sans", " sans").replace("crimson_text", "crimson text").replace("medium_medium", "medium").replace("fatface_fatface", "fatface").replace("100hairline", "thin").replace("200thin", "extralight").replace("300light", "light").replace("500medium", "medium").replace("600semi", "semibold").replace("800heavy", "extrabold").replace("900black", "black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda").replace(/(thin|hairline)(_regular)?/gi, "100").replace(/(extra|ultra)light(_regular)?/gi, "200").replace(/light(_regular)?/gi, "300").replace(/_book|_normal|_roman/gi, "_regular").replace(/medium(_regular)?/gi, "500").replace(/(semi|demi)bold(_regular)?/gi, "600").replace(/(extra|ultra)bold(_regular)?/gi, "800").replace(/bold(_regular)?/gi, "700").replace(/(black|heavy|fatface)(_regular)?/gi, "900").replace(/([1-9]00)_italic/gi, "$1italic").replace(/regularitalic/gi, "italic").replace(/regularitalic/gi, "italic").split(" ").map((e) => e.charAt(0).toUpperCase() + e.slice(1)).join(" ");
}
function Bw(n) {
  let r = [];
  n.scene.objects.traverse((e, t) => {
    let o = t;
    if (o.type === "TextFrame") {
      let i = wt.defaultTwoLayerData("phong"), s = typeof o.color == "string" ? n.shared.colors[o.color] : o.color;
      i.layers[1].data.color = { r: s.r, g: s.g, b: s.b }, i.layers[1].data.alpha = o.alpha;
      let l = Lw(o.font);
      n.shared.fonts[l] === void 0 && (n.shared.fonts[l] = { name: l });
      let c = { name: o.name, ...Et.defaultData, ...So.defaultData, flatShading: false, wireframe: false, geometry: { ...Qr.defaultData("TextGeometry"), width: o.width, height: o.height, font: l, depth: 0, horizontalAlign: o.horizontalAlign, verticalAlign: o.verticalAlign, fontSize: o.fontSize * 1.40625, lineHeight: o.lineHeight / 1.40625, letterSpacing: o.letterSpacing - 1, text: o.text, textTransform: o.textTransform, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, material: i, states: Ye(o.states), events: Ye(o.events), visible: o.visible, raycastLock: o.raycastLock, position: o.position, rotation: o.rotation, scale: o.scale, hiddenMatrix: o.hiddenMatrix }, u = Ye(n.scene.objects).parent(e);
      n.scene.objects.insertAfter(u ?? null, e, [{ id: e + "new", data: c, children: [] }]), r.push(e);
    }
  }), r.forEach((e) => {
    n.scene.objects.delete(e);
  });
}
function Dw(n) {
  let r = { 0: "MouseDown", 1: "MouseUp", 2: "MouseHover", 5: "KeyDown", 6: "KeyUp", 7: "Start", 9: "LookAt", 10: "Follow", 11: "Scroll", 12: "Audio", 13: "GameControl" };
  n.scene.objects.traverse((e, t) => {
    t.events.forEach((o) => {
      if (!!r[Number(o.type)])
        if (Object.assign(o, { type: r[Number(o.type)] }), o.type === "Audio" && "audioEvent" in o && (Object.assign(o, { playAudio: o.audioEvent }), delete o.audioEvent), o.type === "GameControl")
          Object.assign(o, { gameActions: { idle: new he(), move: new he(), jump: new he() } });
        else {
          let i = new he();
          Object.assign(o, { actions: i }), (o.type === "MouseDown" || o.type === "MouseUp" || o.type === "KeyDown" || o.type === "KeyUp") && "url" in o && i.push({ fi: 0, id: MathUtils.generateUUID(), data: { type: "Link", url: o.url, delay: 0 } }), "targets" in o && (o.targets.forEach((s, l, c) => {
            let u = { state: void 0, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", duration: 0, easing: 4 }, a = { easing: s.easing, duration: s.duration };
            s.easing === 6 ? Object.assign(a, En(s, "mass", "stiffness", "damping", "velocity")) : s.easing === 5 && Object.assign(a, { control1: { ...s.control1 }, control2: { ...s.control2 } });
            let d = { repeat: s.repeat ? -1 : 0, delay: s.delay, delayDirection: s.delayDirection, direction: s.cycle && s.rewind ? "pingpong-rewind" : s.cycle ? "pingpong" : "normal" }, p = { state: s.state, ...d, ...a }, f = { allowSlerp: true, type: "Transition", object: s.object, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", tweens: new he({ fi: 0, id: MathUtils.generateUUID(), data: u }, { fi: 1, id: MathUtils.generateUUID(), data: p }) };
            i.push({ fi: c, id: l, data: f });
          }), delete o.targets);
        }
    });
  });
}
function Gw(n) {
  n.scene.objects.traverse((r, e) => {
    function t(o, i) {
      var _a2;
      let s = new he(), l = [];
      if (e.events.forEach((c, u, a) => {
        if (c.type === "Audio" && c.trigger === i) {
          let d;
          l.push(u), c.interaction === "play" ? d = { ...En(c, "interaction", "audio", "delay", "volume", "loop"), triggerAfter: "after" in c ? c.after : void 0, toggle: "after" in c ? c.toggle : void 0, type: "Audio" } : (c.interaction === "pause" || c.interaction === "stop") && (d = { ...En(c, "interaction", "delay", "object", "playAudio"), type: "Audio" }), d && s.push({ fi: a, id: u, data: d });
        }
      }), l.forEach((c) => e.events.delete(c)), s.length) {
        let c = (_a2 = e.events.find((u) => u.type === o)) == null ? void 0 : _a2.data;
        c ? "actions" in c && c.actions.insertBefore(null, s) : e.events.insertBefore(null, [{ id: MathUtils.generateUUID(), data: { type: o, actions: s } }]);
      }
    }
    t("Start", "start"), t("MouseDown", "mouseDown"), t("MouseUp", "mouseUp"), t("KeyDown", "keyDown"), t("KeyUp", "keyUp");
  });
}
function vm(n) {
  var _a2;
  let r = (_a2 = n.layers.find((e) => e.type === "light")) == null ? void 0 : _a2.data;
  if ((r == null ? void 0 : r.category) === "basic") {
    let e = ft.defaultData("light", "phong"), t = r;
    Object.assign(t, e), t.visible = false;
  }
}
function bm(n) {
  Da(n, vm), Ga(n, vm);
}
function Rw(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && e.geometry.type === "SubdivGeometry" && (e.geometry.scaleBaked || (e.geometry.scaleBaked = [1, 1, 1]));
  });
}
function Vw(n) {
  n.scene.objects.traverse((r, e) => {
    (e.type === "Empty" || e.type === "Mesh") && e.cloner && !e.cloner.randomnessObject && !e.cloner.toObject && !e.cloner.randomness && (e.cloner = { ...e.cloner, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, randomness: false, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } });
  });
}
function jw(n) {
  n.scene.objects.traverse((r, e) => {
    e.type === "Mesh" && e.geometry.type === "NonParametricGeometry" && !("material" in e) && !("materials" in e) && (e.material = wt.defaultTwoLayerData("phong"));
  });
}
function Fw(n) {
  n.scene.publish.orbitControls.autoZoom === void 0 && (n.scene.publish.orbitControls.autoZoom = false), n.scene.objects.traverse((r, e) => {
    (e.type === "OrthographicCamera" || e.type === "PerspectiveCamera") && (e.orthographic.autoZoom === void 0 && (e.orthographic.autoZoom = false), e.orthographic.autoZoomFrustumSize === void 0 && (e.orthographic.autoZoomFrustumSize = 790));
  });
}
function zw(n) {
  n.scene.objects.traverse((r, e) => {
    e.pathSnapping === void 0 && (e.pathSnapping = { pathId: null, slide: 0, offset: 0, orientation: "tangential" }), e.pathSnapping.offset === void 0 && (e.pathSnapping.offset = 0);
  });
}
function Uw(n) {
  n.scene.publish.mouseEventTarget === void 0 && (n.scene.publish.mouseEventTarget = "canvas"), n.scene.publish.settings.web.hint === void 0 && (n.scene.publish.settings.web.hint = false);
}
function kw(n) {
  let { video: r } = n.scene.publish.settings;
  r.format === "gif" && r.fps > 48 && (r.fps = 15);
}
function Hw(n) {
  n.scene.objects.traverse((r, e) => {
    e.events.forEach((t) => {
      t.type === "GameControl" && (t.resetYPosition = Math.abs(t.resetYPosition - e.position[1]));
    });
  });
}
var Sm = 36;
function wm(n) {
  let r = n.schema ?? 0;
  r !== Sm && (console.warn("updating from ", r, "to ", Sm), r < 1 && (Ga(n, hm), Da(n, hm), n.schema = 1), r < 2 && (hw(n), n.schema = 2), r < 3 && (gw(n), n.schema = 3), r < 4 && (xw(n), n.schema = 4), r < 5 && (vw(n), n.schema = 5), r < 6 && (bw(n), n.schema = 6), r < 7 && (Sw(n), n.schema = 7), r < 8 && (n.schema = 8), r < 9 && (gm(n), n.schema = 9), r < 10 && (Pw(n), n.schema = 10), r < 11 && (Ow(n), n.schema = 11), r < 12 && (gm(n), n.schema = 12), r < 13 && (Aw(n), n.schema = 13), r < 14 && (Cw(n), n.schema = 14), r < 15 && (Nw(n), n.schema = 15), r < 16 && (Ew(n), n.schema = 16), r < 17 && (Ga(n, xm), Da(n, xm), n.schema = 17), r < 18 && (Ga(n, ym), Da(n, ym), n.schema = 18), r < 19 && (yw(n), n.schema = 19), r < 20 && (Mw(n), Bw(n), n.schema = 20), r < 21 && (Dw(n), Gw(n), n.schema = 21), r < 22 && (bm(n), n.schema = 22), r < 23 && (Rw(n), n.schema = 23), r < 24 && (Vw(n), n.schema = 24), (r < 25 || n.shared.videos === void 0) && (Iw(n), r < 25 && (n.schema = 25)), r < 26 && (ww(n), n.schema = 26), r < 27 && (_w(n), n.schema = 27), r < 28 && (bm(n), n.schema = 28), r < 29 && (Tw(n), n.schema = 29), r < 30 && (jw(n), n.schema = 30), r < 31 && (Fw(n), n.schema = 31), r < 33 && (zw(n), n.schema = 33), r < 34 && (Uw(n), n.schema = 34), r < 35 && (kw(n), n.schema = 35), r < 36 && (Hw(n), n.schema = 36));
}
var ui = Bs(Tm());
var Ww = 0.5 * (Math.sqrt(3) - 1);
var Li = (3 - Math.sqrt(3)) / 6;
var qw = 1 / 3;
var hr = 1 / 6;
var YG = (Math.sqrt(5) - 1) / 4;
var XG = (5 - Math.sqrt(5)) / 20;
var Bi = (n) => Math.floor(n) | 0;
var Pm = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]);
var vc = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
function Ra(n = Math.random) {
  let r = Am(n), e = new Float64Array(r).map((o) => Pm[o % 12 * 2]), t = new Float64Array(r).map((o) => Pm[o % 12 * 2 + 1]);
  return function(i, s) {
    let l = 0, c = 0, u = 0, a = (i + s) * Ww, d = Bi(i + a), p = Bi(s + a), f = (d + p) * Li, m = d - f, h = p - f, y = i - m, g = s - h, v, S;
    y > g ? (v = 1, S = 0) : (v = 0, S = 1);
    let w = y - v + Li, b = g - S + Li, T = y - 1 + 2 * Li, _ = g - 1 + 2 * Li, x = d & 255, C = p & 255, P = 0.5 - y * y - g * g;
    if (P >= 0) {
      let A = x + r[C], G = e[A], z = t[A];
      P *= P, l = P * P * (G * y + z * g);
    }
    let I = 0.5 - w * w - b * b;
    if (I >= 0) {
      let A = x + v + r[C + S], G = e[A], z = t[A];
      I *= I, c = I * I * (G * w + z * b);
    }
    let O = 0.5 - T * T - _ * _;
    if (O >= 0) {
      let A = x + 1 + r[C + 1], G = e[A], z = t[A];
      O *= O, u = O * O * (G * T + z * _);
    }
    return 70 * (l + c + u);
  };
}
function Om(n = Math.random) {
  let r = Am(n), e = new Float64Array(r).map((i) => vc[i % 12 * 3]), t = new Float64Array(r).map((i) => vc[i % 12 * 3 + 1]), o = new Float64Array(r).map((i) => vc[i % 12 * 3 + 2]);
  return function(s, l, c) {
    let u, a, d, p, f = (s + l + c) * qw, m = Bi(s + f), h = Bi(l + f), y = Bi(c + f), g = (m + h + y) * hr, v = m - g, S = h - g, w = y - g, b = s - v, T = l - S, _ = c - w, x, C, P, I, O, A;
    b >= T ? T >= _ ? (x = 1, C = 0, P = 0, I = 1, O = 1, A = 0) : b >= _ ? (x = 1, C = 0, P = 0, I = 1, O = 0, A = 1) : (x = 0, C = 0, P = 1, I = 1, O = 0, A = 1) : T < _ ? (x = 0, C = 0, P = 1, I = 0, O = 1, A = 1) : b < _ ? (x = 0, C = 1, P = 0, I = 0, O = 1, A = 1) : (x = 0, C = 1, P = 0, I = 1, O = 1, A = 0);
    let G = b - x + hr, z = T - C + hr, $ = _ - P + hr, te = b - I + 2 * hr, K = T - O + 2 * hr, q = _ - A + 2 * hr, k = b - 1 + 3 * hr, R = T - 1 + 3 * hr, D = _ - 1 + 3 * hr, B = m & 255, L = h & 255, F = y & 255, W = 0.6 - b * b - T * T - _ * _;
    if (W < 0)
      u = 0;
    else {
      let E = B + r[L + r[F]];
      W *= W, u = W * W * (e[E] * b + t[E] * T + o[E] * _);
    }
    let H = 0.6 - G * G - z * z - $ * $;
    if (H < 0)
      a = 0;
    else {
      let E = B + x + r[L + C + r[F + P]];
      H *= H, a = H * H * (e[E] * G + t[E] * z + o[E] * $);
    }
    let j = 0.6 - te * te - K * K - q * q;
    if (j < 0)
      d = 0;
    else {
      let E = B + I + r[L + O + r[F + A]];
      j *= j, d = j * j * (e[E] * te + t[E] * K + o[E] * q);
    }
    let U = 0.6 - k * k - R * R - D * D;
    if (U < 0)
      p = 0;
    else {
      let E = B + 1 + r[L + 1 + r[F + 1]];
      U *= U, p = U * U * (e[E] * k + t[E] * R + o[E] * D);
    }
    return 32 * (u + a + d + p);
  };
}
function Am(n) {
  let e = new Uint8Array(512);
  for (let t = 0; t < 512 / 2; t++)
    e[t] = t;
  for (let t = 0; t < 512 / 2 - 1; t++) {
    let o = t + ~~(n() * (256 - t)), i = e[t];
    e[t] = e[o], e[o] = i;
  }
  for (let t = 256; t < 512; t++)
    e[t] = e[t - 256];
  return e;
}
var Xt = new Triangle();
var Va = class {
  constructor(r) {
    this.weightAttribute = null;
    let e = r.geometry;
    if (!e.isBufferGeometry || e.attributes.position.itemSize !== 3)
      throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
    e.index && (e = e.toNonIndexed()), this.geometry = e, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.distribution = null;
  }
  build() {
    let r = this.positionAttribute, e = new Float32Array(r.count / 3);
    for (let o = 0; o < r.count; o += 3) {
      let i = 1;
      Xt.a.fromBufferAttribute(r, o), Xt.b.fromBufferAttribute(r, o + 1), Xt.c.fromBufferAttribute(r, o + 2), i *= Xt.getArea(), e[o / 3] = i;
    }
    this.distribution = new Float32Array(r.count / 3);
    let t = 0;
    for (let o = 0; o < e.length; o++)
      t += e[o], this.distribution[o] = t;
    return this;
  }
  setRandomGenerator(r) {
    return this.randomFunction = r, this;
  }
  sample(r, e) {
    if (this.distribution) {
      let t = this.distribution[this.distribution.length - 1], o = this.binarySearch(this.randomFunction() * t);
      return this.sampleFace(o, r, e);
    }
  }
  binarySearch(r) {
    if (!this.distribution)
      return 0;
    let e = this.distribution, t = 0, o = e.length - 1, i = -1;
    for (; t <= o; ) {
      let s = Math.ceil((t + o) / 2);
      if (s === 0 || e[s - 1] <= r && e[s] > r) {
        i = s;
        break;
      } else
        r < e[s] ? o = s - 1 : t = s + 1;
    }
    return i;
  }
  sampleFace(r, e, t) {
    let o = this.randomFunction(), i = this.randomFunction();
    return o + i > 1 && (o = 1 - o, i = 1 - i), Xt.a.fromBufferAttribute(this.positionAttribute, r * 3), Xt.b.fromBufferAttribute(this.positionAttribute, r * 3 + 1), Xt.c.fromBufferAttribute(this.positionAttribute, r * 3 + 2), e.set(0, 0, 0).addScaledVector(Xt.a, o).addScaledVector(Xt.b, i).addScaledVector(Xt.c, 1 - (o + i)), Xt.getNormal(t), this;
  }
};
var Nm = Bs(Cm());
var Xw = new Matrix4();
var Kw = new Matrix4();
var Zw = new Matrix4();
var Di;
((r) => {
  function n(e) {
    return e && e.__isSPEObject;
  }
  r.is = n;
})(Di || (Di = {}));
var Mn = (n) => class extends n {
  constructor() {
    super(...arguments);
    this.hiddenMatrix = new Matrix4();
    this.matrixWorldRigid = new Matrix4();
    this.shearScale = new Matrix4();
    this.shearScaleInv = new Matrix4();
  }
  get __isSPEObject() {
    return true;
  }
  isDescendantOf(t) {
    t instanceof Object3D && (t = t.uuid);
    let o = this;
    for (; o.parent; ) {
      if (o.parent.uuid === t)
        return true;
      o = o.parent;
    }
    return false;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
    for (let o of this.children)
      o.updateMatrixWorld(t);
  }
  updateWorldMatrix(t, o) {
    let i = this.parent;
    if (t && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), o)
      for (let s of this.children)
        s.updateWorldMatrix(false, true);
  }
  traverseObject(t, o = 0) {
    if (t(this, o) !== true)
      for (let s of this.children)
        Di.is(s) && s.traverseObject(t, o + 1);
  }
  updateMatrixWorldSVD() {
    let t = this.matrixWorld.elements, o = [[t[0], t[4], t[8]], [t[1], t[5], t[9]], [t[2], t[6], t[10]]], { u: i, v: s, q: l } = (0, Nm.SVD)(o), c = Xw.set(i[0][0], i[0][1], i[0][2], 0, i[1][0], i[1][1], i[1][2], 0, i[2][0], i[2][1], i[2][2], 0, 0, 0, 0, 1), u = Kw.set(s[0][0], s[0][1], s[0][2], 0, s[1][0], s[1][1], s[1][2], 0, s[2][0], s[2][1], s[2][2], 0, 0, 0, 0, 1), a = Zw.copy(u).transpose();
    this.shearScale.makeScale(l[0], l[1], l[2]).multiply(a).premultiply(u), this.shearScaleInv.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(c, a).copyPosition(this.matrixWorld), l.every((d) => Math.abs(l[0] - d) < 0.01) ? this.hasNonUniformScale = false : this.hasNonUniformScale = true;
  }
  attach(t, o) {
    this.updateWorldMatrix(true, false);
    let i = new Matrix4().copy(this.matrixWorld).invert();
    return t.parent !== null && (t.parent.updateWorldMatrix(true, false), i.multiply(t.parent.matrixWorld)), "hiddenMatrix" in t && t.hiddenMatrix instanceof Matrix4 ? t.hiddenMatrix.premultiply(i) : t.applyMatrix4(i), t.updateWorldMatrix(false, false), this.add(t), o !== void 0 && (this.children.pop(), this.children.splice(o, 0, t)), this;
  }
};
var bc = class extends Mn(Object3D) {
};
var Jw = (n) => n.type === "Mesh";
var Fr = class extends bc {
  constructor(e) {
    super();
    this.object = e;
    this.matrixAutoUpdate = false;
  }
  expand() {
    let e = 0, t = this.object.entityChildren(e);
    for (; t; ) {
      let o = this.children[e];
      (o == null ? void 0 : o.object) !== t && (o && this.remove(o), o = new Fr(t), this.add(o), o.matrixAutoUpdate = false, o.matrix = t.matrix, o.hiddenMatrix = t.hiddenMatrix), o.expand(), e += 1, t = this.object.entityChildren(e);
    }
    for (; this.children.length > e; )
      this.remove(this.children[e]);
  }
  get visible() {
    var _a2;
    return this.object.visible || this.object.dataPatched.visible && ((_a2 = this.object.dataPatched.cloner) == null ? void 0 : _a2.hideBase) === true;
  }
  set visible(e) {
  }
  get castShadow() {
    return this.object.castShadow;
  }
  set castShadow(e) {
  }
  get receiveShadow() {
    return this.object.receiveShadow;
  }
  set receiveShadow(e) {
  }
  get isMesh() {
    return Jw(this.object);
  }
  get isLight() {
    return this.object.isLight;
  }
  get layers() {
    return this.object.layers;
  }
  set layers(e) {
  }
  get isCamera() {
    return false;
  }
  get geometry() {
    if (this.object.geometry)
      return this.object.geometry;
  }
  get material() {
    if (this.object.material)
      return this.object.material;
  }
};
var Oo = new Vector3();
var Ao = new Vector3();
var Ln = new Matrix4();
var Mm = [new Vector3(-1, 1, 1), new Vector3(-1, -1, 1), new Vector3(1, -1, 1), new Vector3(1, 1, 1), new Vector3(-1, 1, -1), new Vector3(-1, -1, -1), new Vector3(1, -1, -1), new Vector3(1, 1, -1)];
var r_ = [[0, 3], [1, 2], [5, 6], [4, 7], [0, 1], [3, 2], [7, 6], [4, 5], [0, 4], [1, 5], [2, 6], [3, 7]];
var o_ = [[0, 2], [7, 5], [4, 1], [3, 6], [4, 3], [1, 6]];
var Em = (n, r, e) => {
  n.updateEntityBoxSize(Oo, Ao), Ln.copy(r).multiply(n.matrixWorld), Ao.x === 0 && Ao.y === 0 && Ao.z === 0 ? e.push(new Vector3(Oo.x, Oo.y, Oo.z).applyMatrix4(Ln)) : Mm.forEach((t) => {
    e.push(t.clone().multiply(Ao).add(Oo).applyMatrix4(Ln));
  });
};
var Gi = class extends Box3 {
  constructor() {
    super(...arguments);
    this.matrix = new Matrix4();
    this.vertices = [];
    this.faces = [];
    this.edges = [];
    this.centerEdges = [];
  }
  copy(e) {
    return super.copy(e), this.matrix.copy(e.matrix), this.vertices = e.vertices.map((t) => t.clone()), this.faces = e.faces.map((t) => t.clone()), this.edges = e.edges.map((t) => t.clone()), this.centerEdges = e.centerEdges.map((t) => t.clone()), this;
  }
  setFromObjectSize(e, t = false) {
    e.updateWorldMatrix(false, t), this.makeEmpty(), this.matrix.copy(e.matrixWorld);
    let o = new Matrix4().copy(e.matrixWorld).invert();
    return this.expandByObjectSize(e, o, t);
  }
  expandByObjectSize(e, t, o = false) {
    let i = [];
    return o === true ? e.traverseEntity((s) => {
      (s.visible || s.cloner && s.data.visible) && Em(s, t, i);
    }) : Em(e, t, i), this.setFromPoints(i);
  }
  getCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(this.matrix), e;
  }
  getPositionToCenter(e) {
    return e = super.getCenter(e), e.applyMatrix4(Ln.copy(this.matrix).setPosition(0, 0, 0)), e;
  }
  computeVertices() {
    this.getSize(Ao).multiplyScalar(0.5), this.getCenter(Oo), Ln.copy(this.matrix).setPosition(Oo), this.vertices = Mm.map((e) => e.clone().multiply(Ao).applyMatrix4(Ln));
  }
  computeEdges() {
    this.vertices.length > 0 && this.computeVertices(), this.edges = r_.map(([e, t]) => new Line3(this.vertices[e], this.vertices[t])), this.centerEdges = this.edges.map((e) => e.getCenter(new Vector3()));
  }
  computeFaces() {
    this.vertices.length > 0 && this.computeVertices(), this.faces = o_.map(([e, t]) => this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(0.5));
  }
};
var Kt = { Cloner: () => {
}, changeEntityProptotype: () => {
}, createEntity: () => {
} };
var Tc = class extends CurvePath {
  constructor() {
    super();
  }
  getPoints(r = 12) {
    let e = [], t, o = this.getCurveLengths(), s = o[o.length - 1] / o.length;
    for (let l = 0, c = this.curves; l < c.length; l++) {
      let u = c[l], a = l === 0 ? o[l] : o[l] - o[l - 1], d = Math.ceil(r * a / s), p = u.getPoints(d);
      for (let f = 0; f < p.length; f++) {
        let m = p[f];
        t && t.equals(m) || (e.push(m), t = m);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
};
var Pc = 1e-3;
function Oc(n, r, e) {
  return r.clone().sub(n).cross(r.clone().sub(e)).length() <= Pc;
}
function _c(n, r) {
  let e = new Vector3(...n.position), t = new Vector3(...n.controlNext.position), o = new Vector3(...r.controlPrevious.position), i = new Vector3(...r.position);
  return Oc(e, t, i) && Oc(e, o, i);
}
function Fa(n) {
  let r = n.points.map((a) => new Vector3(...a.data.position)), e = [n.points[0]], t = new Vector3(...e[0].data.position);
  for (let a = 0; a < n.points.length - 1; a++)
    Oc(t, r[a], r[a + 1]) || (e.push(n.points[a]), t = r[a]);
  e.push(n.points[n.points.length - 1]);
  let o = n.isClosed, i = e.length - (o ? 0 : 1), s = e.length, l = [];
  for (let a = 0; a < s; a++) {
    let d = e[a].data, p = new Vector3(...d.position), f = new Vector3(...d.controlPrevious.position), m = new Vector3(...d.controlNext.position), h = { position: p, baseRoundness: d.roundness, controlPrevious: f, controlNext: m };
    if (d.roundness === 0 || !n.isClosed && (a === 0 || a === s - 1)) {
      l[a] = { ...h, removedLength: 0 };
      continue;
    }
    let y = o && a == 0 ? s - 1 : a - 1, g = o && a == s - 1 ? 0 : a + 1, v = e[y].data, S = e[g].data, w = new Vector3(...v.position), b = new Vector3(...S.position), T = w.clone().sub(p).normalize(), _ = b.clone().sub(p).normalize();
    Object.assign(h, { prevDir: T, nextDir: _ });
    let x = _c(v, d), C = _c(d, S);
    if (!x || !C)
      l[a] = { ...h, removedLength: 0 };
    else {
      let P = T.clone().add(_).normalize(), I = P.clone().cross(T).length() / T.dot(P);
      l[a] = { ...h, tan: I, removedLength: d.roundness / I };
    }
  }
  for (let a = 0; a < i; a++) {
    let d = a, p = o && a === s - 1 ? 0 : a + 1, f = l[d], m = l[p];
    if (f.removedLength !== 0 || m.removedLength !== 0) {
      let h = f.position.distanceTo(m.position);
      f.removedLength = Math.min(f.removedLength, h / 2), m.removedLength = Math.min(m.removedLength, h / 2);
    }
  }
  let c = [];
  for (let a = 0; a < i; a++) {
    let d = a, p = o && a === s - 1 ? 0 : a + 1, f = l[d], m = l[p], h = null;
    if (!_c(e[d].data, e[p].data))
      f.position.distanceTo(m.position) > Pc && (h = new CubicBezierCurve3(f.position, f.controlNext, m.controlPrevious, m.position));
    else {
      let y = f.position.clone(), g = m.position.clone();
      (f.removedLength !== 0 || m.removedLength !== 0) && (f.nextDir && y.add(f.nextDir.clone().setLength(f.removedLength)), m.prevDir && g.add(m.prevDir.clone().setLength(m.removedLength))), y.distanceTo(g) > Pc && (h = new CubicBezierCurve3(y, y.clone().lerp(g, 0.3), g.clone().lerp(y, 0.3), g));
    }
    c[2 * a + 1] = h;
  }
  for (let a = 0; a < s; a++) {
    let d = l[a];
    if (d.removedLength === 0) {
      c[2 * a] = null;
      continue;
    }
    let p = d.position, f = d.prevDir.clone().multiplyScalar(d.removedLength).add(p), m = d.nextDir.clone().multiplyScalar(d.removedLength).add(p), h = d.tan * d.removedLength, y = d.prevDir.clone().add(d.nextDir).normalize(), g = f.clone().lerp(m, 0.5), v = f.distanceTo(m) / 2, S = y.clone().multiplyScalar(Math.sqrt(Math.pow(h, 2) - Math.pow(v, 2))).add(g), w = y.clone().multiplyScalar(-h).add(S), b = p.distanceTo(w) / p.distanceTo(g), T = d.prevDir.clone().multiplyScalar(b * p.distanceTo(f)).add(p), _ = T.clone().lerp(w, 2), x = f.clone().lerp(T, 4 / 3), C = m.clone().lerp(_, 4 / 3);
    c[2 * a] = new CubicBezierCurve3(f, x, C, m);
  }
  let u = new Tc();
  return c.forEach((a) => {
    a && u.add(a);
  }), u;
}
var Ce;
((r) => {
  function n(e) {
    return e && e.__isEntity;
  }
  r.is = n;
})(Ce || (Ce = {}));
var Ri = (n) => Ce.is(n);
var Ua = (n) => class extends Mn(n) {
  constructor() {
    super(...arguments);
    this.raycastLock = false;
    this.scaleLock = false;
    this.disposed = false;
    this.stateSelection = null;
    this.instances = [];
    this.prevState = null;
    this.currentState = null;
    this.reversibleToState = null;
    this.currentTransitionEvent = null;
    this.previousAction = null;
    this._singleBBox = new Gi();
    this._recursiveBBox = new Gi();
    this.singleBBoxNeedsUpdate = true;
    this.recursiveBBoxNeedsUpdate = true;
    this.attachedPaths = /* @__PURE__ */ new Set();
  }
  get __isEntity() {
    return true;
  }
  entityChildren(t) {
    let o = this.children[t];
    if (Ce.is(o))
      return o;
  }
  get isConcreteEntity() {
    return typeof this.identity == "string";
  }
  get isVirtualEntity() {
    return typeof this.identity != "string";
  }
  get isInstanceRoot() {
    return this.isConcreteEntity && this.data.type === "Instance";
  }
  nearestInstanceSelfOrParent() {
    let t = this;
    for (; t.data.type !== "Instance"; ) {
      let o = t.parent;
      if (Ce.is(o))
        t = o;
      else
        return;
    }
    return t;
  }
  forInstancesRec(t) {
    this.instances.forEach((o) => {
      o.disposed || t(o), o.forInstancesRec(t);
    });
  }
  super_Entity(t, o) {
    typeof t == "string" && (this.uuid = t), this.identity = t, this.data = o, this.matrixAutoUpdate = false, this.dataPatched = this.data;
  }
  changeSelectedState(t, o, i = false) {
    if (!(this.data.states.length === 0 && !i)) {
      for (let s of this.data.states)
        wo.toOps(this.data, s.data).forEach((c) => {
          let u = Vs.replaceProps(c, this.data);
          this.dataPatched = this.data, this.updateByPatchedOp(u, this.data, o);
        });
      if (t !== null) {
        let s = this.data.states.data(t);
        s && (this.dataPatched = wo.patch(this.data, s), wo.toOps(this.data, s).forEach((c) => {
          this.updateByPatchedOp(c, this.dataPatched, o);
        }));
      }
      i && this.updateTransformState(this.dataPatched), this.stateSelection = t, this.updatePathSnapping(this.dataPatched.pathSnapping);
    }
  }
  get singleBBox() {
    return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = false, this._singleBBox.setFromObjectSize(this, false), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox;
  }
  get recursiveBBox() {
    return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = false, this._recursiveBBox.setFromObjectSize(this, true), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox;
  }
  updateEntityBoxSize(t, o) {
    t.setScalar(0), o.setScalar(0);
  }
  resetBBoxNeedsUpdateSelf() {
    this.singleBBoxNeedsUpdate = true, this.recursiveBBoxNeedsUpdate = true;
  }
  resetBBoxNeedsUpdate() {
    this.resetBBoxNeedsUpdateSelf(), this.traverseAncestors((t) => {
      Ri(t) && t.resetBBoxNeedsUpdateSelf();
    }), this.traverseEntity((t) => {
      t.resetBBoxNeedsUpdateSelf();
    });
  }
  find(t) {
    let o;
    return this.traverseEntity((i) => {
      i.uuid === t && (o = i);
    }), o;
  }
  traverseSortNextHelper() {
    let t = this.parent;
    if (t) {
      let o = t.children, i = o.indexOf(this) + 1;
      if (Ce.is(o[i]))
        return o[i];
      if (Ce.is(t))
        return t.traverseSortNextHelper();
    }
  }
  sortNext() {
    let t = this.children;
    return this.children.length > 0 && Ce.is(this.children[0]) ? t[0] : this.traverseSortNextHelper();
  }
  goUp(t) {
    let o = this;
    for (; t > 0 && o !== null; )
      o = o.parent, t -= 1;
    return o;
  }
  hasAnccestorOrSelf(t) {
    return this === t || this.hasAnccestor(t);
  }
  hasAnccestor(t) {
    let o = this.parent;
    for (; o; ) {
      if (t === o)
        return true;
      o = o.parent;
    }
    return false;
  }
  countToAccestor(t) {
    let o = 0, i = this;
    for (; i !== t; ) {
      if (i === null)
        return -1;
      i = i.parent, o += 1;
    }
    return o;
  }
  forEachEntity(t) {
    for (let o of this.children)
      Ri(o) && t(o);
  }
  traverseEntityAncestors(t) {
    this.traverseAncestors((o) => {
      Ce.is(o) && t(o);
    });
  }
  traverseEntity(t, o = 0) {
    if (t(this, o) !== true)
      for (let s of this.children)
        Ri(s) && s.traverseEntity(t, o + 1);
  }
  traverseVisibleEntity(t) {
    t(this);
    for (let o of this.children)
      Ri(o) && o.visible && o.traverseVisibleEntity(t);
  }
  updateMatrix() {
    super.updateMatrix(), this.cloner && this.cloner.onObjUpdateMatrix(), this.dispatchEvent({ type: "updateMatrix" });
  }
  copy(t, o = true) {
    return super.copy(t, false), this.raycastLock = t.raycastLock, this.scaleLock = t.scaleLock, this.hiddenMatrix.copy(t.hiddenMatrix), this;
  }
  hasEntityChild() {
    return this.children.some((t) => Ri(t));
  }
  isAncestorOf(t) {
    if (this.uuid === t)
      return false;
    let o = false;
    return this.traverseEntity((i) => {
      i.uuid === t && (o = true);
    }), o;
  }
  toObjectTransformState(t = []) {
    this.updateWorldMatrix(true, false);
    let o = { position: this.position.toArray(), rotation: [this.rotation.x, this.rotation.y, this.rotation.z], scale: this.scale.toArray(), hiddenMatrix: this.hiddenMatrix.toArray() };
    return Nn(o, t);
  }
  updateTransformState(t) {
    let o = false;
    return t.position && (this.position.fromArray(t.position), o = true), t.rotation && (this.rotation.fromArray(t.rotation), o = true), t.scale && (o = true, this.scale.fromArray(t.scale)), t.hiddenMatrix !== void 0 && (o = true, this.hiddenMatrix.fromArray(t.hiddenMatrix ?? Zr.identity)), o && (this.updateMatrix(), this.resetBBoxNeedsUpdate(), this.invalidateClonerTransform(this), this.traverseEntityAncestors((i) => {
      i.invalidateClonerTransform(this);
    })), t.position && t.rotation && t.scale && t.hiddenMatrix !== void 0 && this.updateWorldMatrix(false, true), o;
  }
  dispose() {
    this.disposed = true, this.cloner && (this.cloner.removeFromParent(), this.cloner = void 0);
  }
  disposeChildrenRecursively() {
    for (let t of this.children)
      Ce.is(t) && t.disposeRecursively();
  }
  disposeRecursively() {
    this.dispose(), this.children.forEach((t) => {
      Ce.is(t) && t.disposeRecursively();
    });
  }
  toState(t = []) {
    let o = { name: this.name, visible: this.visible, raycastLock: this.raycastLock, ...this.toObjectTransformState(t) };
    return Nn(o, t);
  }
  updateByOp(t, o, i, s) {
    let l = this.data;
    this.data = o;
    let c = t, u = qt(t.path, ["states", "*"]);
    if (u !== null) {
      if (t.type === 0) {
        let [a] = u;
        if ((this == null ? void 0 : this.stateSelection) === a) {
          let d = { ...t.props };
          if (Object.values(t.props).some((p) => p === void 0)) {
            let p = this.data;
            if (p !== void 0) {
              let f = ut.zoom(p, t.path.slice(2));
              if (f)
                for (let m in t.props)
                  t.props[m] === void 0 && m in f && (d[m] = f[m]);
            }
          }
          c = { ...t, props: d, path: t.path.slice(2) };
        }
      }
    } else if (t.type === 0) {
      let a = this.stateSelection ? this.data.states.data(this.stateSelection) : void 0;
      if (a !== void 0) {
        if (t.props.name !== void 0 && a.name) {
          let { name: p, ...f } = a;
          a = f;
        }
        if (t.props.material !== void 0 && "material" in a) {
          let { material: p, ...f } = a;
          a = f;
        }
        let d = ut.removeOverridden(t.path, t.props, a);
        c = { ...t, props: d };
      }
    }
    if (this.updateByPatchedOpBase(c, wo.patch(this.data, this.stateSelection ? this.data.states.data(this.stateSelection) : void 0), i), qt(t.path, ["overrides"])) {
      let a = [], d = [...t.path];
      for (a.push(d[1]), d.splice(0, 2); d.length > 0 && d[0] === "descendants"; )
        a.push(d[1]), d.splice(0, 2);
      if (a[a.length - 1] === void 0) {
        if (t.type === 0)
          for (let p of Object.keys(t.props)) {
            a[a.length - 1] = p;
            let f = i.scene.findInstance([this.uuid, ...a]);
            f && (f.overrideData = t.props[p], f.updateState(Er.apply(f.component.data, f.overrideData), i));
          }
      } else {
        let p = i.scene.findInstance([this.uuid, ...a]);
        if (p) {
          let f = ut.zoom(p.component.data, d);
          if (t = { ...t, path: d }, t.type === 0) {
            let m = t.props;
            if (f)
              for (let [h, y] of Object.entries(t.props))
                y === void 0 && (m === t.props && (m = { ...t.props }), m[h] = f[h]);
            t = { ...t, props: m };
          }
          p.overrideData = sn.resolve(o.overrides, a), p.updateByOp(t, rt.applySimple(p.data, t), i, false);
        }
      }
    } else if (this.instances.length > 0) {
      let a;
      if (t.path.length === 0 && t.type === 0) {
        let d;
        for (let p of Jr.rootOverrideProps)
          p in t.props && (d === void 0 && (d = {}), d[p] = t.props[p]);
        d && (a = { ...t, props: d });
      } else
        for (let d of Jr.rootOverrideProps)
          if (qt(t.path, [d])) {
            a = t;
            break;
          }
      a !== void 0 && this.instances.forEach((d) => {
        if (d.isInstanceRoot) {
          let p = Er.filterOp(d.overrideData, a);
          p && d.updateByOp(p, rt.applySimple(d.data, p), i, true);
        }
      }), this.instances.forEach((d) => {
        if (!d.isInstanceRoot) {
          let p = Er.filterOp(d.overrideData, t);
          if (p) {
            let f;
            l === d.data && t === p ? f = o : f = rt.applySimple(d.data, p), d.updateByOp(p, f, i, true);
          }
        }
      });
    }
  }
  updateByPatchedOpBase(t, o, i) {
    if (this.dataPatched = o, t.path.length === 0 && t.type === 0)
      t.props.type !== void 0 && !Yt.is(t.props.type) && Kt.changeEntityProptotype(this, o, i);
    else if (t.path.length === 1 && t.path[0] === "geometry" && t.type === 0 && "type" in t.props) {
      Kt.changeEntityProptotype(this, o, i);
      for (let s of this.children)
        Ce.is(s) && s.updateVisible();
    }
    this.updateByPatchedOp(t, o, i);
  }
  updateByPatchedOp(t, o, i) {
    if (t.path.length === 0 && t.type === 0 && this.updateState(t.props, i), qt(t.path, ["pathSnapping"]) !== null && this.updatePathSnapping(o.pathSnapping), qt(t.path, ["cloner"]) !== null) {
      let s = rt.drop(t, 1);
      s.path.length === 0 && s.type === 0 && s.props.disabled === true ? this.setFromClonerState(null, i) : this.cloner ? this.cloner.updateState(o.cloner, i.scene) : (this.setFromClonerState(o.cloner, i), this.expandCloner(i.scene)), this.updateVisible();
    }
  }
  updatePathSnapping(t) {
    this._updatedPathSnapping = t;
  }
  applyPathSnapping(t) {
    var _a2;
    let o = this._updatedPathSnapping || this.dataPatched.pathSnapping;
    if (o.pathId === null)
      return;
    let i = t.find(o.pathId);
    if (!i)
      return;
    let s = i.data, l = Fa(s.geometry.path), c = (o.slide + o.offset) % 1, u = l.getPointAt(c), a = this.parent ? (_a2 = this.parent) == null ? void 0 : _a2.matrixWorld : new Matrix4();
    i.updateMatrixWorld();
    let d = new Matrix4().multiplyMatrices(a.clone().invert(), i.matrixWorld);
    u.applyMatrix4(d);
    let p = { position: u.toArray(), rotation: s.rotation };
    if (o.orientation === "tangential") {
      let f = new Matrix4().extractRotation(i.matrixWorld), m = l.getTangentAt(c).applyMatrix4(f).add(u), h = new Matrix4().lookAt(u, m, new Vector3(0, 1, 0)), y = new Euler().setFromRotationMatrix(h);
      p = { ...p, rotation: [y.x, y.y, y.z] };
    }
    this.updateTransformState(p);
  }
  updateVisible() {
    var _a2;
    this.visible = this.dataPatched.visible && (!this.dataPatched.cloner || (this.dataPatched.cloner.disabled ?? false) || ((_a2 = this.dataPatched.cloner) == null ? void 0 : _a2.hideBase) !== true);
  }
  updateState_Entity(t, o) {
    t.name !== void 0 && (this.name = t.name), t.raycastLock !== void 0 && (this.raycastLock = t.raycastLock), t.visible !== void 0 && (this.updateVisible(), this.resetBBoxNeedsUpdate()), "cloner" in t && t.cloner !== void 0 && (this.setFromClonerState(t.cloner, o), this.updateVisible()), this.updateTransformState(t);
  }
  get attachedSurfaceCloners() {
    return this.children.filter((t) => t instanceof Kt.Cloner && t.parameters.type === "toObject");
  }
  setFromClonerState(t, o) {
    this.disposed || (t === null || t.disabled ? (this.cloner && this.cloner.removeFromParent(), this.cloner = void 0) : (this.cloner === void 0 && (this.cloner = new Kt.Cloner(this, t), o.scene.addPendingExpandCloner(this)), this.cloner.updateState(t, o.scene)));
  }
  expandCloner(t) {
    !this.disposed && this.cloner && this.cloner.expandClones(t);
  }
  invalidateClonerTransform(t) {
    this.cloner && this.cloner.invalidateTransform(t);
  }
};
var Bm = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 64, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadius: 0, cornerSegments: 8, hollow: 0 }, n.parameters), t = e.width / 2, o = e.radiusTop ?? t, i = e.radiusBottom ?? t;
    return o === i ? (o = t, i = t) : o > i ? (o = t, i = i * t / o) : (o = o * t / i, i = t), { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), radiusTop: o, radiusBottom: i }) };
  }
  static build(n) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: i, openEnded: s, thetaStart: l, thetaLength: c, radiusTop: u, radiusBottom: a, cornerRadius: d, cornerSegments: p, hollow: f } = n.parameters, m;
    return d || f ? m = new Vi(u, a, t, o, i, s, l, c * Math.PI / 180, d, d, p, f) : m = new CylinderGeometry(u, a, t, o, i, s, l, c * Math.PI / 180), m.scale(1, 1, e / r), Object.assign(m, { userData: { ...n, type: "CylinderGeometry" } });
  }
};
function io(n, r, e) {
  e.x = n.x * r.x, e.y = n.y, e.z = n.x * r.y;
}
function Lm(n) {
  return new Vector2(n.y, -n.x);
}
var Vi = class extends BufferGeometry {
  constructor(r, e, t, o, i, s, l, c, u, a, d, p, f = false) {
    super(), this.type = "RoundedCylinderBufferGeometry", r = r !== void 0 ? r : 1, e = e !== void 0 ? e : 1, t = t || 1, o = Math.floor(o) || 8, i = Math.floor(i) || 1, s = s !== void 0 ? s : false, l = l !== void 0 ? l : 0, c = c !== void 0 ? c : Math.PI * 2, s && (u = 0, a = 0);
    let m = [], h = [], y = [], g = [], v = 0, S = t / 2, w = new Vector3(), b = new Vector3();
    f && r == 0 && (r = u), f && e == 0 && (e = a);
    let T = new Vector2(r, S), _ = new Vector2(e, -S), x = null, C = null, P = null, I = null, O = T.clone().sub(_), A = 0, G = 0, z = 0;
    p > 0 && (A = Math.min(r, e) * (1 - p), G = r - A, z = e - A);
    let $ = T.clone();
    $.x -= A;
    let te = Math.PI - O.angle(), K = O.angle(), q = Math.tan(K / 2), k = Math.tan(te / 2), R = q + k, D = p ? R : k, B = p ? R : q;
    if (u = Math.min(u, (r - G) / D, O.length() / R), a = Math.min(a, (e - z) / B, O.length() / R), u > 0) {
      let U = u / q;
      x = T.clone().sub(new Vector2(U, u)), p && (P = x.clone(), P.x -= A - R * u), T.sub(O.clone().setLength(U));
    }
    if (a > 0) {
      let U = a / k;
      C = _.clone().sub(new Vector2(U, -a)), _.add(O.clone().setLength(U)), p && (I = C.clone(), I.x -= A - R * a, $.sub(O.clone().setLength(U)));
    }
    O = T.clone().sub(_);
    let L = O.length() < 0.5, F = [];
    for (let U = 0; U <= o; U++) {
      let E = [], oe = U / o, Y = oe * c + l, re = new Vector2(Math.sin(Y), Math.cos(Y));
      I && C ? (W(E, oe, re, te, a, I, -1, true), W(E, oe, re, K, a, C, -1, false)) : C ? (H(E, re, C.x, 0, -1), W(E, oe, re, K, a, C, -1, false)) : s || H(E, re, e, z, -1);
      let X = Lm(O).normalize();
      if (io(X, re, w), !L)
        for (let ee = 0; ee <= i; ee++) {
          let Z = ee / i, ie = O.clone().multiplyScalar(Z).add(_);
          io(ie, re, b), h.push(b.x, b.y, b.z), y.push(w.x, w.y, w.z), g.push(oe, 0.5 + b.y / t), E.push(v++);
        }
      if (P && x ? (W(E, oe, re, te, u, x, 1, false), W(E, oe, re, K, u, P, 1, true)) : x ? (W(E, oe, re, te, u, x, 1, false), H(E, re, x.x, 0, 1)) : s || H(E, re, r, G, 1), p && !L) {
        let ee = Lm(O).multiplyScalar(-1).normalize();
        io(ee, re, w);
        for (let Z = 0; Z <= i; Z++) {
          let ie = Z / i, ce = O.clone().multiplyScalar(-ie).add($);
          io(ce, re, b), h.push(b.x, b.y, b.z), y.push(w.x, w.y, w.z), g.push(oe, 0.5 + b.y / t), E.push(v++);
        }
      }
      p && !s && E.push(E[0]), F.push(E);
    }
    for (let U = 0; U < F.length - 1; U++)
      for (let E = 0; E < F[0].length - 1; E++) {
        if (s && p && E == i)
          continue;
        let oe = F[U][E], Y = F[U + 1][E], re = F[U + 1][E + 1], X = F[U][E + 1], ee = h[re * 3 + 0], Z = h[re * 3 + 2];
        m.push(oe, Y, X), (ee != 0 || Z != 0) && m.push(Y, re, X);
      }
    c < Math.PI * 2 && (j(-1, F[0], l), j(1, F[F.length - 1], l + c)), this.setIndex(m), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(y, 3)), this.setAttribute("uv", new Float32BufferAttribute(g, 2));
    function W(U, E, oe, Y, re, X, ee, Z) {
      for (let ie = 0; ie < d + 1; ie++) {
        let ce = ie / d, se = ee < 0 ? ce : 1 - ce;
        Z && (se -= 1), se *= Y;
        let pe = new Vector2(Math.sin(se), Math.cos(se) * ee), Le = pe.clone().multiplyScalar(re).add(X);
        io(Le, oe, b), h.push(b.x, b.y, b.z), io(pe, oe, w), y.push(w.x, w.y, w.z), g.push(E, 0.5 + b.y / t), U.push(v++);
      }
    }
    function H(U, E, oe, Y, re) {
      let X = new Vector3(), ee = new Vector2(), Z = [oe, Y];
      re < 0 && Z.reverse();
      for (let ie of Z)
        ee.set(ie, S * re), io(ee, E, X), h.push(X.x, X.y, X.z), y.push(0, re, 0), g.push(0.5, 0.5), U.push(v++);
    }
    function j(U, E, oe) {
      let Y = new Vector2(Math.sin(oe), Math.cos(oe)), re = new Vector2(-Math.cos(oe), Math.sin(oe)), X = new Vector3(), ee = U < 0 ? (ce, se, pe) => m.push(ce, se, pe) : (ce, se, pe) => m.push(ce, pe, se), Z = new Vector2((r + e + G + z) / 4, 0);
      io(Z, Y, X), h.push(X.x, X.y, X.z), y.push(re.x, 0, re.y), g.push(0.5, 0.5);
      let ie = v++;
      for (let ce of E) {
        let se = h.slice(ce * 3, ce * 3 + 3);
        h.push(...se), y.push(re.x, 0, re.y);
        let pe = g.slice(ce * 2, ce * 2 + 2);
        g.push(...pe), v++;
      }
      for (let ce = ie + 1; ce < v - 1; ce++)
        ee(ie, ce, ce + 1);
      ee(ie, v - 1, ie + 1);
    }
  }
};
var Dm = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 32, heightSegments: 8, openEnded: false, thetaStart: 0, thetaLength: 360, cornerRadiusTop: 0, cornerRadiusBottom: 0, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, depth: e, height: t, radialSegments: o, heightSegments: i, openEnded: s, thetaStart: l, thetaLength: c, cornerRadiusTop: u, cornerRadiusBottom: a, cornerSegments: d } = n.parameters, p;
    return u > 0 || a > 0 || c < 360 ? p = new Vi(0, r / 2, t, o, i, s, l, c * Math.PI / 180, u, a, d, 0, true) : p = new ConeGeometry(r / 2, t, o, i, s), p.scale(1, 1, e / r), Object.assign(p, { userData: { ...n, type: "ConeGeometry" } });
  }
};
var Gm = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, widthSegments: 1, heightSegments: 1, depthSegments: 1, cornerRadius: 0, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, widthSegments: o, heightSegments: i, depthSegments: s, cornerRadius: l, cornerSegments: c } = n.parameters, u;
    return l == 0 ? u = new BoxGeometry(r, e, t, o, i, s) : u = new Nc(r, e, t, o, i, s, l, c), Object.assign(u, { userData: { ...n, type: "CubeGeometry" } });
  }
};
var Cc = Math.PI / 2;
var Nc = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 1, i = 1, s = 1, l = 0, c = 4) {
    super(), this.type = "BoxGeometry";
    let u = this;
    o = Math.floor(o), i = Math.floor(i), s = Math.floor(s), c = Math.floor(c), l = Math.min(l, r / 2, e / 2, t / 2);
    let a = [], d = [], p = [], f = [], m = 0, h = 0;
    y("z", "y", "x", -1, -1, t, e, r, s, i, 0), y("z", "y", "x", 1, -1, t, e, -r, s, i, 1), y("x", "z", "y", 1, 1, r, t, e, o, s, 2), y("x", "z", "y", 1, -1, r, t, -e, o, s, 3), y("x", "y", "z", 1, -1, r, e, t, o, i, 4), y("x", "y", "z", -1, -1, r, e, -t, o, i, 5), l > 0 && (g("z", "y", "x", -1, -1, 1, t, e, r, s, 0), g("z", "y", "x", 1, -1, -1, t, e, r, s, 1), g("z", "y", "x", -1, 1, -1, t, e, r, s, 1), g("z", "y", "x", 1, 1, 1, t, e, r, s, 0), g("x", "y", "z", -1, -1, -1, r, e, t, o, 0), g("x", "y", "z", 1, -1, 1, r, e, t, o, 1), g("x", "y", "z", -1, 1, 1, r, e, t, o, 0), g("x", "y", "z", 1, 1, -1, r, e, t, o, 1), g("y", "x", "z", -1, -1, 1, e, r, t, i, 0), g("y", "x", "z", 1, -1, -1, e, r, t, i, 1), g("y", "x", "z", 1, 1, 1, e, r, t, i, 1), g("y", "x", "z", -1, 1, -1, e, r, t, i, 0), v(1, 1, 1), v(-1, 1, 1), v(1, -1, 1), v(-1, -1, 1), v(1, 1, -1), v(-1, 1, -1), v(1, -1, -1), v(-1, -1, -1)), this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(d, 3)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("uv", new Float32BufferAttribute(f, 2));
    function y(S, w, b, T, _, x, C, P, I, O, A) {
      let G = (x - 2 * l) / I, z = (C - 2 * l) / O, $ = x / 2 - l, te = C / 2 - l, K = P / 2, q = I + 1, k = O + 1, R = 0, D = 0, B = new Vector3();
      for (let L = 0; L < k; L++) {
        let F = L * z - te;
        for (let W = 0; W < q; W++) {
          let H = W * G - $;
          B[S] = H * T, B[w] = F * _, B[b] = K, d.push(B.x, B.y, B.z), B[S] = 0, B[w] = 0, B[b] = P > 0 ? 1 : -1, p.push(B.x, B.y, B.z), f.push(W / I), f.push(1 - L / O), R += 1;
        }
      }
      for (let L = 0; L < O; L++)
        for (let F = 0; F < I; F++) {
          let W = m + F + q * L, H = m + F + q * (L + 1), j = m + (F + 1) + q * (L + 1), U = m + (F + 1) + q * L;
          a.push(W, H, U), a.push(H, j, U), D += 6;
        }
      u.addGroup(h, D, A), h += D, m += R;
    }
    function g(S, w, b, T, _, x, C, P, I, O, A) {
      let G = (C - 2 * l) / O, z = C / 2 - l, $ = P / 2 - l, te = I / 2, K = O + 1, q = 0, k = 0, R = new Vector3(), D = new Vector3();
      for (let B = 0; B < c + 1; B++) {
        let L = B / c * Cc, F = Math.sin(L) * l, W = (1 - Math.cos(L)) * l, H = Math.sin(L), j = Math.cos(L);
        R[w] = ($ + F) * _, R[b] = (te - W) * x, D[S] = 0, D[w] = H * Math.sign(R[w]), D[b] = j * Math.sign(R[b]);
        for (let U = 0; U < K; U++) {
          let E = U * G - z;
          R[S] = E * T, d.push(R.x, R.y, R.z), p.push(D.x, D.y, D.z), f.push(U / O), f.push(0), q += 1;
        }
      }
      for (let B = 0; B < c; B++)
        for (let L = 0; L < O; L++) {
          let F = m + L + K * B, W = m + L + K * (B + 1), H = m + (L + 1) + K * (B + 1), j = m + (L + 1) + K * B;
          a.push(F, W, j), a.push(W, H, j), k += 6;
        }
      u.addGroup(h, k, A), h += k, m += q;
    }
    function v(S, w, b) {
      let T = new Vector3(), _ = new Vector3(r / 2, e / 2, t / 2);
      _.subScalar(l);
      let x = [], C = S * w * b > 0 ? (I, O, A) => a.push(I, O, A) : (I, O, A) => a.push(I, A, O);
      for (let I = 0; I <= c; I++) {
        let O = [], A = Cc * (1 - I / c), G = Math.cos(A), z = Math.sin(A), $ = 0;
        for (let te = 0; te <= I; te++) {
          let K = Math.cos($), q = Math.sin($);
          T.x = G * K, T.y = z, T.z = G * q;
          let k = _.clone().addScaledVector(T, l);
          d.push(S * k.x, w * k.y, b * k.z), p.push(S * T.x, w * T.y, b * T.z), f.push(0, 0), O.push(m++), $ += Cc / I;
        }
        x.push(O);
      }
      let P = x.length - 1;
      for (let I = 0; I < P; I++) {
        let O = x[I], A = x[I + 1], G = O.length - 1;
        C(O[0], A[1], A[0]);
        for (let z = 1; z <= G; z++)
          C(O[z - 1], O[z], A[z]), C(O[z], A[z + 1], A[z]);
      }
    }
  }
};
var so = class extends BufferGeometry {
  constructor(r = [], e = [], t = "", o = 1, i = 0.2, s = 4) {
    super(), this.type = "PolyhedronGeometryRound";
    let l = [], c = [], u = [];
    a(), d(), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2));
    return;
    function a() {
      var _a2;
      i = Math.min(1 - 1e-5, i), i == 0 && (s = 0);
      let f = { IcosahedronGeometry: 5, DodecahedronGeometry: 3, HexahedronGeometry: 3, OctahedronGeometry: 4, TetrahedronGeometry: 3 }[t], m = new Vector3(), h = m.clone(), y = new Triangle(), g = i * o, v = o - g, S = s + 1, w = new Vector3(), b = (q, k) => w.subVectors(q, k).normalize(), T = (q, k) => Array(q).fill(void 0).map(k), _ = T(r.length / 3, (q, k) => new Vector3().fromArray(r, k * 3).setLength(o)), x = [], C = 1e6;
      for (let q = 0; q < _.length; q++) {
        let k = _[q], R = [], D, B, L, F = 1e10, W = -1;
        for (; (W = e.indexOf(q, W + 1)) != -1; ) {
          let E = W - W % 3;
          D = e[E + (W + 1) % 3], B = e[E + (W + 2) % 3], L = k.distanceToSquared(_[D]), F = Math.min(F, L), R.push([D, B, L]);
        }
        F += 1e-6;
        let H = [], j = 0, U = R.length;
        for (let E = 0; E < U; E++) {
          [D, B, L] = R[j];
          let oe = ((_a2 = x[D]) == null ? void 0 : _a2.includes(q)) == true;
          L <= F && H.push(D + +oe * C), j = R.findIndex((Y) => Y[0] == B);
        }
        x.push(H);
      }
      let P = [];
      {
        let q = 0, k = 0, R, D, B = f == 3;
        for (let L = 0; L <= s; L++) {
          R = L * (L + 1) / 2, D = (L + 1) * (L + 2) / 2;
          for (let F = 0; F < s - L; F++)
            [q, k] = [R + F + L + 2, D + F + L + 3], P.push(R, D, ...B ? [k, R] : [q, D], k, q), [R, D] = [q, k];
          P.push(R, D, R + s + 2);
        }
      }
      let I = m.clone(), O = m.clone(), A = m.clone(), G = m.clone(), z = m.clone(), $ = [], te = T(_.length, () => T(f, () => m.clone()));
      for (let q = 0; q < _.length; q++) {
        m.copy(_[q]).normalize(), I.copy(m).multiplyScalar(v);
        let k = x[q];
        for (let H = 0; H < k.length; H++) {
          let j = k[H], U = k[(H + 1) % f];
          y.setFromPointsAndIndices(_, q, j % C, U % C), y.b.sub(y.a).setLength(1e10).add(y.a), y.c.sub(y.a).setLength(1e10).add(y.a), y.closestPointToPoint(I, te[q][H]);
        }
        let R = [], D = [], B = [], L = new Vector3();
        s == 0 && [...te[q]].reduce((H, j) => H.add(j), L).multiplyScalar(1 / f);
        for (let H = 0; H < f; H++) {
          let j = [], U = (H - 1 + f) % f, E = te[q][U], oe = te[q][H];
          m.copy(E).sub(I), h.copy(oe).sub(I);
          let Y = I.angleTo(m), re = m.angleTo(h), X = Math.cos(Y) * g;
          s == 0 ? O.copy(L) : O.copy(I).setLength(v + X), D.push(X);
          let ee = [O, E, oe];
          for (let Z = 0; Z < 2; Z++) {
            let ie = ee[Z], ce = ee[Z + 1];
            G.subVectors(ie, I), z.subVectors(ce, I), A.crossVectors(G, z).normalize();
            for (let se = 0; se < S; se++) {
              let pe = [Y, re][Z] * se / S;
              m.copy(G).applyAxisAngle(A, pe).add(I), R.push(m.clone()), Z && (b(m, I), j.push([se == 0 ? ie : m.clone(), w.clone()]));
            }
            Z && (b(ce, I), j.push([ce, w.clone()]));
          }
          B.push(j);
        }
        $.push(B);
        let F = 2 * S, W = 2;
        for (let H = 0; H < f; H++) {
          let j = F * H, U = F * ((H + 1) % f), E = [R[j]];
          for (let Y = 1; Y < S; Y++) {
            G = R[j + Y], z = R[U + Y], E.push(G);
            for (let re = 1, X = Y - W + 1; re <= X; re++)
              m.lerpVectors(G, z, re / (X + 1)), m.sub(I).setLength(D[H]).add(I), E.push(m.clone());
            E.push(z);
          }
          for (let Y = 0; Y < S; Y++)
            E.push(R[Y + S + j]);
          E.push(R[U + S]);
          let oe = P.map((Y) => E[Y]);
          l.push(...oe.map((Y) => [Y.x, Y.y, Y.z]).flat()), u.push(...oe.map((Y) => (b(Y, I), [w.x, w.y, w.z])).flat());
        }
      }
      let K = [];
      for (let q = 0; q < x.length; q++)
        for (let k = 0; k < f; k++) {
          let R = x[q][k];
          if (R < C) {
            let D = x[R].findIndex((F) => F % C == q), B = $[q][k], L = $[R][D];
            for (let F = 0; F < S; F++) {
              let W = B[F], H = L[S - F], j = B[F + 1], U = L[S - (F + 1)];
              [W, H, j, j, H, U].forEach((E) => {
                l.push(E[0].x, E[0].y, E[0].z), u.push(E[1].x, E[1].y, E[1].z);
              });
            }
            K.push(B[0][0], L[S][0], B[S][0], L[0][0]);
          }
        }
      for (; K.length; ) {
        let q, k, R, D;
        [q, k] = K.splice(0, 2);
        let B = [q];
        for (; q != k; )
          B.push(k), R = K.indexOf(k), D = R % 2, k = K.splice(R - D, 2)[1 - D];
        w.subVectors(B[0], B[1]).cross(m.subVectors(B[0], B[2])).normalize();
        let L = w.dot(B[0]) < 0;
        L && w.negate();
        for (let F = 1; F <= B.length - 2; F++)
          [B[F + +L], B[F + 1 - +L], B[0]].forEach((W) => {
            l.push(W.x, W.y, W.z), u.push(w.x, w.y, w.z);
          });
      }
    }
    function d() {
      let p = new Vector3();
      for (let _ = 0; _ < l.length; _ += 3) {
        p.x = l[_ + 0], p.y = l[_ + 1], p.z = l[_ + 2];
        let x = b(p) / 2 / Math.PI + 0.5, C = T(p) / Math.PI + 0.5;
        c.push(x, 1 - C);
      }
      let f = new Vector3(), m = new Vector3(), h = new Vector3(), y = new Vector3(), g = new Vector2(), v = new Vector2(), S = new Vector2(), w = (_, x, C, P) => {
        P < 0 && _.x === 1 && (c[x] = _.x - 1), C.x === 0 && C.z === 0 && (c[x] = P / 2 / Math.PI + 0.5);
      };
      for (let _ = 0, x = 0; _ < l.length; _ += 9, x += 6) {
        f.set(l[_ + 0], l[_ + 1], l[_ + 2]), m.set(l[_ + 3], l[_ + 4], l[_ + 5]), h.set(l[_ + 6], l[_ + 7], l[_ + 8]), g.set(c[x + 0], c[x + 1]), v.set(c[x + 2], c[x + 3]), S.set(c[x + 4], c[x + 5]), y.copy(f).add(m).add(h).divideScalar(3);
        let C = b(y);
        w(g, x + 0, f, C), w(v, x + 2, m, C), w(S, x + 4, h, C);
      }
      for (let _ = 0; _ < c.length; _ += 6) {
        let x = c[_ + 0], C = c[_ + 2], P = c[_ + 4], I = Math.max(x, C, P), O = Math.min(x, C, P);
        I > 0.9 && O < 0.1 && (x < 0.2 && (c[_ + 0] += 1), C < 0.2 && (c[_ + 2] += 1), P < 0.2 && (c[_ + 4] += 1));
      }
      function b(_) {
        return Math.atan2(_.z, -_.x);
      }
      function T(_) {
        return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
      }
    }
  }
  static fromJSON(r) {
    return new so(r.vertices, r.indices, r.radius, r.corner, r.cornerSides);
  }
};
var Rm = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, detail: o, corner: i, cornerSides: s } = n.parameters, l = o === 0 && i !== 0 ? new Fi(r * 0.5, i, s) : new DodecahedronGeometry(r * 0.5, o);
    return l.scale(1, e / r, t / r), Object.assign(l, { userData: { ...n, type: "DodecahedronGeometry" } });
  }
};
var Fi = class extends so {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, i = 1 / o, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -o, 0, -i, o, 0, i, -o, 0, i, o, -i, -o, 0, -i, o, 0, i, -o, 0, i, o, 0, -o, 0, -i, o, 0, -i, -o, 0, i, o, 0, i], l = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], c = "DodecahedronGeometry";
    super(s, l, c, r, e, t), this.type = c;
  }
  static fromJSON(r) {
    return new Fi(r.radius, r.corner, r.cornerSides);
  }
};
var zi = 1e-12;
var Bn = class {
  constructor(r) {
    this.position = new Vector2();
    this.startPosition = new Vector2();
    this.uuid = MathUtils.generateUUID();
    this.position = r.clone();
  }
  start() {
    this.reset();
  }
  reset() {
    this.startPosition.copy(this.position);
  }
  applyOffset(r) {
    this.position.copy(this.startPosition).add(r);
  }
  copy(r) {
    return this.position.copy(r.position), this.startPosition.copy(r.startPosition), this;
  }
  clone() {
    return new Bn(this.position).copy(this);
  }
  toJSON() {
    return [this.position.x, this.position.y];
  }
};
var Dn = class extends Bn {
  constructor(e) {
    super(e.position);
    this.parent = e;
  }
  copy(e) {
    return super.copy(e), this;
  }
  clone() {
    return new Dn(this.parent).copy(this);
  }
};
var Jt = class extends Bn {
  constructor(e, t) {
    super(t);
    this.controls = [];
    this.roundness = 0;
    this.areControlsDirectionsMirrored = true;
    this.uuid = e, this.controls.push(new Dn(this), new Dn(this));
  }
  static create(e, t) {
    let o = new Jt(e, new Vector2(...t.position));
    return o.controls[0].position.set(...t.controlPrevious.position), o.controls[1].position.set(...t.controlNext.position), o.roundness = t.roundness, o.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored, o;
  }
  getOppositeControl(e) {
    let t = this.controls.indexOf(e);
    return t === 0 ? this.controls[1] : t === 1 ? this.controls[0] : null;
  }
  applyOffsetToControls(e, t = 1) {
    for (let o = 0, i = this.controls.length; o < i; o++) {
      let s = this.controls[o];
      this.position.distanceTo(s.position) <= t ? s.position.copy(this.position) : s.applyOffset(e);
    }
  }
  controlsMoved() {
    return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position));
  }
  copy(e) {
    return super.copy(e), this.controls[0].copy(e.controls[0]), this.controls[1].copy(e.controls[1]), this.roundness = e.roundness, this.uuid = e.uuid, this;
  }
  clone() {
    return new Jt(this.uuid, this.position).copy(this);
  }
  toJSON() {
    return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness]);
  }
  computeTangents() {
    var _a2, _b2;
    let e = (_a2 = this.curveBefore) == null ? void 0 : _a2.getTangentAt(1), t = (_b2 = this.curveAfter) == null ? void 0 : _b2.getTangentAt(0);
    return [e, t];
  }
  computeNormals(e = new Vector2(), t = new Vector2()) {
    let [o, i] = this.computeTangents();
    return o && i && (Vm(o, e), Vm(i, t)), [e, t];
  }
  computeTangent(e = new Vector2()) {
    let [t, o] = this.computeTangents();
    return t && o && e.copy(t).add(o).normalize(), e;
  }
  computeNormal(e = new Vector2()) {
    let [t, o] = this.computeNormals();
    return e.copy(t).add(o).normalize(), e;
  }
};
function Vm(n, r = new Vector2()) {
  let e = n.length();
  return r.set(-n.y / e, n.x / e);
}
var Dc = (n) => n;
var Gn = new Vector2();
var qa = new Vector2();
var v_ = new Vector2();
var b_ = new Vector2();
var S_ = new Vector2();
var w_ = new Vector2();
var zm = new Vector3();
var Um = new Vector3();
function km(n) {
  let r = new Vector2();
  r.addVectors(n.v0, Gn.subVectors(n.v1, n.v0).multiplyScalar(2 / 3));
  let e = new Vector2();
  return e.addVectors(n.v2, qa.subVectors(n.v1, n.v2).multiplyScalar(2 / 3)), new CubicBezierCurve(n.v0, r, e, n.v2);
}
function Ui(n, r, e = Number.EPSILON) {
  return Math.abs(n - r) < e;
}
function __(n, r, e = Number.EPSILON) {
  return n.distanceTo(r) < e;
}
function T_(n, r, e = Number.EPSILON) {
  return n.distanceTo(r) < e;
}
function Gc(n, r, e) {
  let t = Math.sqrt(Math.pow(r.x - n.x, 2) + Math.pow(r.y - n.y, 2)), o = Math.sqrt(Math.pow(r.x - e.x, 2) + Math.pow(r.y - e.y, 2)), i = Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2));
  return Math.acos((o * o + t * t - i * i) / (2 * o * t));
}
function Hm(n, r, e) {
  return jm(n, r) && jm(r, e) && Lc(n.position, r.position, e.position);
}
function Lc(n, r, e) {
  return Gn.copy(r).sub(n).cross(qa.copy(e).sub(n)) === 0;
}
function Wm(n, r, e, t, o) {
  let i = Math.sqrt(Math.pow(r.x - n.x, 2) + Math.pow(r.y - n.y, 2)), s = (n.y + r.y) / 2, l = (n.x + r.x) / 2, c = Math.sqrt(Math.pow(e, 2) - Math.pow(i / 2, 2)) * (n.y - r.y) / i, u = Math.sqrt(Math.pow(e, 2) - Math.pow(i / 2, 2)) * (r.x - n.x) / i;
  return t.set(l + c, s + u), o.set(l - c, s - u), [t, o];
}
function qm(n, r, e) {
  let t = n.distanceTo(e), o = r.distanceTo(e);
  return t < o ? r : n;
}
function $m(n, r, e, t, o, i) {
  let s = r.x - n.x, l = r.y - n.y, c = e.x - n.x, u = e.y - n.y, a = Math.sqrt((s + c) * (s + c) + (l + u) * (l + u)), d;
  return Gc(r, n, e) > Math.PI && (a *= -1), Ui(u, l) ? d = (l + u) * (t / a - 0.5) * 8 / 3 / (s - c) : d = (s + c) * (t / a - 0.5) * 8 / 3 / (u - l), o.set(r.x - d * l, r.y + d * s), i.set(e.x + d * u, e.y - d * c), [o, i];
}
function Rc(n, r) {
  return n.position.equals(n.controls[1].position) && r.position.equals(r.controls[0].position);
}
function jm(n, r) {
  return Lc(n.position, n.controls[1].position, r.position) && Lc(n.position, r.controls[0].position, r.position);
}
function Ym(n, r, e, t, o = 0.5) {
  let i = Gn.subVectors(r, n).multiplyScalar(o).add(n), s = qa.subVectors(e, r).multiplyScalar(o).add(r), l = v_.subVectors(t, e).multiplyScalar(o).add(e), c = i, u = b_.subVectors(s, i).multiplyScalar(o).add(i), a = S_.subVectors(l, s).multiplyScalar(o).add(s), d = l, p = w_.subVectors(a, u).multiplyScalar(o).add(u);
  return [n.x, n.y, c.x, c.y, u.x, u.y, p.x, p.y, a.x, a.y, d.x, d.y, t.x, t.y];
}
function Xm(n, r, e = 12, t = true) {
  let o = Um.set(0, 0, 0), i, s = 0, l = [];
  for (let c = 0; c < r.length; c++) {
    let u = Dc(r[c]), a = Gn, d = ao(u, e);
    l.push(d);
    for (let p = 0; p <= d; p++)
      if (u instanceof CubicBezierCurve || u instanceof QuadraticBezierCurve || u instanceof LineCurve) {
        if (u.getPoint(p / d, a), o.set(a.x, a.y, 0), i !== void 0 && T_(i, o))
          continue;
        i === void 0 && (i = zm), i.copy(o), n.setXYZ(s, o.x, o.y, o.z), s++;
      }
  }
  return t && s > 1 && !(n.getX(s - 1) === n.getX(0) && n.getY(s - 1) === n.getY(0) && n.getZ(s - 1) === n.getZ(0)) && (n.setXYZ(s, n.getX(0), n.getY(0), n.getZ(0)), s++), n;
}
function Km(n, r, e, t = 12, o = true) {
  let i = Um.set(0, 0, 0), s = 0, l = [];
  for (let c = 0; c < r.length; c++) {
    if (e[c] === false)
      continue;
    let u, a = Dc(r[c]), d = Gn, p = ao(a, t);
    l.push(p);
    for (let f = 0; f <= p; f++)
      if (a instanceof CubicBezierCurve || a instanceof QuadraticBezierCurve || a instanceof LineCurve) {
        if (a.getPoint(f / p, d), i.set(d.x, d.y, 0), u == null ? void 0 : u.equals(i))
          continue;
        u === void 0 ? u = zm : (n.setXYZ(s, u.x, u.y, u.z), s++, n.setXYZ(s, i.x, i.y, i.z), s++), u.copy(i);
      }
  }
  return o && s > 1 && !(n.getX(s - 1) === n.getX(0) && n.getY(s - 1) === n.getY(0) && n.getZ(s - 1) === n.getZ(0)) && (n.setXYZ(s, n.getX(0), n.getY(0), n.getZ(0)), s++), l;
}
function Vc(n, r = 12, e = false) {
  let t = [];
  for (let o = 0, i = n.length; o < i; o++) {
    let s = n[o], l = 0;
    if (e && s.roundedCurveCorner !== void 0) {
      let c = ao(s.roundedCurveCorner, r) * 0.5;
      o > 0 && (t[o - 1] += c), l += c;
    }
    s.curveAfter !== void 0 && (l += ao(s.curveAfter, r)), t.push(l);
  }
  return n.length > 0 && e && n[0].roundedCurveCorner !== void 0 && (t[n.length - 1] += ao(n[0].roundedCurveCorner, r) * 0.5), t;
}
function ao(n, r = 12) {
  return n && n instanceof EllipseCurve ? r * 2 : n && (n instanceof LineCurve || n instanceof LineCurve3) ? 1 : n && n instanceof SplineCurve ? r * n.points.length : r;
}
function Zm(n, r, e = 12, t = true) {
  let o, i = 0;
  for (let s = 0; s < r.length; s++) {
    let l = Dc(r[s]), c = ao(l, e), u = Gn;
    for (let a = 0; a <= c; a++)
      if (l instanceof CubicBezierCurve || l instanceof QuadraticBezierCurve || l instanceof LineCurve) {
        if (l.getPoint(a / c, u), o !== void 0 && __(o, u, zi))
          continue;
        o === void 0 && (o = qa), o.copy(u), n.push(u.x, u.y), i++;
      }
  }
  return Ui(n[0], n[n.length - 2], zi) && Ui(n[1], n[n.length - 1], zi) && (n.pop(), n.pop()), t && i > 1 && !(Ui(n[i - 1], n[1], zi) && Ui(n[i - 2], n[0], zi)) && (n.push(n[0], n[1]), i++), n;
}
var zc = new Vector2();
var A_ = new Vector2();
var I_ = new Vector2();
var C_ = new Vector2();
var N_ = new Vector2();
var E_ = new Vector2();
var Se = class extends Shape {
  constructor(e = 100, t = 100) {
    super();
    this.points = [];
    this.shapeHoles = [];
    this.plane = new Plane(new Vector3(0, 0, -1));
    this.subdivision = 0;
    this.controlSnapDistance = 4;
    this.pointIDs = 0;
    this.isMesh2D = false;
    this._roundness = 0;
    this.isClosed = false;
    this.useCubicForRoundedCorners = true;
    this.uuid = MathUtils.generateUUID();
    this.needsUpdate = false;
    this.roundedCurves = [];
    this._width = e, this._height = t;
  }
  static createFromState(e, t, o) {
    let i = new Se();
    return i.isClosed = e.isClosed, i.points = e.points.map((s) => Jt.create(s.id, s.data)), typeof e.roundness == "number" && (i.roundness = e.roundness), i.shapeHoles = e.shapeHoles.map((s) => Se.createFromState(s)), t !== void 0 && o !== void 0 && i.applySize(t, o), i.update(), i;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get roundness() {
    return this._roundness;
  }
  set roundness(e) {
    if (this._roundness !== e) {
      this._roundness = e;
      for (let t = 0, o = this.points.length; t < o; t++)
        this.points[t].roundness = e;
      this.needsUpdate = true;
    }
  }
  getPointsIndexesByIds(e) {
    return e.map((t) => this.getPointIndexById(t)).filter((t) => t >= 0);
  }
  getPointIndexById(e) {
    let t = this.points.length, o = this.points.findIndex((i) => i.uuid === e);
    if (o < 0) {
      let i = t;
      for (let s = 0, l = this.shapeHoles.length; s < l; s++) {
        let c = this.shapeHoles[s], u = c.points.length, a = c.getPointIndexById(e);
        if (a < 0)
          i += u;
        else
          return a + i;
      }
    }
    return o;
  }
  getLineIndexById(e) {
    return this.getPointIndexById(e);
  }
  getBezierPoint(e) {
    if (e <= this.points.length - 1)
      return this.points[e];
    if (this.shapeHoles.length > 0) {
      let t = this.points.length;
      for (let o = 0, i = this.shapeHoles.length; o < i; o++) {
        let s = this.shapeHoles[o], l = e - t;
        if (l <= s.points.length - 1)
          return s.points[l];
        t += s.points.length;
      }
    }
    throw new Error("This shape does not have a point for this index: " + e);
  }
  getBezierPointIndex(e) {
    let t = this.points.indexOf(e);
    if (t >= 0)
      return t;
    if (t = this.points.length, this.shapeHoles.length > 0)
      for (let o = 0, i = this.shapeHoles.length; o < i; o++) {
        let s = this.shapeHoles[o], l = s.points.indexOf(e);
        if (l >= 0)
          return t + l;
        t += s.points.length;
      }
    return -1;
  }
  getAllPoints() {
    let e = [].concat(...this.shapeHoles.map((t) => t.points));
    return [...this.points, ...e];
  }
  applySize(e, t) {
    e === 0 && (e = 1e-3), t === 0 && (t = 1e-3), this._width = e, this._height = t;
  }
  applyScale(e, t) {
    let o = zc.set(e, t);
    for (let i = 0, s = this.points.length; i < s; i++) {
      let l = this.points[i];
      l.position.multiply(o), l.controls[0].position.multiply(o), l.controls[1].position.multiply(o);
    }
    for (let i = 0, s = this.shapeHoles.length; i < s; i++)
      this.shapeHoles[i].applyScale(e, t);
    this._update();
  }
  createPoint(e, t = 0, o = MathUtils.generateUUID()) {
    let i;
    e instanceof Vector2 ? i = e : i = new Vector2(e, t);
    let s = new Jt(o, i);
    return s.roundness = this.roundness, s;
  }
  addPoint(e) {
    this.points.push(e), this.needsUpdate = true;
  }
  addPointAt(e, t) {
    this.points.splice(t, 0, e), this.needsUpdate = true;
  }
  getPointByUuid(e) {
    for (let t = 0, o = this.points.length; t < o; t++) {
      let i = this.points[t];
      if (i.uuid === e)
        return i;
    }
    for (let t = 0, o = this.shapeHoles.length; t < o; t++) {
      let s = this.shapeHoles[t].getPointByUuid(e);
      if (s)
        return s;
    }
  }
  getFirstPoint() {
    return this.points[0];
  }
  getLastPoint() {
    return this.points[this.points.length - 1];
  }
  removePoint(e) {
    let t = this.points.indexOf(e);
    t >= 0 && this.points.splice(t, 1), this.needsUpdate = true;
  }
  removePointById(e) {
    let t = this.points.find((o) => o.uuid === e);
    t && this.removePoint(t);
  }
  update() {
    for (let e = 0, t = this.shapeHoles.length; e < t; e++)
      this.shapeHoles[e].update();
    this._update();
  }
  extractShapePointsToBuffer(e, t = 12, o = false) {
    this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t);
    let i = o ? this.roundedCurveDivisions : this.curveDivisions;
    return Xm(e, o ? this.roundedCurves : this.curves, t, this.autoClose), i.reduce((s, l) => s + l, 0) + 1;
  }
  computeCurveDivisions(e = 12) {
    return this.curveDivisions = Vc(this.points, e, false), this.roundedCurveDivisions = Vc(this.points, e, true), this.curveDivisions;
  }
  extractFilteredShapePointsToBuffer(e, t, o = 12) {
    return Km(e, this.curves, t, o, this.autoClose).reduce((s, l) => s + l, 0) * 2;
  }
  extractShapePointsToFlatArray(e, t = 12) {
    return this.subdivision = t, this.curveDivisions === void 0 && this.computeCurveDivisions(t), Zm(e, this.roundedCurves, t, this.autoClose);
  }
  getCurveIndexFromVertexId(e, t = false) {
    let o = 0;
    this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision);
    let i = t ? this.roundedCurveDivisions : this.curveDivisions, s = 0;
    t && this.points[0].roundedCurveCorner !== void 0 && (s = ao(this.points[0].roundedCurveCorner, this.subdivision) * 0.5);
    let l = e - s;
    l < 0 && (l += i.reduce((c, u) => c + u, 0));
    for (let c = 0, u = i.length; c < u; c++) {
      let a = i[c];
      if (l < o + a)
        return [c, (l - o + 1) / a];
      o += a;
    }
    return [0, 1];
  }
  getCurveT(e, t, o) {
    let i = this.points[e], s = this.points[e >= this.points.length - 1 ? 0 : e + 1], l = this.curveDivisions, c = l[e];
    if (Rc(i, s)) {
      let d = i.position.distanceTo(s.position);
      return i.position.distanceTo(zc.set(o.x, o.y)) / d;
    }
    let u = 0;
    for (let d = 0; d < e; d++)
      u += l[d];
    return (t - u) / c;
  }
  dispose() {
  }
  _applyCurveForPoint(e, t) {
    Rc(t, e) ? this.lineTo(e.position.x, e.position.y) : this.bezierCurveTo(t.controls[1].position.x, t.controls[1].position.y, e.controls[0].position.x, e.controls[0].position.y, e.position.x, e.position.y);
    let o = this.curves[this.curves.length - 1];
    e.curveBefore = o, t.curveAfter = o;
    let i = o.clone();
    e.roundedCurveBefore = i, t.roundedCurveAfter = i, e.roundedCurveCorner = void 0, this.roundedCurves.push(i);
  }
  _update() {
    if (this.curves = [], this.roundedCurves = [], !this.points.length)
      return;
    for (let t = 0, o = this.points.length; t < o; t++) {
      let i = this.points[t];
      if (t === 0)
        this.moveTo(i.position.x, i.position.y);
      else {
        let s = this.points[t - 1];
        this._applyCurveForPoint(i, s);
      }
    }
    let e = this.getLastPoint();
    if ((e == null ? void 0 : e.curveAfter) && (e.curveAfter = void 0), this.isClosed) {
      let t = this.points[0], o = this.points[this.points.length - 1];
      this._applyCurveForPoint(t, o);
    }
    if (this.points.length > 2) {
      let t = 0;
      for (let o = 0, i = this.points.length; o < i; o++) {
        let s = this.points[o], l = this.points[o - 1] ?? this.points[this.points.length - 1], c = this.points[o + 1] ?? this.points[0], u = s.roundness, a = l && c && Hm(l, s, c);
        if (!s.controlsMoved() && u > 0 && !a) {
          let d = s.curveBefore, p = s.curveAfter;
          if (d === void 0 || p === void 0)
            continue;
          let f = s.roundedCurveBefore, m = s.roundedCurveAfter, h = d.getLength(), y = p.getLength(), g = Math.min(u, h * 0.499), v = Math.min(u, y * 0.499), S = Math.min(g, v), w = 1 - S / h, b = S / y, T = d.getPointAt(w, zc), _ = p.getPointAt(b, A_);
          this._subSplitCurve(d, f, w, T, void 0), this._subSplitCurve(p, m, b, void 0, _);
          let x;
          if (this.useCubicForRoundedCorners) {
            let C = Gc(T, s.position, _) / 2, P = Math.tan(C) * T.distanceTo(s.position), [I, O] = Wm(T, _, P, I_, C_), A = qm(I, O, s.position), [G, z] = $m(A, T, _, P, N_, E_);
            x = new CubicBezierCurve(T.clone(), G.clone(), z.clone(), _.clone());
          } else
            x = new QuadraticBezierCurve(T.clone(), s.position.clone(), _.clone());
          s.roundedCurveCorner = x, this.roundedCurves.splice(o + t, 0, x), t++;
        }
      }
    }
  }
  _subSplitCurve(e, t, o, i, s) {
    if (e instanceof LineCurve)
      i !== void 0 && t.v2.copy(i), s !== void 0 && t.v1.copy(s);
    else {
      let l = e, c = t, u = l.getUtoTmapping(o, 0), a = Ym(l.v0, l.v1, l.v2, l.v3, u);
      return i !== void 0 && (c.v0.set(a[0], a[1]), c.v1.set(a[2], a[3]), c.v2.set(a[4], a[5]), c.v3.set(a[6], a[7])), s !== void 0 && (c.v0.set(a[6], a[7]), c.v1.set(a[8], a[9]), c.v2.set(a[10], a[11]), c.v3.set(a[12], a[13])), c;
    }
    return t;
  }
  clone() {
    let e = new Se(this._width, this._height);
    return e.points = this.points.map((t) => t.clone()), e.isClosed = this.isClosed, e.roundness = this.roundness, e.isMesh2D = this.isMesh2D, e.shapeHoles = this.shapeHoles.map((t) => t.clone()), e;
  }
  toJSON() {
    return { points: this.points.reduce((e, t) => e.concat(t.toJSON()), []), shapeHoles: this.shapeHoles.map((e) => e.toJSON()), isClosed: this.isClosed, roundness: this.roundness };
  }
  fromJSON(e) {
    var _a2;
    this.points = [], this.pointIDs = 0;
    let t = e.points.length / 7;
    for (let o = 0; o < t; o++) {
      let i = o * 7, s = e.points[i + 0], l = e.points[i + 1], c = e.points[i + 2], u = e.points[i + 3], a = e.points[i + 4], d = e.points[i + 5], p = e.points[i + 6], f = new Jt(MathUtils.generateUUID(), new Vector2(s, l));
      f.controls[0].position.set(c, u), f.controls[1].position.set(a, d), f.roundness = p, this.points.push(f);
    }
    return this.shapeHoles = ((_a2 = e.shapeHoles) == null ? void 0 : _a2.length) ? e.shapeHoles.map((o) => {
      let i = new Se();
      return i.fromJSON(o), i;
    }) : [], this.isClosed = e.isClosed, this._roundness = e.roundness, this._update(), this;
  }
  fromShape(e) {
    let t = (i, s) => {
      s instanceof CubicBezierCurve && s.v3.equals(i.position) && i.controls[0].position.copy(s.v2);
    }, o = (i) => {
      let s = [], l, c;
      for (l = 0, c = i.length; l < c; l++)
        i[l] instanceof QuadraticBezierCurve && (i[l] = km(i[l]));
      for (l = 0, c = i.length; l < c; l++) {
        let d = i[l], p = l > 0 ? i[l - 1] : null, f;
        d instanceof CubicBezierCurve ? (f = this.createPoint(d.v0), f.controls[1].position.copy(d.v1)) : d instanceof LineCurve && (f = this.createPoint(d.v1)), f !== void 0 && (p !== null && t(f, p), s.push(f));
      }
      let u = i[i.length - 1], a = false;
      return u instanceof CubicBezierCurve ? u.v3.equals(s[0].position) && (s[0].controls[0].position.copy(u.v2), a = true) : u instanceof LineCurve && u.v2.equals(s[0].position) && (a = true), this.isClosed = a, s;
    };
    return this.points = o(e.curves), e instanceof Shape && (this.shapeHoles = e.holes.map((i) => {
      let s = new Se();
      return s.fromShape(i), s;
    })), this.update(), this;
  }
  updatePoint(e, t) {
    let o = this.getPointByUuid(e);
    o && (t.position !== void 0 && o.position.fromArray(t.position), t.roundness !== void 0 && (o.roundness = t.roundness), t.areControlsDirectionsMirrored !== void 0 && (o.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored), this.needsUpdate = true);
  }
  updatePreviousControl(e, t) {
    var _a2;
    let i = (_a2 = this.getPointByUuid(e)) == null ? void 0 : _a2.controls[0];
    i && (t.position && i.position.fromArray(t.position), this.needsUpdate = true);
  }
  updateNextControl(e, t) {
    var _a2;
    let i = (_a2 = this.getPointByUuid(e)) == null ? void 0 : _a2.controls[1];
    i && (t.position && i.position.fromArray(t.position), this.needsUpdate = true);
  }
};
var kc = Math.PI * 2;
function Uc({ x: n, y: r }, e, t, o, i) {
  return { x: n * e + o, y: r * t + i };
}
function M_(n, r) {
  let e = r === 1.5707963267948966 ? 0.551915024494 : r === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(r / 4), t = Math.cos(n), o = Math.sin(n), i = Math.cos(n + r), s = Math.sin(n + r);
  return [{ x: t - o * e, y: o + t * e }, { x: i + s * e, y: s - i * e }, { x: i, y: s }];
}
function eh(n, r, e, t) {
  let o = n * t - r * e < 0 ? -1 : 1, i = Math.min(1, Math.max(-1, n * e + r * t));
  return o * Math.acos(i);
}
function L_(n, r, e, t, o, i, s, l, c, u) {
  let a = Math.pow(o, 2), d = Math.pow(i, 2), p = Math.pow(s, 2), f = Math.pow(l, 2), m = a * d - a * f - d * p;
  m < 0 && (m = 0), m /= a * f + d * p, m = Math.sqrt(m) * (c === u ? -1 : 1);
  let h = m * o / i * l, y = m * -i / o * s, g = h + (n + e) / 2, v = y + (r + t) / 2, S = (s - h) / o, w = (l - y) / i, b = (-s - h) / o, T = (-l - y) / i, _ = eh(1, 0, S, w), x = eh(S, w, b, T);
  return !u && x > 0 && (x -= kc), u && x < 0 && (x += kc), { centerx: g, centery: v, ang1: _, ang2: x };
}
function th({ px: n, py: r, cx: e, cy: t, rx: o, ry: i, largeArcFlag: s, sweepFlag: l }) {
  let c = [];
  if (o === 0 || i === 0)
    return [];
  let u = (n - e) / 2, a = (r - t) / 2;
  if (u === 0 && a === 0)
    return [];
  o = Math.abs(o), i = Math.abs(i);
  let d = Math.pow(u, 2) / Math.pow(o, 2) + Math.pow(a, 2) / Math.pow(i, 2);
  d > 1 && (o *= Math.sqrt(d), i *= Math.sqrt(d));
  let p = L_(n, r, e, t, o, i, u, a, s, l), { ang1: f, ang2: m } = p, { centerx: h, centery: y } = p, g = Math.abs(m) / (kc / 4);
  Math.abs(1 - g) < 1e-7 && (g = 1);
  let v = Math.max(Math.ceil(g), 1);
  m /= v;
  for (let S = 0; S < v; S++)
    c.push(M_(f, m)), f += m;
  return c.map((S) => {
    let { x: w, y: b } = Uc(S[0], o, i, h, y), { x: T, y: _ } = Uc(S[1], o, i, h, y), { x, y: C } = Uc(S[2], o, i, h, y);
    return { x1: w, y1: b, x2: T, y2: _, x, y: C };
  });
}
var ve;
(function(n) {
  n[n.ODD = 0] = "ODD", n[n.NONZERO = 1] = "NONZERO", n[n.POSITIVE = 2] = "POSITIVE", n[n.NEGATIVE = 3] = "NEGATIVE", n[n.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO";
})(ve || (ve = {}));
var De;
(function(n) {
  n[n.POLYGONS = 0] = "POLYGONS", n[n.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", n[n.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
})(De || (De = {}));
function ue(n, r) {
  if (!n)
    throw r || "Assertion Failed!";
}
var ae = function() {
  function n() {
  }
  return n.vertEq = function(r, e) {
    return r.s === e.s && r.t === e.t;
  }, n.vertLeq = function(r, e) {
    return r.s < e.s || r.s === e.s && r.t <= e.t;
  }, n.transLeq = function(r, e) {
    return r.t < e.t || r.t === e.t && r.s <= e.s;
  }, n.edgeGoesLeft = function(r) {
    return n.vertLeq(r.Dst, r.Org);
  }, n.edgeGoesRight = function(r) {
    return n.vertLeq(r.Org, r.Dst);
  }, n.vertL1dist = function(r, e) {
    return Math.abs(r.s - e.s) + Math.abs(r.t - e.t);
  }, n.edgeEval = function(r, e, t) {
    ue(n.vertLeq(r, e) && n.vertLeq(e, t));
    var o = e.s - r.s, i = t.s - e.s;
    return o + i > 0 ? o < i ? e.t - r.t + (r.t - t.t) * (o / (o + i)) : e.t - t.t + (t.t - r.t) * (i / (o + i)) : 0;
  }, n.edgeSign = function(r, e, t) {
    ue(n.vertLeq(r, e) && n.vertLeq(e, t));
    var o = e.s - r.s, i = t.s - e.s;
    return o + i > 0 ? (e.t - t.t) * o + (e.t - r.t) * i : 0;
  }, n.transEval = function(r, e, t) {
    ue(n.transLeq(r, e) && n.transLeq(e, t));
    var o = e.t - r.t, i = t.t - e.t;
    return o + i > 0 ? o < i ? e.s - r.s + (r.s - t.s) * (o / (o + i)) : e.s - t.s + (t.s - r.s) * (i / (o + i)) : 0;
  }, n.transSign = function(r, e, t) {
    ue(n.transLeq(r, e) && n.transLeq(e, t));
    var o = e.t - r.t, i = t.t - e.t;
    return o + i > 0 ? (e.s - t.s) * o + (e.s - r.s) * i : 0;
  }, n.vertCCW = function(r, e, t) {
    return r.s * (e.t - t.t) + e.s * (t.t - r.t) + t.s * (r.t - e.t) >= 0;
  }, n.interpolate = function(r, e, t, o) {
    return r = r < 0 ? 0 : r, t = t < 0 ? 0 : t, r <= t ? t === 0 ? (e + o) / 2 : e + (o - e) * (r / (r + t)) : o + (e - o) * (t / (r + t));
  }, n.intersect = function(r, e, t, o, i) {
    var s, l, c;
    n.vertLeq(r, e) || (c = r, r = e, e = c), n.vertLeq(t, o) || (c = t, t = o, o = c), n.vertLeq(r, t) || (c = r, r = t, t = c, c = e, e = o, o = c), n.vertLeq(t, e) ? n.vertLeq(e, o) ? (s = n.edgeEval(r, t, e), l = n.edgeEval(t, e, o), s + l < 0 && (s = -s, l = -l), i.s = n.interpolate(s, t.s, l, e.s)) : (s = n.edgeSign(r, t, e), l = -n.edgeSign(r, o, e), s + l < 0 && (s = -s, l = -l), i.s = n.interpolate(s, t.s, l, o.s)) : i.s = (t.s + e.s) / 2, n.transLeq(r, e) || (c = r, r = e, e = c), n.transLeq(t, o) || (c = t, t = o, o = c), n.transLeq(r, t) || (c = r, r = t, t = c, c = e, e = o, o = c), n.transLeq(t, e) ? n.transLeq(e, o) ? (s = n.transEval(r, t, e), l = n.transEval(t, e, o), s + l < 0 && (s = -s, l = -l), i.t = n.interpolate(s, t.t, l, e.t)) : (s = n.transSign(r, t, e), l = -n.transSign(r, o, e), s + l < 0 && (s = -s, l = -l), i.t = n.interpolate(s, t.t, l, o.t)) : i.t = (t.t + e.t) / 2;
  }, n;
}();
var ki = function() {
  function n() {
    this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = false, this.inside = false;
  }
  return n;
}();
var Ya = function() {
  function n(r) {
    this.side = r, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0;
  }
  return Object.defineProperty(n.prototype, "Rface", { get: function() {
    return this.Sym.Lface;
  }, set: function(r) {
    this.Sym.Lface = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dst", { get: function() {
    return this.Sym.Org;
  }, set: function(r) {
    this.Sym.Org = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Oprev", { get: function() {
    return this.Sym.Lnext;
  }, set: function(r) {
    this.Sym.Lnext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Lprev", { get: function() {
    return this.Onext.Sym;
  }, set: function(r) {
    this.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dprev", { get: function() {
    return this.Lnext.Sym;
  }, set: function(r) {
    this.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Rprev", { get: function() {
    return this.Sym.Onext;
  }, set: function(r) {
    this.Sym.Onext = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Dnext", { get: function() {
    return this.Sym.Onext.Sym;
  }, set: function(r) {
    this.Sym.Onext.Sym = r;
  }, enumerable: true, configurable: true }), Object.defineProperty(n.prototype, "Rnext", { get: function() {
    return this.Sym.Lnext.Sym;
  }, set: function(r) {
    this.Sym.Lnext.Sym = r;
  }, enumerable: true, configurable: true }), n;
}();
var Rn = function() {
  function n() {
    this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
  }
  return n;
}();
var rh = function() {
  function n() {
    var r = new Rn(), e = new ki(), t = new Ya(0), o = new Ya(1);
    r.next = r.prev = r, r.anEdge = null, e.next = e.prev = e, t.next = t, t.Sym = o, o.next = o, o.Sym = t, this.vHead = r, this.fHead = e, this.eHead = t, this.eHeadSym = o;
  }
  return n.prototype.makeEdge_ = function(r) {
    var e = new Ya(0), t = new Ya(1);
    r.Sym.side < r.side && (r = r.Sym);
    var o = r.Sym.next;
    return t.next = o, o.Sym.next = e, e.next = r, r.Sym.next = t, e.Sym = t, e.Onext = e, e.Lnext = t, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, t.Sym = e, t.Onext = t, t.Lnext = e, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, e;
  }, n.prototype.splice_ = function(r, e) {
    var t = r.Onext, o = e.Onext;
    t.Sym.Lnext = e, o.Sym.Lnext = r, r.Onext = o, e.Onext = t;
  }, n.prototype.makeVertex_ = function(r, e, t) {
    var o = r;
    ue(o, "Vertex can't be null!");
    var i = t.prev;
    o.prev = i, i.next = o, o.next = t, t.prev = o, o.anEdge = e;
    var s = e;
    do
      s.Org = o, s = s.Onext;
    while (s !== e);
  }, n.prototype.makeFace_ = function(r, e, t) {
    var o = r;
    ue(o, "Face can't be null");
    var i = t.prev;
    o.prev = i, i.next = o, o.next = t, t.prev = o, o.anEdge = e, o.trail = null, o.marked = false, o.inside = t.inside;
    var s = e;
    do
      s.Lface = o, s = s.Lnext;
    while (s !== e);
  }, n.prototype.killEdge_ = function(r) {
    r.Sym.side < r.side && (r = r.Sym);
    var e = r.next, t = r.Sym.next;
    e.Sym.next = t, t.Sym.next = e;
  }, n.prototype.killVertex_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Org = e, o = o.Onext;
    while (o !== t);
    var i = r.prev, s = r.next;
    s.prev = i, i.next = s;
  }, n.prototype.killFace_ = function(r, e) {
    var t = r.anEdge, o = t;
    do
      o.Lface = e, o = o.Lnext;
    while (o !== t);
    var i = r.prev, s = r.next;
    s.prev = i, i.next = s;
  }, n.prototype.makeEdge = function() {
    var r = new Rn(), e = new Rn(), t = new ki(), o = this.makeEdge_(this.eHead);
    return this.makeVertex_(r, o, this.vHead), this.makeVertex_(e, o.Sym, this.vHead), this.makeFace_(t, o, this.fHead), o;
  }, n.prototype.splice = function(r, e) {
    var t = false, o = false;
    if (r !== e) {
      if (e.Org !== r.Org && (o = true, this.killVertex_(e.Org, r.Org)), e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(e, r), !o) {
        var i = new Rn();
        this.makeVertex_(i, e, r.Org), r.Org.anEdge = r;
      }
      if (!t) {
        var s = new ki();
        this.makeFace_(s, e, r.Lface), r.Lface.anEdge = r;
      }
    }
  }, n.prototype.delete = function(r) {
    var e = r.Sym, t = false;
    if (r.Lface !== r.Rface && (t = true, this.killFace_(r.Lface, r.Rface)), r.Onext === r)
      this.killVertex_(r.Org, null);
    else if (r.Rface.anEdge = r.Oprev, r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev), !t) {
      var o = new ki();
      this.makeFace_(o, r, r.Lface);
    }
    e.Onext === e ? (this.killVertex_(e.Org, null), this.killFace_(e.Lface, null)) : (r.Lface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), this.killEdge_(r);
  }, n.prototype.addEdgeVertex = function(r) {
    var e = this.makeEdge_(r), t = e.Sym;
    this.splice_(e, r.Lnext), e.Org = r.Dst;
    var o = new Rn();
    return this.makeVertex_(o, t, e.Org), e.Lface = t.Lface = r.Lface, e;
  }, n.prototype.splitEdge = function(r) {
    var e = this.addEdgeVertex(r), t = e.Sym;
    return this.splice_(r.Sym, r.Sym.Oprev), this.splice_(r.Sym, t), r.Dst = t.Org, t.Dst.anEdge = t.Sym, t.Rface = r.Rface, t.winding = r.winding, t.Sym.winding = r.Sym.winding, t.idx = r.idx, t.Sym.idx = r.Sym.idx, t;
  }, n.prototype.connect = function(r, e) {
    var t = false, o = this.makeEdge_(r), i = o.Sym;
    if (e.Lface !== r.Lface && (t = true, this.killFace_(e.Lface, r.Lface)), this.splice_(o, r.Lnext), this.splice_(i, e), o.Org = r.Dst, i.Org = e.Org, o.Lface = i.Lface = r.Lface, r.Lface.anEdge = i, !t) {
      var s = new ki();
      this.makeFace_(s, o, r.Lface);
    }
    return o;
  }, n.prototype.zapFace = function(r) {
    var e = r.anEdge, t, o, i, s, l;
    o = e.Lnext;
    do
      t = o, o = t.Lnext, t.Lface = null, t.Rface === null && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), i = t.Sym, i.Onext === i ? this.killVertex_(i.Org, null) : (i.Org.anEdge = i.Onext, this.splice_(i, i.Oprev)), this.killEdge_(t));
    while (t != e);
    s = r.prev, l = r.next, l.prev = s, s.next = l;
  }, n.prototype.countFaceVerts_ = function(r) {
    var e = r.anEdge, t = 0;
    do
      t++, e = e.Lnext;
    while (e !== r.anEdge);
    return t;
  }, n.prototype.mergeConvexFaces = function(r) {
    var e, t, o, i, s, l, c;
    for (e = this.fHead.next; e !== this.fHead; e = e.next)
      if (!!e.inside)
        for (t = e.anEdge, s = t.Org; o = t.Lnext, i = t.Sym, i && i.Lface && i.Lface.inside && (l = this.countFaceVerts_(e), c = this.countFaceVerts_(i.Lface), l + c - 2 <= r && ae.vertCCW(t.Lprev.Org, t.Org, i.Lnext.Lnext.Org) && ae.vertCCW(i.Lprev.Org, i.Org, t.Lnext.Lnext.Org) && (o = i.Lnext, this.delete(i), t = null, i = null)), !(t && t.Lnext.Org === s); )
          t = o;
    return true;
  }, n.prototype.check = function() {
    var r = this.fHead, e = this.vHead, t = this.eHead, o, i, s, l, c, u;
    for (i = r, i = r; (o = i.next) !== r; i = o) {
      ue(o.prev === i), c = o.anEdge;
      do
        ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c), ue(c.Lface === o), c = c.Lnext;
      while (c !== o.anEdge);
    }
    for (ue(o.prev === i && o.anEdge === null), l = e, l = e; (s = l.next) !== e; l = s) {
      ue(s.prev === l), c = s.anEdge;
      do
        ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c), ue(c.Org === s), c = c.Onext;
      while (c !== s.anEdge);
    }
    for (ue(s.prev === l && s.anEdge === null), u = t, u = t; (c = u.next) !== t; u = c)
      ue(c.Sym.next === u.Sym), ue(c.Sym !== c), ue(c.Sym.Sym === c), ue(c.Org !== null), ue(c.Dst !== null), ue(c.Lnext.Onext.Sym === c), ue(c.Onext.Sym.Lnext === c);
    ue(c.Sym.next === u.Sym && c.Sym === this.eHeadSym && c.Sym.Sym === c && c.Org === null && c.Dst === null && c.Lface === null && c.Rface === null);
  }, n;
}();
var oh = function() {
  function n() {
    this.handle = null;
  }
  return n;
}();
var nh = function() {
  function n() {
    this.key = null, this.node = 0;
  }
  return n;
}();
var B_ = function() {
  function n(r, e) {
    this.leq = e, this.max = 0, this.nodes = [], this.handles = [], this.initialized = false, this.freeList = 0, this.size = 0, this.max = r, this.nodes = [], this.handles = [];
    for (var t = 0; t < r + 1; t++)
      this.nodes[t] = new oh(), this.handles[t] = new nh();
    this.initialized = false, this.nodes[1].handle = 1, this.handles[1].key = null;
  }
  return n.prototype.floatDown_ = function(r) {
    var e = this.nodes, t = this.handles, o, i, s;
    for (o = e[r].handle; ; ) {
      if (s = r << 1, s < this.size && this.leq(t[e[s + 1].handle].key, t[e[s].handle].key) && ++s, ue(s <= this.max), i = e[s].handle, s > this.size || this.leq(t[o].key, t[i].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = i, t[i].node = r, r = s;
    }
  }, n.prototype.floatUp_ = function(r) {
    var e = this.nodes, t = this.handles, o, i, s;
    for (o = e[r].handle; ; ) {
      if (s = r >> 1, i = e[s].handle, s === 0 || this.leq(t[i].key, t[o].key)) {
        e[r].handle = o, t[o].node = r;
        break;
      }
      e[r].handle = i, t[i].node = r, r = s;
    }
  }, n.prototype.init = function() {
    for (var r = this.size; r >= 1; --r)
      this.floatDown_(r);
    this.initialized = true;
  }, n.prototype.min = function() {
    return this.handles[this.nodes[1].handle].key;
  }, n.prototype.insert = function(r) {
    var e, t;
    if (e = ++this.size, e * 2 > this.max) {
      this.max *= 2;
      var o, i;
      for (i = this.nodes.length, this.nodes.length = this.max + 1, o = i; o < this.nodes.length; o++)
        this.nodes[o] = new oh();
      for (i = this.handles.length, this.handles.length = this.max + 1, o = i; o < this.handles.length; o++)
        this.handles[o] = new nh();
    }
    return this.freeList === 0 ? t = e : (t = this.freeList, this.freeList = this.handles[t].node), this.nodes[e].handle = t, this.handles[t].node = e, this.handles[t].key = r, this.initialized && this.floatUp_(e), t;
  }, n.prototype.extractMin = function() {
    var r = this.nodes, e = this.handles, t = r[1].handle, o = e[t].key;
    return this.size > 0 && (r[1].handle = r[this.size].handle, e[r[1].handle].node = 1, e[t].key = null, e[t].node = this.freeList, this.freeList = t, --this.size, this.size > 0 && this.floatDown_(1)), o;
  }, n.prototype.delete = function(r) {
    var e = this.nodes, t = this.handles, o;
    ue(r >= 1 && r <= this.max && t[r].key !== null), o = t[r].node, e[o].handle = e[this.size].handle, t[e[o].handle].node = o, --this.size, o <= this.size && (o <= 1 || this.leq(t[e[o >> 1].handle].key, t[e[o].handle].key) ? this.floatDown_(o) : this.floatUp_(o)), t[r].key = null, t[r].node = this.freeList, this.freeList = r;
  }, n;
}();
var Hc = function() {
  function n() {
    this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = false, this.sentinel = false, this.dirty = false, this.fixUpperEdge = false;
  }
  return n;
}();
var ih = function() {
  function n() {
    this.key = null, this.next = null, this.prev = null;
  }
  return n;
}();
var D_ = function() {
  function n(r, e) {
    this.frame = r, this.leq = e, this.head = new ih(), this.head.next = this.head, this.head.prev = this.head;
  }
  return n.prototype.min = function() {
    return this.head.next;
  }, n.prototype.max = function() {
    return this.head.prev;
  }, n.prototype.insert = function(r) {
    return this.insertBefore(this.head, r);
  }, n.prototype.search = function(r) {
    var e = this.head;
    do
      e = e.next;
    while (e.key !== null && !this.leq(this.frame, r, e.key));
    return e;
  }, n.prototype.insertBefore = function(r, e) {
    do
      r = r.prev;
    while (r.key !== null && !this.leq(this.frame, r.key, e));
    var t = new ih();
    return t.key = e, t.next = r.next, r.next.prev = t, t.prev = r, r.next = t, t;
  }, n.prototype.delete = function(r) {
    r.next.prev = r.prev, r.prev.next = r.next;
  }, n;
}();
var G_ = function() {
  function n() {
  }
  return n.regionBelow = function(r) {
    return r.nodeUp.prev.key;
  }, n.regionAbove = function(r) {
    return r.nodeUp.next.key;
  }, n.debugEvent = function(r) {
  }, n.addWinding = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, n.edgeLeq = function(r, e, t) {
    var o = r.event, i = e.eUp, s = t.eUp;
    if (i.Dst === o)
      return s.Dst === o ? ae.vertLeq(i.Org, s.Org) ? ae.edgeSign(s.Dst, i.Org, s.Org) <= 0 : ae.edgeSign(i.Dst, s.Org, i.Org) >= 0 : ae.edgeSign(s.Dst, o, s.Org) <= 0;
    if (s.Dst === o)
      return ae.edgeSign(i.Dst, o, i.Org) >= 0;
    var l = ae.edgeEval(i.Dst, o, i.Org), c = ae.edgeEval(s.Dst, o, s.Org);
    return l >= c;
  }, n.deleteRegion = function(r, e) {
    e.fixUpperEdge && ue(e.eUp.winding === 0), e.eUp.activeRegion = null, r.dict.delete(e.nodeUp);
  }, n.fixUpperEdge = function(r, e, t) {
    ue(e.fixUpperEdge), r.mesh.delete(e.eUp), e.fixUpperEdge = false, e.eUp = t, t.activeRegion = e;
  }, n.topLeftRegion = function(r, e) {
    var t = e.eUp.Org, o;
    do
      e = n.regionAbove(e);
    while (e.eUp.Org === t);
    if (e.fixUpperEdge) {
      if (o = r.mesh.connect(n.regionBelow(e).eUp.Sym, e.eUp.Lnext), o === null)
        return null;
      n.fixUpperEdge(r, e, o), e = n.regionAbove(e);
    }
    return e;
  }, n.topRightRegion = function(r) {
    var e = r.eUp.Dst;
    do
      r = n.regionAbove(r);
    while (r.eUp.Dst === e);
    return r;
  }, n.addRegionBelow = function(r, e, t) {
    var o = new Hc();
    return o.eUp = t, o.nodeUp = r.dict.insertBefore(e.nodeUp, o), o.fixUpperEdge = false, o.sentinel = false, o.dirty = false, t.activeRegion = o, o;
  }, n.isWindingInside = function(r, e) {
    switch (r.windingRule) {
      case ve.ODD:
        return (e & 1) !== 0;
      case ve.NONZERO:
        return e !== 0;
      case ve.POSITIVE:
        return e > 0;
      case ve.NEGATIVE:
        return e < 0;
      case ve.ABS_GEQ_TWO:
        return e >= 2 || e <= -2;
    }
    throw new Error("Invalid winding rulle");
  }, n.computeWinding = function(r, e) {
    e.windingNumber = n.regionAbove(e).windingNumber + e.eUp.winding, e.inside = n.isWindingInside(r, e.windingNumber);
  }, n.finishRegion = function(r, e) {
    var t = e.eUp, o = t.Lface;
    o.inside = e.inside, o.anEdge = t, n.deleteRegion(r, e);
  }, n.finishLeftRegions = function(r, e, t) {
    for (var o, i = null, s = e, l = e.eUp; s !== t; ) {
      if (s.fixUpperEdge = false, i = n.regionBelow(s), o = i.eUp, o.Org != l.Org) {
        if (!i.fixUpperEdge) {
          n.finishRegion(r, s);
          break;
        }
        o = r.mesh.connect(l.Lprev, o.Sym), n.fixUpperEdge(r, i, o);
      }
      l.Onext !== o && (r.mesh.splice(o.Oprev, o), r.mesh.splice(l, o)), n.finishRegion(r, s), l = i.eUp, s = i;
    }
    return l;
  }, n.addRightEdges = function(r, e, t, o, i, s) {
    var l, c, u, a, d = true;
    u = t;
    do
      ue(ae.vertLeq(u.Org, u.Dst)), n.addRegionBelow(r, e, u.Sym), u = u.Onext;
    while (u !== o);
    for (i === null && (i = n.regionBelow(e).eUp.Rprev), c = e, a = i; l = n.regionBelow(c), u = l.eUp.Sym, u.Org === a.Org; )
      u.Onext !== a && (r.mesh.splice(u.Oprev, u), r.mesh.splice(a.Oprev, u)), l.windingNumber = c.windingNumber - u.winding, l.inside = n.isWindingInside(r, l.windingNumber), c.dirty = true, !d && n.checkForRightSplice(r, c) && (n.addWinding(u, a), n.deleteRegion(r, c), r.mesh.delete(a)), d = false, c = l, a = u;
    c.dirty = true, ue(c.windingNumber - u.winding === l.windingNumber), s && n.walkDirtyRegions(r, c);
  }, n.spliceMergeVertices = function(r, e, t) {
    r.mesh.splice(e, t);
  }, n.vertexWeights = function(r, e, t) {
    var o = ae.vertL1dist(e, r), i = ae.vertL1dist(t, r), s = 0.5 * i / (o + i), l = 0.5 * o / (o + i);
    r.coords[0] += s * e.coords[0] + l * t.coords[0], r.coords[1] += s * e.coords[1] + l * t.coords[1], r.coords[2] += s * e.coords[2] + l * t.coords[2];
  }, n.getIntersectData = function(r, e, t, o, i, s) {
    e.coords[0] = e.coords[1] = e.coords[2] = 0, e.idx = -1, n.vertexWeights(e, t, o), n.vertexWeights(e, i, s);
  }, n.checkForRightSplice = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp;
    if (ae.vertLeq(o.Org, i.Org)) {
      if (ae.edgeSign(i.Dst, o.Org, i.Org) > 0)
        return false;
      ae.vertEq(o.Org, i.Org) ? o.Org !== i.Org && (r.pq.delete(o.Org.pqHandle), n.spliceMergeVertices(r, i.Oprev, o)) : (r.mesh.splitEdge(i.Sym), r.mesh.splice(o, i.Oprev), e.dirty = t.dirty = true);
    } else {
      if (ae.edgeSign(o.Dst, i.Org, o.Org) < 0)
        return false;
      n.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), r.mesh.splice(i.Oprev, o);
    }
    return true;
  }, n.checkForLeftSplice = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp, s;
    if (ue(!ae.vertEq(o.Dst, i.Dst)), ae.vertLeq(o.Dst, i.Dst)) {
      if (ae.edgeSign(o.Dst, i.Dst, o.Org) < 0)
        return false;
      n.regionAbove(e).dirty = e.dirty = true, s = r.mesh.splitEdge(o), r.mesh.splice(i.Sym, s), s.Lface.inside = e.inside;
    } else {
      if (ae.edgeSign(i.Dst, o.Dst, i.Org) > 0)
        return false;
      e.dirty = t.dirty = true, s = r.mesh.splitEdge(i), r.mesh.splice(o.Lnext, i.Sym), s.Rface.inside = e.inside;
    }
    return true;
  }, n.checkForIntersect = function(r, e) {
    var t = n.regionBelow(e), o = e.eUp, i = t.eUp, s = o.Org, l = i.Org, c = o.Dst, u = i.Dst, a, d, p = new Rn(), f, m;
    if (ue(!ae.vertEq(u, c)), ue(ae.edgeSign(c, r.event, s) <= 0), ue(ae.edgeSign(u, r.event, l) >= 0), ue(s !== r.event && l !== r.event), ue(!e.fixUpperEdge && !t.fixUpperEdge), s === l || (a = Math.min(s.t, c.t), d = Math.max(l.t, u.t), a > d))
      return false;
    if (ae.vertLeq(s, l)) {
      if (ae.edgeSign(u, s, l) > 0)
        return false;
    } else if (ae.edgeSign(c, l, s) < 0)
      return false;
    return n.debugEvent(r), ae.intersect(c, s, u, l, p), ue(Math.min(s.t, c.t) <= p.t), ue(p.t <= Math.max(l.t, u.t)), ue(Math.min(u.s, c.s) <= p.s), ue(p.s <= Math.max(l.s, s.s)), ae.vertLeq(p, r.event) && (p.s = r.event.s, p.t = r.event.t), f = ae.vertLeq(s, l) ? s : l, ae.vertLeq(f, p) && (p.s = f.s, p.t = f.t), ae.vertEq(p, s) || ae.vertEq(p, l) ? (n.checkForRightSplice(r, e), false) : !ae.vertEq(c, r.event) && ae.edgeSign(c, r.event, p) >= 0 || !ae.vertEq(u, r.event) && ae.edgeSign(u, r.event, p) <= 0 ? u === r.event ? (r.mesh.splitEdge(o.Sym), r.mesh.splice(i.Sym, o), e = n.topLeftRegion(r, e), o = n.regionBelow(e).eUp, n.finishLeftRegions(r, n.regionBelow(e), t), n.addRightEdges(r, e, o.Oprev, o, o, true), true) : c === r.event ? (r.mesh.splitEdge(i.Sym), r.mesh.splice(o.Lnext, i.Oprev), t = e, e = n.topRightRegion(e), m = n.regionBelow(e).eUp.Rprev, t.eUp = i.Oprev, i = n.finishLeftRegions(r, t, null), n.addRightEdges(r, e, i.Onext, o.Rprev, m, true), true) : (ae.edgeSign(c, r.event, p) >= 0 && (n.regionAbove(e).dirty = e.dirty = true, r.mesh.splitEdge(o.Sym), o.Org.s = r.event.s, o.Org.t = r.event.t), ae.edgeSign(u, r.event, p) <= 0 && (e.dirty = t.dirty = true, r.mesh.splitEdge(i.Sym), i.Org.s = r.event.s, i.Org.t = r.event.t), false) : (r.mesh.splitEdge(o.Sym), r.mesh.splitEdge(i.Sym), r.mesh.splice(i.Oprev, o), o.Org.s = p.s, o.Org.t = p.t, o.Org.pqHandle = r.pq.insert(o.Org), n.getIntersectData(r, o.Org, s, c, l, u), n.regionAbove(e).dirty = e.dirty = t.dirty = true, false);
  }, n.walkDirtyRegions = function(r, e) {
    for (var t = n.regionBelow(e), o, i; ; ) {
      for (; t.dirty; )
        e = t, t = n.regionBelow(t);
      if (!e.dirty && (t = e, e = n.regionAbove(e), e === null || !e.dirty))
        return;
      if (e.dirty = false, o = e.eUp, i = t.eUp, o.Dst !== i.Dst && n.checkForLeftSplice(r, e) && (t.fixUpperEdge ? (n.deleteRegion(r, t), r.mesh.delete(i), t = n.regionBelow(e), i = t.eUp) : e.fixUpperEdge && (n.deleteRegion(r, e), r.mesh.delete(o), e = n.regionAbove(t), o = e.eUp)), o.Org !== i.Org)
        if (o.Dst !== i.Dst && !e.fixUpperEdge && !t.fixUpperEdge && (o.Dst === r.event || i.Dst === r.event)) {
          if (n.checkForIntersect(r, e))
            return;
        } else
          n.checkForRightSplice(r, e);
      o.Org === i.Org && o.Dst === i.Dst && (n.addWinding(i, o), n.deleteRegion(r, e), r.mesh.delete(o), e = n.regionAbove(t));
    }
  }, n.connectRightVertex = function(r, e, t) {
    var o, i = t.Onext, s = n.regionBelow(e), l = e.eUp, c = s.eUp, u = false;
    if (l.Dst !== c.Dst && n.checkForIntersect(r, e), ae.vertEq(l.Org, r.event) && (r.mesh.splice(i.Oprev, l), e = n.topLeftRegion(r, e), i = n.regionBelow(e).eUp, n.finishLeftRegions(r, n.regionBelow(e), s), u = true), ae.vertEq(c.Org, r.event) && (r.mesh.splice(t, c.Oprev), t = n.finishLeftRegions(r, s, null), u = true), u) {
      n.addRightEdges(r, e, t.Onext, i, i, true);
      return;
    }
    ae.vertLeq(c.Org, l.Org) ? o = c.Oprev : o = l, o = r.mesh.connect(t.Lprev, o), n.addRightEdges(r, e, o, o.Onext, o.Onext, false), o.Sym.activeRegion.fixUpperEdge = true, n.walkDirtyRegions(r, e);
  }, n.connectLeftDegenerate = function(r, e, t) {
    var o, i, s, l, c;
    if (o = e.eUp, ae.vertEq(o.Org, t)) {
      ue(false), n.spliceMergeVertices(r, o, t.anEdge);
      return;
    }
    if (!ae.vertEq(o.Dst, t)) {
      r.mesh.splitEdge(o.Sym), e.fixUpperEdge && (r.mesh.delete(o.Onext), e.fixUpperEdge = false), r.mesh.splice(t.anEdge, o), n.sweepEvent(r, t);
      return;
    }
    ue(false), e = n.topRightRegion(e), c = n.regionBelow(e), s = c.eUp.Sym, i = l = s.Onext, c.fixUpperEdge && (ue(i !== s), n.deleteRegion(r, c), r.mesh.delete(s), s = i.Oprev), r.mesh.splice(t.anEdge, s), ae.edgeGoesLeft(i) || (i = null), n.addRightEdges(r, e, s.Onext, l, i, true);
  }, n.connectLeftVertex = function(r, e) {
    var t, o, i, s, l, c, u = new Hc();
    if (u.eUp = e.anEdge.Sym, t = r.dict.search(u).key, o = n.regionBelow(t), !!o) {
      if (s = t.eUp, l = o.eUp, ae.edgeSign(s.Dst, e, s.Org) === 0) {
        n.connectLeftDegenerate(r, t, e);
        return;
      }
      if (i = ae.vertLeq(l.Dst, s.Dst) ? t : o, t.inside || i.fixUpperEdge) {
        if (i === t)
          c = r.mesh.connect(e.anEdge.Sym, s.Lnext);
        else {
          var a = r.mesh.connect(l.Dnext, e.anEdge);
          c = a.Sym;
        }
        i.fixUpperEdge ? n.fixUpperEdge(r, i, c) : n.computeWinding(r, n.addRegionBelow(r, t, c)), n.sweepEvent(r, e);
      } else
        n.addRightEdges(r, t, e.anEdge, e.anEdge, null, true);
    }
  }, n.sweepEvent = function(r, e) {
    r.event = e, n.debugEvent(r);
    for (var t = e.anEdge; t.activeRegion === null; )
      if (t = t.Onext, t === e.anEdge) {
        n.connectLeftVertex(r, e);
        return;
      }
    var o = n.topLeftRegion(r, t.activeRegion);
    ue(o !== null);
    var i = n.regionBelow(o), s = i.eUp, l = n.finishLeftRegions(r, i, null);
    l.Onext === s ? n.connectRightVertex(r, o, l) : n.addRightEdges(r, o, l.Onext, s, s, true);
  }, n.addSentinel = function(r, e, t, o) {
    var i = new Hc(), s = r.mesh.makeEdge();
    s.Org.s = t, s.Org.t = o, s.Dst.s = e, s.Dst.t = o, r.event = s.Dst, i.eUp = s, i.windingNumber = 0, i.inside = false, i.fixUpperEdge = false, i.sentinel = true, i.dirty = false, i.nodeUp = r.dict.insert(i);
  }, n.initEdgeDict = function(r) {
    r.dict = new D_(r, n.edgeLeq);
    var e = r.bmax[0] - r.bmin[0], t = r.bmax[1] - r.bmin[1], o = r.bmin[0] - e, i = r.bmax[0] + e, s = r.bmin[1] - t, l = r.bmax[1] + t;
    n.addSentinel(r, o, i, s), n.addSentinel(r, o, i, l);
  }, n.doneEdgeDict = function(r) {
    for (var e, t = 0; (e = r.dict.min().key) !== null; )
      e.sentinel || (ue(e.fixUpperEdge), ue(++t === 1)), ue(e.windingNumber === 0), n.deleteRegion(r, e);
  }, n.removeDegenerateEdges = function(r) {
    var e, t, o, i = r.mesh.eHead;
    for (e = i.next; e !== i; e = t)
      t = e.next, o = e.Lnext, ae.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e && (n.spliceMergeVertices(r, o, e), r.mesh.delete(e), e = o, o = e.Lnext), o.Lnext === e && (o !== e && ((o === t || o === t.Sym) && (t = t.next), r.mesh.delete(o)), (e === t || e === t.Sym) && (t = t.next), r.mesh.delete(e));
  }, n.initPriorityQ = function(r) {
    var e, t, o, i = 0;
    for (o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      i++;
    for (i += 8, e = r.pq = new B_(i, ae.vertLeq), o = r.mesh.vHead, t = o.next; t !== o; t = t.next)
      t.pqHandle = e.insert(t);
    return t !== o ? false : (e.init(), true);
  }, n.donePriorityQ = function(r) {
    r.pq = null;
  }, n.removeDegenerateFaces = function(r, e) {
    var t, o, i;
    for (t = e.fHead.next; t !== e.fHead; t = o)
      o = t.next, i = t.anEdge, ue(i.Lnext !== i), i.Lnext.Lnext === i && (n.addWinding(i.Onext, i), r.mesh.delete(i));
    return true;
  }, n.computeInterior = function(r, e) {
    e === void 0 && (e = true);
    var t, o;
    if (n.removeDegenerateEdges(r), !n.initPriorityQ(r))
      return false;
    for (n.initEdgeDict(r); (t = r.pq.extractMin()) !== null; ) {
      for (; o = r.pq.min(), !(o === null || !ae.vertEq(o, t)); )
        o = r.pq.extractMin(), n.spliceMergeVertices(r, t.anEdge, o.anEdge);
      n.sweepEvent(r, t);
    }
    return r.event = r.dict.min().key.eUp.Org, n.debugEvent(r), n.doneEdgeDict(r), n.donePriorityQ(r), n.removeDegenerateFaces(r, r.mesh) ? (e && r.mesh.check(), true) : false;
  }, n;
}();
var R_ = function() {
  function n() {
    this.mesh = new rh(), this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = ve.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
  }
  return n.prototype.dot_ = function(r, e) {
    return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
  }, n.prototype.normalize_ = function(r) {
    var e = r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
    if (!e)
      throw "Zero-size vector!";
    e = Math.sqrt(e), r[0] /= e, r[1] /= e, r[2] /= e;
  }, n.prototype.longAxis_ = function(r) {
    var e = 0;
    return Math.abs(r[1]) > Math.abs(r[0]) && (e = 1), Math.abs(r[2]) > Math.abs(r[e]) && (e = 2), e;
  }, n.prototype.computeNormal_ = function(r) {
    var e, t, o, i, s, l, c = [0, 0, 0], u = [0, 0, 0], a = [0, 0, 0], d = [0, 0, 0], p = [0, 0, 0], f = [null, null, null], m = [null, null, null], h = this.mesh.vHead;
    e = h.next;
    for (var y = 0; y < 3; ++y)
      i = e.coords[y], u[y] = i, m[y] = e, c[y] = i, f[y] = e;
    for (e = h.next; e !== h; e = e.next)
      for (var g = 0; g < 3; ++g)
        i = e.coords[g], i < u[g] && (u[g] = i, m[g] = e), i > c[g] && (c[g] = i, f[g] = e);
    var v = 0;
    if (c[1] - u[1] > c[0] - u[0] && (v = 1), c[2] - u[2] > c[v] - u[v] && (v = 2), u[v] >= c[v]) {
      r[0] = 0, r[1] = 0, r[2] = 1;
      return;
    }
    for (l = 0, t = m[v], o = f[v], a[0] = t.coords[0] - o.coords[0], a[1] = t.coords[1] - o.coords[1], a[2] = t.coords[2] - o.coords[2], e = h.next; e !== h; e = e.next)
      d[0] = e.coords[0] - o.coords[0], d[1] = e.coords[1] - o.coords[1], d[2] = e.coords[2] - o.coords[2], p[0] = a[1] * d[2] - a[2] * d[1], p[1] = a[2] * d[0] - a[0] * d[2], p[2] = a[0] * d[1] - a[1] * d[0], s = p[0] * p[0] + p[1] * p[1] + p[2] * p[2], s > l && (l = s, r[0] = p[0], r[1] = p[1], r[2] = p[2]);
    l <= 0 && (r[0] = r[1] = r[2] = 0, r[this.longAxis_(a)] = 1);
  }, n.prototype.checkOrientation_ = function() {
    for (var r = this.mesh.fHead, e, t = this.mesh.vHead, o, i = 0, s = r.next; s !== r; s = s.next)
      if (o = s.anEdge, !(o.winding <= 0))
        do
          i += (o.Org.s - o.Dst.s) * (o.Org.t + o.Dst.t), o = o.Lnext;
        while (o !== s.anEdge);
    if (i < 0) {
      for (e = t.next; e !== t; e = e.next)
        e.t = -e.t;
      this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
    }
  }, n.prototype.projectPolygon_ = function() {
    var r = this.mesh.vHead, e = [0, 0, 0], t, o, i = false;
    e[0] = this.normal[0], e[1] = this.normal[1], e[2] = this.normal[2], !e[0] && !e[1] && !e[2] && (this.computeNormal_(e), i = true), t = this.sUnit, o = this.tUnit;
    var s = this.longAxis_(e);
    t[s] = 0, t[(s + 1) % 3] = 1, t[(s + 2) % 3] = 0, o[s] = 0, o[(s + 1) % 3] = 0, o[(s + 2) % 3] = e[s] > 0 ? 1 : -1;
    for (var l = r.next; l !== r; l = l.next)
      l.s = this.dot_(l.coords, t), l.t = this.dot_(l.coords, o);
    i && this.checkOrientation_();
    for (var c = true, u = r.next; u !== r; u = u.next)
      c ? (this.bmin[0] = this.bmax[0] = u.s, this.bmin[1] = this.bmax[1] = u.t, c = false) : (u.s < this.bmin[0] && (this.bmin[0] = u.s), u.s > this.bmax[0] && (this.bmax[0] = u.s), u.t < this.bmin[1] && (this.bmin[1] = u.t), u.t > this.bmax[1] && (this.bmax[1] = u.t));
  }, n.prototype.addWinding_ = function(r, e) {
    r.winding += e.winding, r.Sym.winding += e.Sym.winding;
  }, n.prototype.tessellateMonoRegion_ = function(r, e) {
    var t, o;
    if (t = e.anEdge, !(t.Lnext !== t && t.Lnext.Lnext !== t))
      throw "Mono region invalid";
    for (; ae.vertLeq(t.Dst, t.Org); t = t.Lprev)
      ;
    for (; ae.vertLeq(t.Org, t.Dst); t = t.Lnext)
      ;
    o = t.Lprev;
    for (var i = void 0; t.Lnext !== o; )
      if (ae.vertLeq(t.Dst, o.Org)) {
        for (; o.Lnext !== t && (ae.edgeGoesLeft(o.Lnext) || ae.edgeSign(o.Org, o.Dst, o.Lnext.Dst) <= 0); )
          i = r.connect(o.Lnext, o), o = i.Sym;
        o = o.Lprev;
      } else {
        for (; o.Lnext !== t && (ae.edgeGoesRight(t.Lprev) || ae.edgeSign(t.Dst, t.Org, t.Lprev.Org) >= 0); )
          i = r.connect(t, t.Lprev), t = i.Sym;
        t = t.Lnext;
      }
    if (o.Lnext === t)
      throw "Mono region invalid";
    for (; o.Lnext.Lnext !== t; )
      i = r.connect(o.Lnext, o), o = i.Sym;
    return true;
  }, n.prototype.tessellateInterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      if (e = t.next, t.inside && !this.tessellateMonoRegion_(r, t))
        return false;
    return true;
  }, n.prototype.discardExterior_ = function(r) {
    for (var e, t = r.fHead.next; t !== r.fHead; t = e)
      e = t.next, t.inside || r.zapFace(t);
  }, n.prototype.setWindingNumber_ = function(r, e, t) {
    for (var o, i = r.eHead.next; i !== r.eHead; i = o)
      o = i.next, i.Rface.inside !== i.Lface.inside ? i.winding = i.Lface.inside ? e : -e : t ? r.delete(i) : i.winding = 0;
  }, n.prototype.getNeighbourFace_ = function(r) {
    return !r.Rface || !r.Rface.inside ? -1 : r.Rface.n;
  }, n.prototype.outputPolymesh_ = function(r, e, t, o) {
    var i, s = 0, l = 0, c;
    t > 3 && r.mergeConvexFaces(t);
    for (var u = r.vHead.next; u !== r.vHead; u = u.next)
      u.n = -1;
    for (var a = r.fHead.next; a !== r.fHead; a = a.next)
      if (a.n = -1, !!a.inside) {
        i = a.anEdge, c = 0;
        do {
          var u = i.Org;
          u.n === -1 && (u.n = l, l++), c++, i = i.Lnext;
        } while (i !== a.anEdge);
        if (c > t)
          throw "Face vertex greater that support polygon";
        a.n = s, ++s;
      }
    this.elementCount = s, e === De.CONNECTED_POLYGONS && (s *= 2), this.elements = [], this.elements.length = s * t, this.vertexCount = l, this.vertices = [], this.vertices.length = l * o, this.vertexIndices = [], this.vertexIndices.length = l;
    for (var u = r.vHead.next; u !== r.vHead; u = u.next)
      if (u.n !== -1) {
        var d = u.n * o;
        this.vertices[d + 0] = u.coords[0], this.vertices[d + 1] = u.coords[1], o > 2 && (this.vertices[d + 2] = u.coords[2]), this.vertexIndices[u.n] = u.idx;
      }
    for (var p = 0, a = r.fHead.next; a !== r.fHead; a = a.next)
      if (!!a.inside) {
        i = a.anEdge, c = 0;
        do {
          var u = i.Org;
          this.elements[p++] = u.n, c++, i = i.Lnext;
        } while (i !== a.anEdge);
        for (var f = c; f < t; ++f)
          this.elements[p++] = -1;
        if (e === De.CONNECTED_POLYGONS) {
          i = a.anEdge;
          do
            this.elements[p++] = this.getNeighbourFace_(i), i = i.Lnext;
          while (i !== a.anEdge);
          for (var m = c; m < t; ++m)
            this.elements[p++] = -1;
        }
      }
  }, n.prototype.outputContours_ = function(r, e) {
    var t, o, i = 0, s = 0;
    this.vertexCount = 0, this.elementCount = 0;
    for (var l = r.fHead.next; l !== r.fHead; l = l.next)
      if (!!l.inside) {
        o = t = l.anEdge;
        do
          this.vertexCount++, t = t.Lnext;
        while (t !== o);
        this.elementCount++;
      }
    this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * e, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
    var c = 0, u = 0, a = 0;
    i = 0;
    for (var l = r.fHead.next; l !== r.fHead; l = l.next)
      if (!!l.inside) {
        s = 0, o = t = l.anEdge;
        do
          this.vertices[c++] = t.Org.coords[0], this.vertices[c++] = t.Org.coords[1], e > 2 && (this.vertices[c++] = t.Org.coords[2]), this.vertexIndices[u++] = this.vertexIdCallback ? this.vertexIdCallback(t) : t.Org.idx, s++, t = t.Lnext;
        while (t !== o);
        this.elements[a++] = i, this.elements[a++] = s, i += s;
      }
  }, n.prototype.addContour = function(r, e) {
    this.mesh === null && (this.mesh = new rh()), r < 2 && (r = 2), r > 3 && (r = 3);
    for (var t = null, o = 0; o < e.length; o += r)
      t === null ? (t = this.mesh.makeEdge(), this.mesh.splice(t, t.Sym)) : (this.mesh.splitEdge(t), t = t.Lnext), t.Org.coords[0] = e[o + 0], t.Org.coords[1] = e[o + 1], r > 2 ? t.Org.coords[2] = e[o + 2] : t.Org.coords[2] = 0, t.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(t), t.winding = 1, t.Sym.winding = -1;
  }, n.prototype.tesselate = function(r, e, t, o, i, s) {
    if (r === void 0 && (r = ve.ODD), e === void 0 && (e = De.POLYGONS), s === void 0 && (s = true), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, i && (this.normal[0] = i[0], this.normal[1] = i[1], this.normal[2] = i[2]), this.windingRule = r, o < 2 && (o = 2), o > 3 && (o = 3), !this.mesh)
      return false;
    this.projectPolygon_(), G_.computeInterior(this, s);
    var l = this.mesh;
    return e === De.BOUNDARY_CONTOURS ? this.setWindingNumber_(l, 1, true) : this.tessellateInterior_(l), s && l.check(), e === De.BOUNDARY_CONTOURS ? this.outputContours_(l, o) : this.outputPolymesh_(l, e, t, o), true;
  }, n;
}();
function er(n) {
  var r = n.windingRule, e = r === void 0 ? ve.ODD : r, t = n.elementType, o = t === void 0 ? De.POLYGONS : t, i = n.polySize, s = i === void 0 ? 3 : i, l = n.vertexSize, c = l === void 0 ? 2 : l, u = n.normal, a = u === void 0 ? [0, 0, 1] : u, d = n.contours, p = d === void 0 ? [] : d, f = n.strict, m = f === void 0 ? true : f, h = n.debug, y = h === void 0 ? false : h;
  if (!p && m)
    throw new Error("Contours can't be empty");
  if (!!p) {
    var g = new R_();
    n.edgeCreateCallback && (g.edgeCreateCallback = n.edgeCreateCallback), n.vertexIdCallback && (g.vertexIdCallback = n.vertexIdCallback);
    for (var v = 0; v < p.length; v++)
      g.addContour(c || 2, p[v]);
    return g.tesselate(e, o, s, c, a, m), { vertices: g.vertices, vertexIndices: g.vertexIndices, vertexCount: g.vertexCount, elements: g.elements, elementCount: g.elementCount, mesh: y ? g.mesh : void 0 };
  }
}
var fV = ve.ODD;
var mV = ve.NONZERO;
var hV = ve.POSITIVE;
var yV = ve.NEGATIVE;
var gV = ve.ABS_GEQ_TWO;
var xV = De.POLYGONS;
var vV = De.CONNECTED_POLYGONS;
var bV = De.BOUNDARY_CONTOURS;
var Vn = class extends BufferGeometry {
  constructor(e, t = 12, o = {}) {
    super();
    this.type = "ShapeGeometry";
    this.windingRule = ve.ODD;
    this.elementType = De.POLYGONS;
    this.polySize = 3;
    this.vertexSize = 2;
    this.strict = true;
    this._shape = e, this._curveSegments = t, this._triangulationOptions = Object.assign({ windingRule: ve.ODD, elementType: De.POLYGONS, polySize: 3, vertexSize: 2, strict: true }, o);
    let i = this._shape.extractShapePointsToFlatArray([], this._curveSegments), s = this._shape.shapeHoles.map((m) => m.extractShapePointsToFlatArray([], this._curveSegments)), l, c = true, u = true, a, d;
    for (let m = 0, h = i.length / 2; m < h; m++) {
      let y = m * 2, g = i[y + 0], v = i[y + 1];
      if (a !== void 0 && g !== a && (c = false), d !== void 0 && v !== d && (u = false), a = g, d = v, !c && !u)
        break;
    }
    !c && !u && (l = er({ contours: [i, ...s], windingRule: this._triangulationOptions.windingRule, elementType: this._triangulationOptions.elementType, polySize: this._triangulationOptions.polySize, vertexSize: this._triangulationOptions.vertexSize, strict: this._triangulationOptions.strict }));
    let p = (l == null ? void 0 : l.vertexCount) ?? 1, f = (l == null ? void 0 : l.elementCount) ?? 1;
    if (this._positionAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._normalAttribute = new BufferAttribute(new Float32Array(p * 3), 3), this._uvAttribute = new BufferAttribute(new Float32Array(p * 2), 2), this._indexAttribute = new BufferAttribute(new Uint32Array(f * 3), 1), l) {
      let m = 1 / 0, h = -1 / 0, y = 1 / 0, g = -1 / 0;
      for (let w = 0, b = p; w < b; w++) {
        let T = w * 2, _ = l.vertices[T + 0], x = l.vertices[T + 1];
        _ < m && (m = _), _ > h && (h = _), x < y && (y = x), x > g && (g = x);
      }
      let v = h - m, S = g - y;
      for (let w = 0, b = p; w < b; w++) {
        let T = w * 2, _ = l.vertices[T + 0], x = l.vertices[T + 1], C = (_ - m) / v, P = (x - y) / S;
        this._positionAttribute.setXYZ(w, _, x, 0), this._normalAttribute.setXYZ(w, 0, 0, 1), this._uvAttribute.setXY(w, C, P);
      }
      for (let w = 0, b = f; w < b; w++) {
        let T = w * 3, _ = l.elements[T + 0], x = l.elements[T + 1], C = l.elements[T + 2];
        this._indexAttribute.setX(T + 0, _), this._indexAttribute.setX(T + 1, x), this._indexAttribute.setX(T + 2, C);
      }
    }
    this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, ((l == null ? void 0 : l.elementCount) ?? 1) * 3);
  }
  clone() {
    let e = new Vn(this._shape, this._curveSegments);
    return e.userData = Vr(this.userData), e;
  }
};
var Ka = class {
  constructor(r = 256, e = false) {
    this.capacity = r, this.size = 0, this.debug = e, this.debug && console.log(`allocating with cap ${r}`);
    let t = r * Ka.eSize;
    this.buffer = new ArrayBuffer(t);
    let o = Float32Array.BYTES_PER_ELEMENT, i = 0;
    this.positions = new Float32Array(this.buffer, i * o, 3 * r), i += 3 * r, this.normals = new Float32Array(this.buffer, i * o, 3 * r), i += 3 * r, this.uvs = new Float32Array(this.buffer, i * o, 2 * r);
  }
  realloc(r, e = false) {
    if (r < this.size)
      throw Error("cannot shrink buffer");
    if (r <= this.capacity && !e)
      return;
    this.debug && console.log(`resizing from ${this.capacity} → ${r}`);
    let t = r * Ka.eSize, o = new ArrayBuffer(t), i = Float32Array.BYTES_PER_ELEMENT, s = 0, l = new Float32Array(o, s * i, 3 * r);
    s += 3 * r;
    let c = new Float32Array(o, s * i, 3 * r);
    s += 3 * r;
    let u = new Float32Array(o, s * i, 2 * r);
    l.set(this.positions.slice(0, this.size * 3)), c.set(this.normals.slice(0, this.size * 3)), u.set(this.uvs.slice(0, this.size * 2)), this.buffer = o, this.positions = l, this.normals = c, this.uvs = u, this.capacity = r;
  }
  get(r = 1) {
    let e = this.size + r;
    if (e > this.capacity) {
      let o = this.capacity;
      for (; e > o; )
        o *= 2;
      this.realloc(o);
    }
    let t = this.size;
    return this.size = e, t;
  }
  reserve(r) {
    let e = this.size + r;
    e > this.capacity && this.realloc(e);
  }
  shrink() {
    this.debug && console.log(`shrinking ${this.capacity} → ${this.size}`), this.realloc(this.size, true);
  }
};
var Hi = Ka;
Hi.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
var Wc = (n, r) => ([e, t]) => (t < e && (t += r), (n >= e ? n : n + r) <= t);
var jn = class extends BufferGeometry {
  constructor(e, t, o = 0, i = 12, s = 3, l = ve.ODD) {
    super();
    this.type = "ShapeGeometry";
    this.vertexCache = {};
    this._shape = e, this._depth = t, this._bevel = o, this._curveSegments = i, this._bevelSegmentsInput = s, o <= 0 ? (this._bevelSize = 0, this._bevelSegments = 0) : (this._bevelSize = Math.min(o, t / 2 - 1e-12), this._bevelSegments = Math.floor(s));
    let c = this._shape.extractShapePointsToFlatArray([], i), u = this._shape.shapeHoles.map((_) => {
      let x = _.extractShapePointsToFlatArray([], i), C = [];
      for (let P = x.length - 1; P >= 1; P -= 2) {
        let I = x[P - 1], O = x[P - 0];
        C.push(I, O);
      }
      return C;
    }), a = er({ windingRule: l, elementType: De.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [c] }), d = er({ windingRule: ve.ODD, elementType: De.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [...u] });
    if (!a)
      throw new Error("error generating geometry");
    let p = a.elementCount;
    if (d) {
      a.elementCount += d.elementCount;
      for (let _ = 0; _ < d.elements.length; _++) {
        let x = d.elements[_], C = _ % 2 === 0 ? a.vertexCount : 0;
        a.elements.push(x + C);
      }
      for (let _ = 0; _ < d.vertexIndices.length; _++) {
        let x = d.vertexIndices[_], C = a.vertexCount;
        a.vertexIndices.push(x + C);
      }
      for (let _ = 0; _ < d.vertices.length; _++) {
        let x = d.vertices[_];
        a.vertices.push(x);
      }
    }
    let f = 1 / 0, m = -1 / 0, h = 1 / 0, y = -1 / 0;
    for (let _ = 0, x = a.vertexCount; _ < x; _++) {
      let C = _ * 2, P = a.vertices[C + 0], I = a.vertices[C + 1];
      P < f && (f = P), P > m && (m = P), I < h && (h = I), I > y && (y = I);
    }
    this._minX = f, this._minY = h, this._width = m - f, this._height = y - h, this._buffer = new Hi(this._computeBufferEstimatedSize(a));
    let g = [], v = [];
    for (let _ = a.elementCount - 1; _ >= 0; _--) {
      let x = _ >= p, C = _ * 2, P = a.elements[C + 0], I = a.elements[C + 1], O = P + I, A = { start: P, count: I, normals: [], continuous: [], concave: [] }, G = P, z = O - 1, $ = P + 1, te = this._shape.roundedCurves.length;
      do {
        let R = G - P, D = a.vertices[z * 2 + 0], B = a.vertices[z * 2 + 1], L = a.vertices[G * 2 + 0], F = a.vertices[G * 2 + 1], W = a.vertices[$ * 2 + 0], H = a.vertices[$ * 2 + 1], j = L - D, U = F - B, E = Math.sqrt(j * j + U * U);
        j /= E, U /= E;
        let oe = L - W, Y = F - H, re = Math.sqrt(oe * oe + Y * Y);
        oe /= re, Y /= re, A.normals[R * 2 + 0] = -Y, A.normals[R * 2 + 1] = oe, A.concave[R] = j * Y - U * oe > 0;
        let X = a.vertexIndices[G];
        if (Array.isArray(X))
          A.continuous[R] = false;
        else {
          let [ee, Z] = this._shape.getCurveIndexFromVertexId(X - 1, true);
          if (Z > 0 && Z < 1)
            A.continuous[R] = true;
          else {
            let ie = Z === 1 ? ee + 1 : ee - 1;
            ie = (ie + te) % te;
            let ce = Z === 1 ? 0 : 1, se = this._shape.roundedCurves[ee].getTangent(Z), pe = this._shape.roundedCurves[ie].getTangent(ce);
            A.continuous[R] = se.dot(pe) > 0.95;
          }
        }
        x && (A.normals[R * 2 + 0] *= -1, A.normals[R * 2 + 1] *= -1), [z, G, $] = [G, $, $ + 1], $ >= O && ($ -= I);
      } while ($ !== P + 1);
      let K = [];
      K.push({ bevelI: 0, angle: 0, size: 0, boundary: { vertices: a.vertices.slice(P * 2, O * 2), vertexCount: I, vertexIndices: new Array(I).fill(true).map((R, D) => [D, D]), elements: [0, I], elementCount: 1, mesh: null }, reverseMap: [], insetPoints: a.vertices.slice(P * 2, O * 2) });
      for (let R = 1; R <= this._bevelSegments; R++) {
        let D = R / this._bevelSegments * Math.PI / 2, B = (1 - Math.cos(D)) * this._bevelSize, L = [], F = [], W = [], H = [], j = 0;
        for (let E = 0; E < I; E++) {
          let oe = E * 2, Y = (E - 1 + I) % I * 2, re = a.vertices[A.start * 2 + oe + 0], X = a.vertices[A.start * 2 + oe + 1], ee = -A.normals[Y + 0] * B, Z = -A.normals[Y + 1] * B, ie = -A.normals[oe + 0] * B, ce = -A.normals[oe + 1] * B;
          if (A.concave[E] || !A.concave[E] && x) {
            let se = Math.atan2(Z, ee), pe = Math.atan2(ce, ie);
            pe > se && (pe -= Math.PI * 2);
            let Le = pe - se;
            if (A.continuous[E] || x) {
              let ge = se + Le / 2, Ge = Math.cos(ge) * B, Pe = Math.sin(ge) * B;
              L[2 * j + 0] = re + Ge * (x ? -1 : 1), L[2 * j + 1] = X + Pe * (x ? -1 : 1), H[j] = E, j++;
            } else {
              let ge = Math.max(1, Math.floor(i / 4 * Math.abs(Le) / Math.PI));
              for (let Ge = 0; Ge <= ge; Ge++) {
                let Pe = se + Le * (Ge / ge), gt = Math.cos(Pe) * B, xt = Math.sin(Pe) * B;
                L[2 * j + 0] = re + gt, L[2 * j + 1] = X + xt, H[j] = E, j++;
              }
            }
          } else
            L[2 * j + 0] = re + ee, L[2 * j + 1] = X + Z, H[j] = E, F[E] = j, j++, L[2 * j + 0] = re, L[2 * j + 1] = X, H[j] = E, j++, L[2 * j + 0] = re + ie, L[2 * j + 1] = X + ce, H[j] = E, W[E] = j, j++;
        }
        let U = er({ windingRule: ve.POSITIVE, elementType: De.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [L], edgeCreateCallback: (E) => {
          let Y = E.Org.idx, re = H[Y], X = H[(Y + 1) % H.length];
          E.idx = [re, X], E.Sym.idx = [X, re];
        }, vertexIdCallback: (E) => {
          let oe = E.Lprev.idx;
          return [oe ? oe[1] : 0, E.idx ? E.idx[0] : 0];
        } });
        if (!U)
          throw console.log("Error"), new Error(`error generating bevel geometry for ${R}'th loop`);
        if (!U.vertexCount)
          break;
        for (let E = 0; E < U.vertexIndices.length; E++) {
          let [oe, Y] = U.vertexIndices[E];
          if (oe === Y)
            continue;
          let re = Y;
          Y < oe && (re += I);
          for (let X = oe; X < re; X++) {
            let ee = X % I, Z = (X + 1) % I;
            if (!A.continuous[ee] || !A.continuous[Z]) {
              U.vertexIndices[E] = [oe, ee], U.vertexIndices.splice(E + 1, 0, [Z, Y]), U.vertices.splice((E + 1) * 2, 0, U.vertices[E * 2], U.vertices[E * 2 + 1]);
              break;
            }
          }
        }
        K.push({ bevelI: R, angle: D, size: B, boundary: U, reverseMap: H, insetPoints: L });
      }
      let q = (R, D, B) => {
        let L = 0, F = R.boundary.vertexIndices.length;
        for (; L < F && B(R.boundary.vertexIndices[D]); )
          D = (D + 1) % F, L++;
        return L;
      }, k = g.length;
      for (let R = 1; R < K.length; R++) {
        let D = K[R - 1], B = K[R], L = D.boundary.vertexIndices.length, F = B.boundary.vertexIndices.length;
        if (!L || !F)
          break;
        let W = A.concave.length, H = 0, j = Wc(H, I);
        for (; !D.boundary.vertexIndices.filter(j).length || !B.boundary.vertexIndices.filter(j).length; )
          H++, j = Wc(H, I);
        let U = D.boundary.vertexIndices.findIndex(j), E = B.boundary.vertexIndices.findIndex(j);
        do
          U = (U + 1) % L;
        while (j(D.boundary.vertexIndices[U]));
        do
          E = (E + 1) % F;
        while (j(B.boundary.vertexIndices[E]));
        H = (H + 1) % I;
        let oe = H, Y = this._buildBevelVert(A, D, (U - 1 + L) % L), re = this._buildBevelVert(A, B, (E - 1 + F) % F), X = Y, ee = re, Z, ie, ce = false;
        do {
          j = Wc(H, I);
          let se = q(D, U, j), pe = q(B, E, j), Le = ce;
          if (ce = false, se && !pe) {
            for (let ge = 0; ge < se; ge++)
              Z = this._buildBevelVert(A, D, (U + ge) % L, ge / (se - 1)), g.push(X.topN, Z.topP, ee.topN), g.push(Z.bottomP, X.bottomN, ee.bottomN), X = Z;
            ce = true;
          } else if (!se && pe)
            for (let ge = 0; ge < pe; ge++)
              ie = this._buildBevelVert(A, B, (E + ge) % F, ge / (pe - 1)), g.push(ee.topN, X.topP, ie.topP), g.push(X.bottomP, ee.bottomN, ie.bottomP), ee = ie;
          else if (se && pe)
            if (Z = this._buildBevelVert(A, D, U, 0), ie = this._buildBevelVert(A, B, E, 0), Le ? (g.push(X.topN, ie.topP, ee.topN), g.push(X.topN, Z.topP, ie.topP), g.push(ie.bottomP, X.bottomN, ee.bottomN), g.push(ie.bottomP, Z.bottomP, X.bottomN)) : (g.push(ee.topN, X.topN, Z.topP), g.push(ee.topN, Z.topP, ie.topP), g.push(Z.bottomP, X.bottomN, ee.bottomN), g.push(Z.bottomP, ee.bottomN, ie.bottomP)), X = Z, ee = ie, se === pe)
              for (let ge = 1; ge < se; ge++)
                Z = this._buildBevelVert(A, D, (U + ge) % L, ge / (se - 1)), ie = this._buildBevelVert(A, B, (E + ge) % F, ge / (pe - 1)), g.push(X.topN, Z.topP, ee.topN), g.push(ee.topN, Z.topP, ie.topP), g.push(Z.bottomP, X.bottomN, ee.bottomN), g.push(Z.bottomP, ee.bottomN, ie.bottomP), X = Z, ee = ie;
            else if (se > pe) {
              let ge = se / pe, Ge = 0;
              for (let Pe = 1; Pe < se; Pe++)
                Z = this._buildBevelVert(A, D, (U + Pe) % L, Pe / (se - 1)), g.push(X.topN, Z.topP, ee.topN), g.push(Z.bottomP, X.bottomN, ee.bottomN), X = Z, Pe > (Ge + 1) * ge && (Ge++, ie = this._buildBevelVert(A, B, (E + Ge) % F, Ge / (pe - 1)), g.push(ee.topN, Z.topP, ie.topP), g.push(Z.bottomP, ee.bottomN, ie.bottomP), ee = ie);
            } else {
              let ge = pe / se, Ge = 0;
              for (let Pe = 1; Pe < pe; Pe++)
                ie = this._buildBevelVert(A, B, (E + Pe) % F, Pe / (pe - 1)), g.push(ee.topN, Z.topP, ie.topP), g.push(Z.bottomP, ee.bottomN, ie.bottomP), ee = ie, Pe > (Ge + 1) * ge && (Ge++, Z = this._buildBevelVert(A, D, (U + Ge) % L, Ge / (se - 1)), g.push(X.topN, Z.topP, ee.topN), g.push(Z.bottomP, X.bottomN, ee.bottomN), X = Z);
            }
          U = (U + se) % L, E = (E + pe) % F, H = (H + 1) % W;
        } while (H !== oe);
      }
      if (this._buildWall(K, A, g), x) {
        let R = [];
        for (let D = g.length - 1; D >= k + 2; D -= 3) {
          let B = g[D - 2], L = g[D - 1], F = g[D - 0];
          R.push(F, L, B);
        }
        g.splice(k, g.length - k, ...R);
      }
      if (x) {
        let R = [];
        for (let D = K[K.length - 1].boundary.vertices.length - 1; D >= 1; D -= 2) {
          let B = K[K.length - 1].boundary.vertices[D - 1], L = K[K.length - 1].boundary.vertices[D - 0];
          R.push(B, L);
        }
        v.push(R);
      }
      if (!x) {
        let R = K[K.length - 1], D = er({ windingRule: K.length > 1 ? ve.POSITIVE : ve.ODD, elementType: De.POLYGONS, vertexSize: 2, strict: true, contours: [R.insetPoints, ...v] });
        if (!D)
          throw new Error("Error generating geometry for surface");
        u.length === 0 && Object.assign(this, { capStartIndex: g.length });
        for (let B = 0; B < D.elementCount * 3; B += 3) {
          let L = this._buildSurfaceVert(D, D.elements[B + 0]), F = this._buildSurfaceVert(D, D.elements[B + 1]), W = this._buildSurfaceVert(D, D.elements[B + 2]);
          g.push(L.top, F.top, W.top), g.push(W.bottom, F.bottom, L.bottom);
        }
      }
      this.vertexCache = {};
    }
    this._buffer.shrink();
    let S = new BufferAttribute(Uint32Array.from(g), 1), w = new BufferAttribute(this._buffer.positions, 3), b = new BufferAttribute(this._buffer.normals, 3), T = new BufferAttribute(this._buffer.uvs, 2);
    w.needsUpdate = true, b.needsUpdate = true, T.needsUpdate = true, S.needsUpdate = true, this.setAttribute("position", w), this.setAttribute("normal", b), this.setAttribute("uv", T), this.setIndex(S);
  }
  _computeBufferEstimatedSize(e) {
    return e.vertexCount * 2 * (2 + this._bevelSegments);
  }
  _buildWall(e, t, o) {
    let i = e[0];
    for (let s = 0, l = i.boundary.vertexCount; s < l; s++) {
      let c = this._buildBevelVert(t, i, s), u = this._buildBevelVert(t, i, (s + 1) % l);
      o.push(u.topP, c.topN, c.bottomN), o.push(u.topP, c.bottomN, u.bottomP);
    }
  }
  _buildSurfaceVert(e, t) {
    let o = t.toString();
    if (o in this.vertexCache)
      return this.vertexCache[o];
    let i = e.vertices[t * 2 + 0], s = e.vertices[t * 2 + 1], l = (i - this._minX) / this._width, c = (s - this._minY) / this._height, u = this._buffer.get(2), a = u * 3, d = u * 2, p = { top: u + 0, bottom: u + 1 };
    return this._buffer.positions[a + 0] = i, this._buffer.positions[a + 1] = s, this._buffer.positions[a + 2] = this._depth, this._buffer.normals[a + 0] = 0, this._buffer.normals[a + 1] = 0, this._buffer.normals[a + 2] = 1, this._buffer.uvs[d + 0] = l, this._buffer.uvs[d + 1] = c, this._buffer.positions[a + 3] = i, this._buffer.positions[a + 4] = s, this._buffer.positions[a + 5] = 0, this._buffer.normals[a + 3] = 0, this._buffer.normals[a + 4] = 0, this._buffer.normals[a + 5] = -1, this._buffer.uvs[d + 2] = l, this._buffer.uvs[d + 3] = c, this.vertexCache[o] = p, p;
  }
  _buildBevelVert(e, t, o, i = 1) {
    let s = `${t.bevelI}:${o}`;
    if (s in this.vertexCache)
      return this.vertexCache[s];
    let [l, c] = t.boundary.vertexIndices[o], u, a, d, p;
    l !== c ? (a = l, u = c, p = false, d = e.continuous[a] && e.continuous[u]) : (u = l, a = (u - 1 + e.count) % e.count, p = e.concave[u] && t.bevelI > 0, d = e.continuous[u] || p);
    let f = Math.cos(t.angle), m = Math.sin(t.angle), h = o * 2, y = u * 2, g = a * 2, v = t.boundary.vertices[h + 0], S = t.boundary.vertices[h + 1], w = (1 - m) * this._bevelSize, b = (v - this._minX) / this._width, T = (S - this._minY) / this._height, _ = e.normals[y + 0], x = e.normals[y + 1], C = e.normals[g + 0], P = e.normals[g + 1];
    if (p) {
      let z = C - _, $ = P - x;
      _ = _ + z * (1 - i), x = x + $ * (1 - i);
      let te = Math.sqrt(_ * _ + x * x);
      _ /= te, x /= te;
    }
    let I = this._buffer.get(d ? 2 : 4), O = I * 3, A = I * 2, G = { i: o, fi: u, topP: I + 0, topN: I + 0, bottomP: I + 1, bottomN: I + 1 };
    return this._buffer.positions[O + 0] = v, this._buffer.positions[O + 1] = S, this._buffer.positions[O + 2] = this._depth - w, this._buffer.normals[O + 0] = _ * f, this._buffer.normals[O + 1] = x * f, this._buffer.normals[O + 2] = m, this._buffer.uvs[A + 0] = b, this._buffer.uvs[A + 1] = T, this._buffer.positions[O + 3] = v, this._buffer.positions[O + 4] = S, this._buffer.positions[O + 5] = w, this._buffer.normals[O + 3] = _ * f, this._buffer.normals[O + 4] = x * f, this._buffer.normals[O + 5] = -m, this._buffer.uvs[A + 2] = T, this._buffer.uvs[A + 3] = b, d || (I += 2, O += 6, A += 4, G.topP = I + 0, G.bottomP = I + 1, this._buffer.positions[O + 0] = v, this._buffer.positions[O + 1] = S, this._buffer.positions[O + 2] = this._depth - w, this._buffer.normals[O + 0] = C * f, this._buffer.normals[O + 1] = P * f, this._buffer.normals[O + 2] = m, this._buffer.uvs[A + 0] = b, this._buffer.uvs[A + 1] = T, this._buffer.positions[O + 3] = v, this._buffer.positions[O + 4] = S, this._buffer.positions[O + 5] = w, this._buffer.normals[O + 3] = C * f, this._buffer.normals[O + 4] = P * f, this._buffer.normals[O + 5] = -m, this._buffer.uvs[A + 2] = T, this._buffer.uvs[A + 3] = b), this.vertexCache[s] = G, G;
  }
  clone() {
    let e = new jn(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
    return e.userData = Vr(this.userData), e;
  }
};
var Fn = class extends jn {
  constructor(e, t, o = 0, i = 12, s = 3, l = ve.ODD) {
    super(e, t, o, i, s, l);
    this.type = "ShapeGeometry";
  }
  _computeBufferEstimatedSize(e) {
    return e.vertexCount * 2 * (2 + this._bevelSegments);
  }
  _buildWall(e, t, o) {
    let i = e[0];
    for (let s = 0, l = i.boundary.vertexCount; s < l; s++) {
      let c = this._buildBevelVert(t, i, s), u = this._buildBevelVert(t, i, (s + 1) % l);
      o.push(u.topP, c.topN, c.bottomN), o.push(u.topP, c.bottomN, u.bottomP);
    }
  }
  clone() {
    let e = new Fn(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput);
    return e.userData = Vr(this.userData), e;
  }
};
var Tt = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    var _a2, _b2;
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, subdivisions: 40, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3, windingRule: ve.ODD }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.abs(e.depth ?? 0), s = n.shape ?? (r == null ? void 0 : r.shape), l = (s == null ? void 0 : s.roundness) ?? e.roundness;
    s !== void 0 && (s instanceof Se ? (s.width !== t || s.height !== o) && s.applySize(t, o) : s = new Se(t, o).fromJSON(s), ((_a2 = n.parameters) == null ? void 0 : _a2.roundness) !== void 0 && ((_b2 = n.parameters) == null ? void 0 : _b2.roundness) > 0 && s.update());
    let c = s ?? new Se(t, o);
    return { parameters: Object.assign(e, { width: t, height: o, depth: i, roundness: l }), shape: c };
  }
  static build(n) {
    let { depth: r, extrudeBevelSize: e, extrudeBevelSegments: t, subdivisions: o, roundness: i, windingRule: s } = n.parameters;
    n.shape.roundness = i;
    let l;
    return r <= 0 ? l = new Vn(n.shape, o, { windingRule: s }) : l = new Fn(n.shape, r, e, o, t, s), Object.assign(l, { userData: { ...n, type: "VectorGeometry" } });
  }
};
var ch = Math.PI * 2;
var Un = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 64, angle: 360, innerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters);
    return { shape: n.shape && n.shape instanceof Se ? n.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, spikes: t, angle: o, innerRadius: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } = n.parameters, u = n.shape, a = r * 0.5, d = e * 0.5, p = F_(u, a, d, o * Math.PI / 180, t, i);
    u.isClosed = true, u.update();
    let f = Tt.create({ shape: u, parameters: { subdivisions: p, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } });
    return Object.assign(f, { userData: { ...n, type: "EllipseGeometry" } });
  }
};
function F_(n, r, e, t, o, i) {
  if (t >= ch)
    return o > 30 || o % 4 === 0 ? (U_(n, r, e, i), Math.round(o / 4)) : sh(n, t, o, r, e, i);
  t = Math.max(t, 1e-3);
  let s = { x: 0, y: e }, l = t + Math.PI * 0.5, c = { x: Math.cos(l) * r, y: Math.sin(l) * e }, u = th({ px: s.x, py: s.y, cx: c.x, cy: c.y, rx: r, ry: e, largeArcFlag: t > Math.PI, sweepFlag: true });
  return o > 30 || o % u.length === 0 ? z_(n, s.x, s.y, u, o, r, e, i) : sh(n, t, o, r, e, i);
}
function z_(n, r, e, t, o, i, s, l) {
  let c = Math.round(o / t.length);
  n.addPoint(zn(r, e));
  for (let u = 0, a = t.length; u < a; u++) {
    let d = t[u], p = n.points[u], f = zn(d.x, d.y);
    p.controls[1].position.set(d.x1, d.y1), f.controls[0].position.set(d.x2, d.y2), n.addPoint(f);
  }
  return l > 0 ? dh(n, i, s, l) : n.addPoint(zn(0, 0)), c;
}
function sh(n, r, e, t, o, i) {
  let s = -r / e;
  for (let l = 0; l <= e; l++) {
    let c = s * l, u = Math.sin(c) * t, a = Math.cos(c) * o;
    n.addPoint(zn(u, a));
  }
  return r < ch ? i > 0 ? dh(n, t, o, i) : n.addPoint(zn(0, 0)) : (n.removePoint(n.points[n.points.length - 1]), i > 0 && uh(n, t, o, i)), 1;
}
function U_(n, r, e, t = 0, o = 0, i = 0) {
  let s = 0.5522847498, l = r * s, c = e * s;
  n.addPoint(Qa(o - r, i, o - r, i - c, o - r, i + c)), n.addPoint(Qa(o, i + e, o - l, i + e, o + l, i + e)), n.addPoint(Qa(o + r, i, o + r, i + c, o + r, i - c)), n.addPoint(Qa(o, i - e, o + l, i - e, o - l, i - e)), t > 0 && uh(n, r, e, t);
}
function zn(n, r) {
  return new Jt(MathUtils.generateUUID(), new Vector2(n, r));
}
function Qa(n, r, e, t, o, i) {
  let s = zn(n, r);
  return s.controls[0].position.set(e, t), s.controls[1].position.set(o, i), s;
}
function dh(n, r, e, t) {
  ph(n, r, e, t).forEach((i) => n.addPoint(i));
}
function uh(n, r, e, t) {
  let o = ph(n, r, e, t), i = new Se();
  o.forEach((s) => i.addPoint(s)), i.isClosed = true, n.shapeHoles.push(i);
}
function ph(n, r, e, t) {
  let o = t * r / 100, i = o * (Math.abs(e) / Math.abs(r)), s = new Vector2(o / r, i / e), l = n.points.map((c) => {
    let u = c.clone();
    return u.uuid = MathUtils.generateUUID(), u;
  }).reverse();
  return l.forEach((c) => {
    c.position.multiply(s);
    let u = c.controls[0].position.clone().multiply(s), a = c.controls[1].position.clone().multiply(s);
    c.controls[0].position.copy(a), c.controls[1].position.copy(u);
  }), l;
}
var mh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, revolutions: 2, segments: 40, pathRadius: 10, pathType: 0, pathSegments: 30, cornerRadius: 30, cornerSegments: 4 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? t), i = Math.abs(e.depth ?? t), s = Math.abs(Math.min(t, i)) / 2;
    return { parameters: Object.assign(e, { width: t, height: o, depth: i, radius: s, segments: Math.round(e.segments), pathSegments: Math.round(e.pathSegments), cornerSegments: Math.round(e.cornerSegments) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radius: o, revolutions: i, segments: s, pathRadius: l, pathType: c, pathSegments: u, cornerRadius: a, cornerSegments: d } = n.parameters, p = new Io(false, r, e, t, o, i, s, l, c, u, a, d);
    return Object.assign(p, { userData: { ...n, type: "HelixGeometry" } });
  }
};
var Io = class extends BufferGeometry {
  constructor(r = true, e = 1, t = 1, o = 1, i = 1, s = 1, l = 1, c = 1, u = 1, a = 1, d = 1, p = 1, f = false) {
    super();
    let m = r && s === 1;
    m && (p = 0), d > 100 && (d = 100);
    let h = () => new Vector3(), y = new Vector3(), g = h(), v = h(), S = h(), w, b, T, _, x, C, P, I, O = h(), A = h(), G = h(), z = h(), $ = h(), te = h(), K = h(), q = h(), k = t - 2 * c + 1e-3, R = k / s, D = Math.ceil(l * s), B = D + 1, L = k / D, F = -k / 2, W = a + 1, H = 2 * Math.PI / a, j = Math.PI / 2 / p, U = 0.01, E = Math.min((1 - d / 100) * c, c - U), oe = c - E, Y = 0, re = 2, X = p * re + re, ee = W * X / re, Z = ee + W * B, ie = W * (B + X), [ce, se, pe] = [3, 3, 2].map((He) => Array(ie * He).fill(0)), Le = [], ge = i - c;
    function Ge(He, Ct) {
      let ar = Math.PI / 2;
      C = Ct * L, I = 2 * Math.PI * (C % R) / R + ar, C += F, P = Math.sin(I) * ge, x = Math.cos(I) * ge, r ? He.set(x, P, C) : He.set(x, C, P);
    }
    Ge(y, -1e-10), Ge(g, 0), O.copy(y), Ge(y, 1);
    let Pe = y.distanceTo(g), gt = m ? 0 : oe + E, xt = Pe * D + 2 * gt, Ho = E, Gt = xt - gt;
    for (let He = 0; He <= D; He++) {
      Ge(v, He), q.subVectors(v, O).normalize(), O.copy(v), te.copy(v).setComponent(+r + 1, 0).normalize(), K.crossVectors(q, te).normalize();
      let Ct = He === 0, ar = He === D, Ag = Ct ? 3 * Math.PI / 2 : j, Ig = Ct ? Ho : Gt, Cg = Ct ? W : Z, Ng = Ct ? 0 : ie - W, Eg = q.clone().multiplyScalar(Ct ? -oe : oe).add(v), Mg = q.clone().multiplyScalar(Ct ? -1 : 1).normalize();
      for (let Nr = 0; Nr < W; Nr++) {
        let ru = Nr * H;
        if (A.addVectors(y.copy(te).multiplyScalar(c * Math.cos(ru)), g.copy(K).multiplyScalar(c * Math.sin(ru))), G.copy(A).normalize(), Ct || ar) {
          m || (Y = Ng + Nr, [0, 1, 2].forEach((vt) => {
            ce[Y * 3 + vt] = Eg.getComponent(vt), se[Y * 3 + vt] = Mg.getComponent(vt);
          }), pe[Y * 2] = +ar, pe[Y * 2 + 1] = Nr / a), g.copy(G).multiplyScalar(E), S.addVectors(v, g);
          for (let vt = 0; vt < p; vt++) {
            let zl = vt * j + Ag;
            z.addVectors(y.copy(q).multiplyScalar(oe * Math.sin(zl)), g.copy(G).multiplyScalar(oe * Math.cos(zl))), $.copy(z).normalize(), g.addVectors(S, z), z.normalize(), Y = Cg + vt * W + Nr, [0, 1, 2].forEach((Ms) => {
              ce[Y * 3 + Ms] = g.getComponent(Ms), se[Y * 3 + Ms] = $.getComponent(Ms);
            });
            let Lg = +Ct + Math.sin(zl);
            pe[Y * 2] = (Ig + oe * Lg) / xt, pe[Y * 2 + 1] = Nr / a;
          }
        }
        g.addVectors(v, A), Y = ee + He * W + Nr, [0, 1, 2].forEach((vt) => {
          ce[Y * 3 + vt] = g.getComponent(vt), se[Y * 3 + vt] = G.getComponent(vt);
        }), pe[Y * 2] = (gt + He * Pe) / xt, pe[Y * 2 + 1] = Nr / a;
      }
    }
    let Wo = B + 2 * p + re, jl = 1, [Fl, xi] = [+m, Wo - 1];
    f && (xi -= 1);
    for (let He = Fl; He <= xi - 1; He++) {
      let Ct = m && He === xi - 1;
      for (let ar = 0; ar < W - 1; ar++)
        w = He * W + ar, b = w + 1, T = (Ct ? ar : w) + W, _ = (Ct ? ar + 1 : b) + W, He === 0 ? Le.push(b, _, T) : He === Wo - 2 ? Le.push(w, b, T) : Le.push(w, b, T, b, _, T);
    }
    this.setIndex(Le), this.setAttribute("position", new Float32BufferAttribute(ce, 3)), this.setAttribute("normal", new Float32BufferAttribute(se, 3)), this.setAttribute("uv", new Float32BufferAttribute(pe, 2));
  }
};
var hh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, detail: o, corner: i, cornerSides: s } = n.parameters, l = o === 0 && i !== 0 ? new Wi(r * 0.5, i, s) : new IcosahedronGeometry(r * 0.5, o);
    return l.scale(1, e / r, t / r), Object.assign(l, { userData: { ...n, type: "IcosahedronGeometry" } });
  }
};
var Wi = class extends so {
  constructor(r = 1, e = 0.2, t = 4) {
    let o = (1 + Math.sqrt(5)) / 2, i = [-1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, 0, 0, -1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, o, 0, -1, o, 0, 1, -o, 0, -1, -o, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], l = "IcosahedronGeometry";
    super(i, s, l, r, e, t), this.type = l;
  }
  static fromJSON(r) {
    return new Wi(r.radius, r.corner, r.cornerSides);
  }
};
var yh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    var _a2;
    (((_a2 = n.parameters) == null ? void 0 : _a2.points) ?? []).forEach((t) => {
      Array.isArray(t) && (t.x = t[0], t.y = t[1]);
    });
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, segments: 64, verticalSegments: 64, points: [{ x: 0, y: -50, id: 0 }, { x: 50, y: -50, id: 1 }, { x: 50, y: 50, id: 2 }, { x: 0, y: 50, id: 3 }] }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { points: r, segments: e, verticalSegments: t } = n.parameters, o = new Shape();
    o.moveTo(r[0].x, r[0].y), o.bezierCurveTo(r[1].x, r[1].y, r[2].x, r[2].y, r[3].x, r[3].y);
    let i = new LatheGeometry(o.extractPoints(t).shape, e);
    return i.rotateZ(Math.PI), Object.assign(i, { userData: { ...n, type: "LatheGeometry" } });
  }
};
var yr = new Matrix4();
var $c = new Object3D();
var Ja = new Vector3();
var lo = class extends EventDispatcher {
  constructor() {
    super(), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  applyMatrix4(r) {
    let e = new Matrix3().getNormalMatrix(r);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      this.vertices[t].applyMatrix4(r);
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t];
      i.normal.applyMatrix3(e).normalize();
      for (let s = 0, l = i.vertexNormals.length; s < l; s++)
        i.vertexNormals[s].applyMatrix3(e).normalize();
    }
    return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
  }
  rotateX(r) {
    return yr.makeRotationX(r), this.applyMatrix4(yr), this;
  }
  rotateY(r) {
    return yr.makeRotationY(r), this.applyMatrix4(yr), this;
  }
  rotateZ(r) {
    return yr.makeRotationZ(r), this.applyMatrix4(yr), this;
  }
  translate(r, e, t) {
    return yr.makeTranslation(r, e, t), this.applyMatrix4(yr), this;
  }
  scale(r, e, t) {
    return yr.makeScale(r, e, t), this.applyMatrix4(yr), this;
  }
  lookAt(r) {
    return $c.lookAt(r), $c.updateMatrix(), this.applyMatrix4($c.matrix), this;
  }
  fromBufferGeometry(r) {
    let e = this, t = r.index !== null ? r.index : void 0, o = r.attributes;
    if (o.position === void 0)
      return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    let i = o.position, s = o.normal, l = o.color, c = o.uv, u = o.uv2;
    u !== void 0 && (this.faceVertexUvs[1] = []);
    for (let p = 0; p < i.count; p++)
      e.vertices.push(new Vector3().fromBufferAttribute(i, p)), l !== void 0 && e.colors.push(new Color().fromBufferAttribute(l, p));
    function a(p, f, m, h) {
      let y = l === void 0 ? [] : [e.colors[p].clone(), e.colors[f].clone(), e.colors[m].clone()], g = s === void 0 ? [] : [new Vector3().fromBufferAttribute(s, p), new Vector3().fromBufferAttribute(s, f), new Vector3().fromBufferAttribute(s, m)], v = new Hn(p, f, m, g, y, h);
      e.faces.push(v), c !== void 0 && e.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(c, p), new Vector2().fromBufferAttribute(c, f), new Vector2().fromBufferAttribute(c, m)]), u !== void 0 && e.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(u, p), new Vector2().fromBufferAttribute(u, f), new Vector2().fromBufferAttribute(u, m)]);
    }
    let d = r.groups;
    if (d.length > 0)
      for (let p = 0; p < d.length; p++) {
        let f = d[p], m = f.start, h = f.count;
        for (let y = m, g = m + h; y < g; y += 3)
          t !== void 0 ? a(t.getX(y), t.getX(y + 1), t.getX(y + 2), f.materialIndex) : a(y, y + 1, y + 2, f.materialIndex);
      }
    else if (t !== void 0)
      for (let p = 0; p < t.count; p += 3)
        a(t.getX(p), t.getX(p + 1), t.getX(p + 2));
    else
      for (let p = 0; p < i.count; p += 3)
        a(p, p + 1, p + 2);
    return this.computeFaceNormals(), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ja).negate(), this.translate(Ja.x, Ja.y, Ja.z), this;
  }
  normalize() {
    this.computeBoundingSphere();
    let r = this.boundingSphere.center, e = this.boundingSphere.radius, t = e === 0 ? 1 : 1 / e, o = new Matrix4();
    return o.set(t, 0, 0, -t * r.x, 0, t, 0, -t * r.y, 0, 0, t, -t * r.z, 0, 0, 0, 1), this.applyMatrix4(o), this;
  }
  computeFaceNormals() {
    let r = new Vector3(), e = new Vector3();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t], s = this.vertices[i.a], l = this.vertices[i.b], c = this.vertices[i.c];
      r.subVectors(c, l), e.subVectors(s, l), r.cross(e), r.normalize(), i.normal.copy(r);
    }
  }
  computeVertexNormals(r = true) {
    let e = new Array(this.vertices.length);
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t] = new Vector3();
    if (r) {
      let t = new Vector3(), o = new Vector3();
      for (let i = 0, s = this.faces.length; i < s; i++) {
        let l = this.faces[i], c = this.vertices[l.a], u = this.vertices[l.b], a = this.vertices[l.c];
        t.subVectors(a, u), o.subVectors(c, u), t.cross(o), e[l.a].add(t), e[l.b].add(t), e[l.c].add(t);
      }
    } else {
      this.computeFaceNormals();
      for (let t = 0, o = this.faces.length; t < o; t++) {
        let i = this.faces[t];
        e[i.a].add(i.normal), e[i.b].add(i.normal), e[i.c].add(i.normal);
      }
    }
    for (let t = 0, o = this.vertices.length; t < o; t++)
      e[t].normalize();
    for (let t = 0, o = this.faces.length; t < o; t++) {
      let i = this.faces[t], s = i.vertexNormals;
      s.length === 3 ? (s[0].copy(e[i.a]), s[1].copy(e[i.b]), s[2].copy(e[i.c])) : (s[0] = e[i.a].clone(), s[1] = e[i.b].clone(), s[2] = e[i.c].clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let r = 0, e = this.faces.length; r < e; r++) {
      let t = this.faces[r], o = t.vertexNormals;
      o.length === 3 ? (o[0].copy(t.normal), o[1].copy(t.normal), o[2].copy(t.normal)) : (o[0] = t.normal.clone(), o[1] = t.normal.clone(), o[2] = t.normal.clone());
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = true);
  }
  computeMorphNormals() {
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(), o.__originalVertexNormals || (o.__originalVertexNormals = []);
      for (let i = 0, s = o.vertexNormals.length; i < s; i++)
        o.__originalVertexNormals[i] ? o.__originalVertexNormals[i].copy(o.vertexNormals[i]) : o.__originalVertexNormals[i] = o.vertexNormals[i].clone();
    }
    let r = new lo();
    r.faces = this.faces;
    for (let e = 0, t = this.morphTargets.length; e < t; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        let i = this.morphNormals[e].faceNormals, s = this.morphNormals[e].vertexNormals;
        for (let l = 0, c = this.faces.length; l < c; l++) {
          let u = new Vector3(), a = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
          i.push(u), s.push(a);
        }
      }
      let o = this.morphNormals[e];
      r.vertices = this.morphTargets[e].vertices, r.computeFaceNormals(), r.computeVertexNormals();
      for (let i = 0, s = this.faces.length; i < s; i++) {
        let l = this.faces[i], c = o.faceNormals[i], u = o.vertexNormals[i];
        c.copy(l.normal), u.a.copy(l.vertexNormals[0]), u.b.copy(l.vertexNormals[1]), u.c.copy(l.vertexNormals[2]);
      }
    }
    for (let e = 0, t = this.faces.length; e < t; e++) {
      let o = this.faces[e];
      o.normal = o.__originalFaceNormal, o.vertexNormals = o.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(r, e, t = 0) {
    if (!(r && r.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", r);
      return;
    }
    let o, i = this.vertices.length, s = this.vertices, l = r.vertices, c = this.faces, u = r.faces, a = this.colors, d = r.colors;
    e !== void 0 && (o = new Matrix3().getNormalMatrix(e));
    for (let p = 0, f = l.length; p < f; p++) {
      let h = l[p].clone();
      e !== void 0 && h.applyMatrix4(e), s.push(h);
    }
    for (let p = 0, f = d.length; p < f; p++)
      a.push(d[p].clone());
    for (let p = 0, f = u.length; p < f; p++) {
      let m = u[p], h, y, g = m.vertexNormals, v = m.vertexColors, S = new Hn(m.a + i, m.b + i, m.c + i);
      S.normal.copy(m.normal), o !== void 0 && S.normal.applyMatrix3(o).normalize();
      for (let w = 0, b = g.length; w < b; w++)
        h = g[w].clone(), o !== void 0 && h.applyMatrix3(o).normalize(), S.vertexNormals.push(h);
      S.color.copy(m.color);
      for (let w = 0, b = v.length; w < b; w++)
        y = v[w], S.vertexColors.push(y.clone());
      S.materialIndex = m.materialIndex + t, c.push(S);
    }
    for (let p = 0, f = r.faceVertexUvs.length; p < f; p++) {
      let m = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let h = 0, y = m.length; h < y; h++) {
        let g = m[h], v = [];
        for (let S = 0, w = g.length; S < w; S++)
          v.push(g[S].clone());
        this.faceVertexUvs[p].push(v);
      }
    }
  }
  mergeMesh(r) {
    if (!(r && r.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", r);
      return;
    }
    r.matrixAutoUpdate && r.updateMatrix(), this.merge(r.geometry, r.matrix);
  }
  mergeVertices(r = 4) {
    let e = {}, t = [], o = [], i = Math.pow(10, r);
    for (let c = 0, u = this.vertices.length; c < u; c++) {
      let a = this.vertices[c], d = Math.round(a.x * i) + "_" + Math.round(a.y * i) + "_" + Math.round(a.z * i);
      e[d] === void 0 ? (e[d] = c, t.push(this.vertices[c]), o[c] = t.length - 1) : o[c] = o[e[d]];
    }
    let s = [];
    for (let c = 0, u = this.faces.length; c < u; c++) {
      let a = this.faces[c];
      a.a = o[a.a], a.b = o[a.b], a.c = o[a.c];
      let d = [a.a, a.b, a.c];
      for (let p = 0; p < 3; p++)
        if (d[p] === d[(p + 1) % 3]) {
          s.push(c);
          break;
        }
    }
    for (let c = s.length - 1; c >= 0; c--) {
      let u = s[c];
      this.faces.splice(u, 1);
      for (let a = 0, d = this.faceVertexUvs.length; a < d; a++)
        this.faceVertexUvs[a].splice(u, 1);
    }
    let l = this.vertices.length - t.length;
    return this.vertices = t, l;
  }
  setFromPoints(r) {
    this.vertices = [];
    for (let e = 0, t = r.length; e < t; e++) {
      let o = r[e];
      this.vertices.push(new Vector3(o.x, o.y, o.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    let r = this.faces, e = r.length;
    for (let c = 0; c < e; c++)
      r[c]._id = c;
    function t(c, u) {
      return c.materialIndex - u.materialIndex;
    }
    r.sort(t);
    let o = this.faceVertexUvs[0], i = this.faceVertexUvs[1], s, l;
    o && o.length === e && (s = []), i && i.length === e && (l = []);
    for (let c = 0; c < e; c++) {
      let u = r[c]._id;
      s && s.push(o[u]), l && l.push(i[u]);
    }
    s && (this.faceVertexUvs[0] = s), l && (this.faceVertexUvs[1] = l);
  }
  toJSON() {
    let r = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
    if (r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.parameters !== void 0) {
      let m = this.parameters;
      for (let h in m)
        m[h] !== void 0 && (r[h] = m[h]);
      return r;
    }
    let e = [];
    for (let m = 0; m < this.vertices.length; m++) {
      let h = this.vertices[m];
      e.push(h.x, h.y, h.z);
    }
    let t = [], o = [], i = {}, s = [], l = {}, c = [], u = {};
    for (let m = 0; m < this.faces.length; m++) {
      let h = this.faces[m], y = true, g = false, v = this.faceVertexUvs[0][m] !== void 0, S = h.normal.length() > 0, w = h.vertexNormals.length > 0, b = h.color.r !== 1 || h.color.g !== 1 || h.color.b !== 1, T = h.vertexColors.length > 0, _ = 0;
      if (_ = a(_, 0, 0), _ = a(_, 1, y), _ = a(_, 2, g), _ = a(_, 3, v), _ = a(_, 4, S), _ = a(_, 5, w), _ = a(_, 6, b), _ = a(_, 7, T), t.push(_), t.push(h.a, h.b, h.c), t.push(h.materialIndex), v) {
        let x = this.faceVertexUvs[0][m];
        t.push(f(x[0]), f(x[1]), f(x[2]));
      }
      if (S && t.push(d(h.normal)), w) {
        let x = h.vertexNormals;
        t.push(d(x[0]), d(x[1]), d(x[2]));
      }
      if (b && t.push(p(h.color)), T) {
        let x = h.vertexColors;
        t.push(p(x[0]), p(x[1]), p(x[2]));
      }
    }
    function a(m, h, y) {
      return y ? m | 1 << h : m & ~(1 << h);
    }
    function d(m) {
      let h = m.x.toString() + m.y.toString() + m.z.toString();
      return i[h] !== void 0 || (i[h] = o.length / 3, o.push(m.x, m.y, m.z)), i[h];
    }
    function p(m) {
      let h = m.r.toString() + m.g.toString() + m.b.toString();
      return l[h] !== void 0 || (l[h] = s.length, s.push(m.getHex())), l[h];
    }
    function f(m) {
      let h = m.x.toString() + m.y.toString();
      return u[h] !== void 0 || (u[h] = c.length / 2, c.push(m.x, m.y)), u[h];
    }
    return r.data = {}, r.data.vertices = e, r.data.normals = o, s.length > 0 && (r.data.colors = s), c.length > 0 && (r.data.uvs = [c]), r.data.faces = t, r;
  }
  clone() {
    return new lo().copy(this);
  }
  copy(r) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = r.name;
    let e = r.vertices;
    for (let p = 0, f = e.length; p < f; p++)
      this.vertices.push(e[p].clone());
    let t = r.colors;
    for (let p = 0, f = t.length; p < f; p++)
      this.colors.push(t[p].clone());
    let o = r.faces;
    for (let p = 0, f = o.length; p < f; p++)
      this.faces.push(o[p].clone());
    for (let p = 0, f = r.faceVertexUvs.length; p < f; p++) {
      let m = r.faceVertexUvs[p];
      this.faceVertexUvs[p] === void 0 && (this.faceVertexUvs[p] = []);
      for (let h = 0, y = m.length; h < y; h++) {
        let g = m[h], v = [];
        for (let S = 0, w = g.length; S < w; S++) {
          let b = g[S];
          v.push(b.clone());
        }
        this.faceVertexUvs[p].push(v);
      }
    }
    let i = r.morphTargets;
    for (let p = 0, f = i.length; p < f; p++) {
      let m = {};
      if (m.name = i[p].name, i[p].vertices !== void 0) {
        m.vertices = [];
        for (let h = 0, y = i[p].vertices.length; h < y; h++)
          m.vertices.push(i[p].vertices[h].clone());
      }
      if (i[p].normals !== void 0) {
        m.normals = [];
        for (let h = 0, y = i[p].normals.length; h < y; h++)
          m.normals.push(i[p].normals[h].clone());
      }
      this.morphTargets.push(m);
    }
    let s = r.morphNormals;
    for (let p = 0, f = s.length; p < f; p++) {
      let m = {};
      if (s[p].vertexNormals !== void 0) {
        m.vertexNormals = [];
        for (let h = 0, y = s[p].vertexNormals.length; h < y; h++) {
          let g = s[p].vertexNormals[h], v = {};
          v.a = g.a.clone(), v.b = g.b.clone(), v.c = g.c.clone(), m.vertexNormals.push(v);
        }
      }
      if (s[p].faceNormals !== void 0) {
        m.faceNormals = [];
        for (let h = 0, y = s[p].faceNormals.length; h < y; h++)
          m.faceNormals.push(s[p].faceNormals[h].clone());
      }
      this.morphNormals.push(m);
    }
    let l = r.skinWeights;
    for (let p = 0, f = l.length; p < f; p++)
      this.skinWeights.push(l[p].clone());
    let c = r.skinIndices;
    for (let p = 0, f = c.length; p < f; p++)
      this.skinIndices.push(c[p].clone());
    let u = r.lineDistances;
    for (let p = 0, f = u.length; p < f; p++)
      this.lineDistances.push(u[p]);
    let a = r.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    let d = r.boundingSphere;
    return d !== null && (this.boundingSphere = d.clone()), this.elementsNeedUpdate = r.elementsNeedUpdate, this.verticesNeedUpdate = r.verticesNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.lineDistancesNeedUpdate = r.lineDistancesNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, this;
  }
  toBufferGeometry() {
    let r = new Yc().fromGeometry(this), e = new BufferGeometry(), t = new Float32Array(r.vertices.length * 3);
    if (e.setAttribute("position", el.call(new BufferAttribute(t, 3), r.vertices)), r.normals.length > 0) {
      let o = new Float32Array(r.normals.length * 3);
      e.setAttribute("normal", el.call(new BufferAttribute(o, 3), r.normals));
    }
    if (r.colors.length > 0) {
      let o = new Float32Array(r.colors.length * 3);
      e.setAttribute("color", vh.call(new BufferAttribute(o, 3), r.colors));
    }
    if (r.uvs.length > 0) {
      let o = new Float32Array(r.uvs.length * 2);
      e.setAttribute("uv", bh.call(new BufferAttribute(o, 2), r.uvs));
    }
    if (r.uvs2.length > 0) {
      let o = new Float32Array(r.uvs2.length * 2);
      e.setAttribute("uv2", bh.call(new BufferAttribute(o, 2), r.uvs2));
    }
    e.groups = r.groups;
    for (let o in r.morphTargets) {
      let i = [], s = r.morphTargets[o];
      for (let l = 0, c = s.length; l < c; l++) {
        let u = s[l], a = new Float32BufferAttribute(u.data.length * 3, 3);
        a.name = u.name, i.push(el.call(a, u.data));
      }
      e.morphAttributes[o] = i;
    }
    if (r.skinIndices.length > 0) {
      let o = new Float32BufferAttribute(r.skinIndices.length * 4, 4);
      e.setAttribute("skinIndex", Sh.call(o, r.skinIndices));
    }
    if (r.skinWeights.length > 0) {
      let o = new Float32BufferAttribute(r.skinWeights.length * 4, 4);
      e.setAttribute("skinWeight", Sh.call(o, r.skinWeights));
    }
    return r.boundingSphere !== null && (e.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (e.boundingBox = r.boundingBox.clone()), e;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(r) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(r);
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  static createBufferGeometryFromObject(r) {
    let e = new BufferGeometry(), t = r.geometry;
    if (r.isPoints || r.isLine) {
      let o = new Float32BufferAttribute(t.vertices.length * 3, 3), i = new Float32BufferAttribute(t.colors.length * 3, 3);
      if (e.setAttribute("position", el.call(o, t.vertices)), e.setAttribute("color", vh.call(i, t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
        let s = new Float32BufferAttribute(t.lineDistances.length, 1);
        e.setAttribute("lineDistance", J_.call(s, t.lineDistances));
      }
      t.boundingSphere !== null && (e.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (e.boundingBox = t.boundingBox.clone());
    } else
      r.isMesh && (e = t.toBufferGeometry());
    return e;
  }
};
lo.prototype.isGeometry = true;
var Yc = class {
  constructor() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
  }
  computeGroups(r) {
    let e = [], t, o, i, s = r.faces;
    for (o = 0; o < s.length; o++) {
      let l = s[o];
      l.materialIndex !== i && (i = l.materialIndex, t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), t = { start: o * 3, materialIndex: i });
    }
    t !== void 0 && (t.count = o * 3 - t.start, e.push(t)), this.groups = e;
  }
  fromGeometry(r) {
    let e = r.faces, t = r.vertices, o = r.faceVertexUvs, i = o[0] && o[0].length > 0, s = o[1] && o[1].length > 0, l = r.morphTargets, c = l.length, u;
    if (c > 0) {
      u = [];
      for (let g = 0; g < c; g++)
        u[g] = { name: l[g].name, data: [] };
      this.morphTargets.position = u;
    }
    let a = r.morphNormals, d = a.length, p;
    if (d > 0) {
      p = [];
      for (let g = 0; g < d; g++)
        p[g] = { name: a[g].name, data: [] };
      this.morphTargets.normal = p;
    }
    let f = r.skinIndices, m = r.skinWeights, h = f.length === t.length, y = m.length === t.length;
    t.length > 0 && e.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    for (let g = 0; g < e.length; g++) {
      let v = e[g];
      this.vertices.push(t[v.a], t[v.b], t[v.c]);
      let S = v.vertexNormals;
      if (S.length === 3)
        this.normals.push(S[0], S[1], S[2]);
      else {
        let b = v.normal;
        this.normals.push(b, b, b);
      }
      let w = v.vertexColors;
      if (w.length === 3)
        this.colors.push(w[0], w[1], w[2]);
      else {
        let b = v.color;
        this.colors.push(b, b, b);
      }
      if (i === true) {
        let b = o[0][g];
        b !== void 0 ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
      }
      if (s === true) {
        let b = o[1][g];
        b !== void 0 ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
      }
      for (let b = 0; b < c; b++) {
        let T = l[b].vertices;
        u[b].data.push(T[v.a], T[v.b], T[v.c]);
      }
      for (let b = 0; b < d; b++) {
        let T = a[b].vertexNormals[g];
        p[b].data.push(T.a, T.b, T.c);
      }
      h && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), y && this.skinWeights.push(m[v.a], m[v.b], m[v.c]);
    }
    return this.computeGroups(r), this.verticesNeedUpdate = r.verticesNeedUpdate, this.normalsNeedUpdate = r.normalsNeedUpdate, this.colorsNeedUpdate = r.colorsNeedUpdate, this.uvsNeedUpdate = r.uvsNeedUpdate, this.groupsNeedUpdate = r.groupsNeedUpdate, r.boundingSphere !== null && (this.boundingSphere = r.boundingSphere.clone()), r.boundingBox !== null && (this.boundingBox = r.boundingBox.clone()), this;
  }
};
var Hn = class {
  constructor(r, e, t, o, i, s = 0) {
    this.a = r, this.b = e, this.c = t, this.normal = o && o.isVector3 ? o : new Vector3(), this.vertexNormals = Array.isArray(o) ? o : [], this.color = i && i.isColor ? i : new Color(), this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = s;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(r) {
    this.a = r.a, this.b = r.b, this.c = r.c, this.normal.copy(r.normal), this.color.copy(r.color), this.materialIndex = r.materialIndex;
    for (let e = 0, t = r.vertexNormals.length; e < t; e++)
      this.vertexNormals[e] = r.vertexNormals[e].clone();
    for (let e = 0, t = r.vertexColors.length; e < t; e++)
      this.vertexColors[e] = r.vertexColors[e].clone();
    return this;
  }
};
function J_(n) {
  return this.array.set(n), this;
}
function vh(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", t), i = new Color()), r[e++] = i.r, r[e++] = i.g, r[e++] = i.b;
  }
  return this;
}
function bh(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", t), i = new Vector2()), r[e++] = i.x, r[e++] = i.y;
  }
  return this;
}
function el(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", t), i = new Vector3()), r[e++] = i.x, r[e++] = i.y, r[e++] = i.z;
  }
  return this;
}
function Sh(n) {
  let r = this.array, e = 0;
  for (let t = 0, o = n.length; t < o; t++) {
    let i = n[t];
    i === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", t), i = new Vector4()), r[e++] = i.x, r[e++] = i.y, r[e++] = i.z, r[e++] = i.w;
  }
  return this;
}
var tT = ["a", "b", "c"];
function rT(n, r) {
  switch (r) {
    case "c":
      return n.c;
    case "b":
      return n.b;
    case "a":
    default:
      return n.a;
  }
}
function Zc(n, r, e) {
  let t = Math.min(n, r), o = Math.max(n, r), i = t + "_" + o;
  return e.get(i);
}
function Qc(n, r, e, t, o, i) {
  let s = Math.min(n, r), l = Math.max(n, r), c = s + "_" + l, u;
  if (t.has(c))
    u = t.get(c);
  else {
    let a = e[s], d = e[l];
    u = { a, b: d, newEdge: null, faces: [] }, t.set(c, u);
  }
  u.faces.push(o), i[n].edges.push(u), i[r].edges.push(u);
}
function oT(n, r, e, t) {
  let o, i, s;
  for (o = 0, i = n.length; o < i; o++)
    e[o] = { edges: [] };
  for (o = 0, i = r.length; o < i; o++)
    s = r[o], Qc(s.a, s.b, n, t, s, e), Qc(s.b, s.c, n, t, s, e), Qc(s.c, s.a, n, t, s, e);
}
function tl(n, r, e, t, o) {
  n.push(new Hn(r, e, t, void 0, void 0, o));
}
function Wn(n, r) {
  return Math.abs(r - n) / 2 + Math.min(n, r);
}
function rl(n, r, e, t) {
  n.push([r.clone(), e.clone(), t.clone()]);
}
var ol = class {
  constructor(r = 1) {
    this.subdivisions = r;
  }
  modify(r) {
    r instanceof BufferGeometry ? r = new lo().fromBufferGeometry(r) : r = r.clone(), r.mergeVertices();
    let e = this.subdivisions;
    for (; e-- > 0; )
      this._smooth(r);
    return r.computeFaceNormals(), r.computeVertexNormals(), r;
  }
  _smooth(r) {
    let e = new Vector3(), t, o, i, s, l, c = r.vertices, u = r.faces, a = r.faceVertexUvs[0], d = a !== void 0 && a.length > 0, p = [], f = /* @__PURE__ */ new Map();
    oT(c, u, p, f);
    let m = [], h, y, g, v, S, w, b;
    for (let j of Array.from(f.keys())) {
      for (y = f.get(j), g = new Vector3(), S = 3 / 8, w = 1 / 8, b = y.faces.length, b != 2 && (S = 0.5, w = 0, b != 1), g.addVectors(y.a, y.b).multiplyScalar(S), e.set(0, 0, 0), s = 0; s < b; s++) {
        for (v = y.faces[s], l = 0; l < 3 && (h = c[rT(v, tT[l])], !(h !== y.a && h !== y.b)); l++)
          ;
        h && e.add(h);
      }
      e.multiplyScalar(w), g.add(e), y.newEdge = m.length, m.push(g);
    }
    let T, _, x, C, P, I, O, A = [];
    for (o = 0, i = c.length; o < i; o++) {
      for (I = c[o], P = p[o].edges, t = P.length, t == 3 ? T = 3 / 16 : t > 3 && (T = 3 / (8 * t)), _ = 1 - t * Number(T), x = T, t <= 2 && (t == 2 ? (_ = 3 / 4, x = 1 / 8) : t == 1 || t == 0), O = I.clone().multiplyScalar(_), e.set(0, 0, 0), s = 0; s < t; s++)
        C = P[s], h = C.a !== I ? C.a : C.b, e.add(h);
      e.multiplyScalar(Number(x)), O.add(e), A.push(O);
    }
    let G = A.concat(m), z = A.length, $, te, K, q = [], k = [], R, D, B, L, F = new Vector2(), W = new Vector2(), H = new Vector2();
    for (o = 0, i = u.length; o < i; o++)
      v = u[o], $ = Number(Zc(v.a, v.b, f).newEdge) + z, te = Number(Zc(v.b, v.c, f).newEdge) + z, K = Number(Zc(v.c, v.a, f).newEdge) + z, tl(q, $, te, K, v.materialIndex), tl(q, v.a, $, K, v.materialIndex), tl(q, v.b, te, $, v.materialIndex), tl(q, v.c, K, te, v.materialIndex), d && (R = a[o], D = R[0], B = R[1], L = R[2], F.set(Wn(D.x, B.x), Wn(D.y, B.y)), W.set(Wn(B.x, L.x), Wn(B.y, L.y)), H.set(Wn(D.x, L.x), Wn(D.y, L.y)), rl(k, F, W, H), rl(k, D, F, H), rl(k, B, W, F), rl(k, L, H, W));
    r.vertices = G, r.faces = q, d && (r.faceVertexUvs[0] = k);
  }
};
var We = new Vector3();
var Oh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = n.geometry ?? (r == null ? void 0 : r.geometry) ?? new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), t;
    r === void 0 ? (e.computeBoundingBox(), e.boundingBox.getSize(We), t = { width: We.x, height: We.y, depth: We.z, subdivisions: 0 }) : t = r.parameters;
    let o = { ...t, ...n.parameters };
    return { parameters: { width: Math.abs(o.width), height: Math.abs(o.height), depth: Math.abs(o.depth), subdivisions: Math.abs(o.subdivisions) }, geometry: e };
  }
  static build(n) {
    let { width: r, height: e, depth: t, subdivisions: o } = n.parameters, i = n.geometry ?? new BufferGeometry().copy(new BoxGeometry(100, 100, 100)), s = i.userData.parameters;
    s === void 0 ? (i.computeBoundingBox(), i.boundingBox.getSize(We)) : We.set(s.width, s.height, s.depth), (r !== We.x || e !== We.y || t !== We.z) && i.scale(We.x === 0 ? 1 : r / We.x, We.y === 0 ? 1 : e / We.y, We.z === 0 ? 1 : t / We.z);
    let l = i.originalGeometry;
    return o > 0 ? (l === void 0 || (s == null ? void 0 : s.subdivisions) !== o) && (l === void 0 && (l = i), i = new ol(o).modify(l).toBufferGeometry()) : (l !== void 0 && (i = l), l = void 0, i.getAttribute("normal") === void 0 && i.computeVertexNormals()), l !== void 0 && Object.assign(i, { originalGeometry: l }), delete n.geometry, Object.assign(i, { userData: { ...n, type: "NonParametricGeometry" } });
  }
  static loadFromUrl(n, r, e) {
    new BufferGeometryLoader(e).load(n, (o) => {
      let i = this.normalizeInputs({ geometry: o });
      o.boundingBox.getSize(We);
      let s = 100 / We.x;
      Object.assign(i.parameters, { width: 100, height: We.y * s, depth: We.z * s }), r(this.build(i));
    });
  }
};
var nl = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, n.parameters);
    return { shape: n.shape && n.shape instanceof Se ? n.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, spikes: t, cornerRadius: o, depth: i, extrudeBevelSize: s, extrudeBevelSegments: l } = n.parameters, c = n.shape, u = r * 0.5, a = e * 0.5, d = 0, p = 0, f = 2 * Math.PI / t;
    for (let h = 0; h < t; h++) {
      let y = f * h, g = d + Math.sin(y) * u, v = p + Math.cos(y) * a;
      c.addPoint(c.createPoint(g, v));
    }
    c.isClosed = true;
    for (let h = 0, y = c.points.length; h < y; h++)
      c.points[h].roundness = o;
    c.roundness = o, c.update();
    let m = Tt.create({ shape: c, parameters: { roundness: o, depth: i, extrudeBevelSize: s, extrudeBevelSegments: l } });
    return Object.assign(m, { userData: { ...n, type: "PolygonGeometry" } });
  }
};
var Ah = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 4, heightSegments: 1, cornerRadius: 0, cornerSegments: 8, openEnded: false }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radialSegments: o, heightSegments: i, openEnded: s, cornerRadius: l, cornerSegments: c } = n.parameters, u = new td(r * 0.5, e, o, i, s, l, c);
    return u.scale(1, 1, t / r), Object.assign(u, { userData: { ...n, type: "PyramidGeometry" } });
  }
};
function $i(n, r, e) {
  e.x = n.x * r.x, e.y = n.y, e.z = n.x * r.y;
}
function ed(n, r, e, t, o, i) {
  let s = r.clone().sub(n), l = e.clone().sub(n), c = s.angleTo(l);
  if (s.normalize(), l.normalize(), t === o) {
    let u = s.add(l).normalize();
    i.copy(n).addScaledVector(u, t / Math.sin(c / 2));
  } else {
    let u = s.angleTo(l);
    i.copy(n), i.addScaledVector(s, o / Math.sin(u)), i.addScaledVector(l, t / Math.sin(u));
  }
}
function aT(n, r, e) {
  let t = n.clone().sub(r), o = e.clone().sub(r);
  return t.projectOnVector(o), t.add(r);
}
var td = class extends BufferGeometry {
  constructor(r = 0.5, e = 1, t = 4, o = 1, i = false, s = 0, l = 4) {
    super(), t = Math.floor(Math.max(3, t)), o = Math.floor(o), l = Math.floor(l);
    let c = [], u = [], a = [], d = [], p = 0, f = e / 2, m = Math.PI / t, h = r * Math.cos(Math.PI / t), y = 2 * Math.PI / t, g = (t - 2) * Math.PI / t, v = Math.PI - g, S = new Vector3(0, -f, 0), w = new Vector3(0, f, 0), b = new Vector2(r, -f), T = new Vector2(h, -f), _ = new Vector2(0, w.y).sub(T), x = new Vector2(0, w.y).sub(b), C = new Vector2(_.y, -_.x).normalize(), P = new Vector2(x.y, -x.x).normalize(), O = r * Math.cos(Math.PI / t) * Math.tan((Math.PI - _.angle()) / 2) - 1e-8;
    s = Math.min(s, O);
    let A;
    {
      let k = new Vector3(C.x, C.y, 0), R = new Vector3(Math.cos(y) * k.x, k.y, Math.sin(y) * k.x);
      A = k.angleTo(R);
    }
    let G = s / Math.tan((Math.PI - _.angle()) / 2), z = s / Math.tan((Math.PI - A) / 2), $ = new Vector3();
    if (!i) {
      u.push(S.x, S.y, S.z), a.push(0, -1, 0), d.push(0, 0);
      let k = p++, R = [], D = b.clone(), B = G / Math.cos(Math.PI / t);
      D.x -= B;
      for (let L = 0; L < t; L++) {
        let F = L / t * Math.PI * 2 + m, W = new Vector2(Math.sin(F), Math.cos(F));
        $i(D, W, $), u.push($.x, $.y, $.z), a.push(0, -1, 0), d.push(0, 0), R.push(p++);
      }
      for (let L = 0; L < R.length; L++)
        c.push(R[L], k, R[(L + 1) % R.length]);
    }
    let te = [];
    {
      let k = new Vector3(), R = new Vector3(), D = new Vector3(), B = new Vector3(), L = new Vector3(), F = new Vector3();
      for (let W = 0; W < t; W++) {
        let H = W / t * Math.PI * 2 + m, j = (W + 0.5) / t * Math.PI * 2 + m, U = (W + 1) / t * Math.PI * 2 + m, E = new Vector2(Math.sin(H), Math.cos(H)), oe = new Vector2(Math.sin(j), Math.cos(j)), Y = new Vector2(Math.sin(U), Math.cos(U));
        $i(b, E, R), $i(b, Y, D), $i(C, oe, k), ed(w, R, D, z, z, B), u.push(B.x, B.y, B.z), ed(R, w, D, z, G, L), u.push(L.x, L.y, L.z), ed(D, R, w, G, z, F), u.push(F.x, F.y, F.z), a.push(k.x, k.y, k.z), a.push(k.x, k.y, k.z), a.push(k.x, k.y, k.z), d.push(0, 0), d.push(0, 0), d.push(0, 0);
        let re = p++, X = p++, ee = p++;
        if (c.push(re, X, ee), s > 0) {
          {
            let ce = R.clone().add(D).multiplyScalar(0.5), se = w.clone().sub(ce).normalize(), Le = S.clone().sub(ce).normalize().add(se).normalize().multiplyScalar(-1), ge = F.clone().sub(L);
            K(ce, ge, Le, _.angle());
          }
          let Z, ie;
          {
            let ce = new Vector3();
            $i(P, Y, ce);
            let se = F.clone().add(B).multiplyScalar(0.5);
            se = aT(se, D, w);
            let pe = F.clone().sub(B);
            [Z, ie] = K(se, pe, ce, A, B.y);
          }
          {
            let ce = Z, se = ce.clone().setY(0).normalize(), pe = new Vector3(0, -1, 0), Le = se.clone().cross(pe);
            q(ce, se, pe, Le);
          }
          te.concat(ie);
          {
            let ce = _.angle(), se = Math.PI - ce, pe = w.clone();
            pe.y -= s / Math.sin(ce - Math.PI / 2);
            let Le = new Vector3(), ge = [];
            for (let Pe = 0; Pe < l; Pe++) {
              let gt = [], xt = Math.PI / 2 - se * Pe / l, Ho = Math.cos(xt), Gt = Math.sin(xt), Wo = j;
              for (let jl = 0; jl <= Pe; jl++) {
                let Fl = Math.cos(Wo), xi = Math.sin(Wo);
                k.x = Ho * xi, k.y = Gt, k.z = Ho * Fl, Le.copy(pe).addScaledVector(k, s), u.push(Le.x, Le.y, Le.z), a.push(k.x, k.y, k.z), d.push(0, 0), gt.push(p++), Wo += Math.PI * 2 / Pe / t;
              }
              ge.push(gt);
            }
            ie.reverse(), ge.push(ie);
            let Ge = ge.length - 1;
            for (let Pe = 0; Pe < Ge; Pe++) {
              let gt = ge[Pe], xt = ge[Pe + 1], Ho = gt.length - 1;
              c.push(xt[1], gt[0], xt[0]);
              for (let Gt = 1; Gt <= Ho; Gt++)
                c.push(gt[Gt], gt[Gt - 1], xt[Gt]), c.push(xt[Gt + 1], gt[Gt], xt[Gt]);
            }
          }
        }
      }
    }
    this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(u, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2));
    function K(k, R, D, B, L) {
      let F = -B / 2, W = (Math.PI - B) / 2, H = R.clone().normalize().cross(D);
      k.addScaledVector(D, -s / Math.sin(W));
      let j = new Vector3(), U = new Vector3(), E = 1, oe = p, Y = [];
      for (let re = 0; re <= l; re++) {
        let X = F + re / l * B;
        U.set(0, 0, 0), U.addScaledVector(H, Math.sin(X)), U.addScaledVector(D, Math.cos(X));
        for (let ee = 0; ee <= E; ee++) {
          let Z = ee / E - 0.5;
          if (j.copy(k), j.addScaledVector(R, Z), j.addScaledVector(U, s), L != null) {
            let ie = Math.max(0, j.y - L);
            j.addScaledVector(R, -ie / R.y);
          }
          u.push(j.x, j.y, j.z), a.push(U.x, U.y, U.z), d.push(0, 0), ee === 0 && Y.push(p), p++;
        }
      }
      for (let re = 0; re < l; re++)
        for (let X = 0; X < E; X++) {
          let ee = oe + X + (E + 1) * re, Z = ee + (E + 1), ie = Z + 1, ce = ee + 1;
          c.push(ee, Z, ce), c.push(Z, ie, ce);
        }
      return [k.clone().addScaledVector(R, 0.5), Y];
    }
    function q(k, R, D, B) {
      let L = Math.PI / 2, F = x.angle() - L, W = [], H = new Vector3(), j = new Vector3();
      for (let E = 0; E <= l; E++) {
        let oe = [], Y = E / l;
        for (let re = 0; re <= E; re++) {
          let ee = ((E ? re / E : 0) - 0.5) * v, Z = Math.cos(ee), ie = Math.sin(ee), ce = Math.atan(Math.tan(F) * Z), se = (L + ce) * Y, pe = Math.cos(se), Le = Math.sin(se);
          H.set(0, 0, 0), H.addScaledVector(R, Le * Z), H.addScaledVector(D, pe), H.addScaledVector(B, Le * ie), j.copy(k).addScaledVector(H, s), u.push(j.x, j.y, j.z), a.push(H.x, H.y, H.z), d.push(0, 0), oe.push(p++);
        }
        W.push(oe);
      }
      let U = W.length - 1;
      for (let E = 0; E < U; E++) {
        let oe = W[E], Y = W[E + 1], re = oe.length - 1;
        c.push(oe[0], Y[1], Y[0]);
        for (let X = 1; X <= re; X++)
          c.push(oe[X - 1], oe[X], Y[X]), c.push(oe[X], Y[X + 1], Y[X]);
      }
    }
  }
};
var il = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, cornerRadius: [0, 0, 0, 0], cornerType: 1, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters), t = Object.assign((r == null ? void 0 : r.ui) ?? { enabledIndieCorners: false }, n.ui);
    return { shape: n.shape && n.shape instanceof Se ? n.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }), ui: t };
  }
  static build(n) {
    let r = n.shape, { width: e, height: t, cornerRadius: o, cornerType: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } = n.parameters, u = { x: e * 0.5, y: t * 0.5 }, a = { x: -u.x, y: -u.y }, d = { x: u.x, y: u.y };
    function p(w, b, T) {
      return b > e && T > t ? Math.min(w * e / b, w * t / T) : b > e ? w * e / b : T > t ? w * t / T : w;
    }
    let f = [];
    f[0] = o[0] === 0 ? 0 : p(o[0], o[0] + o[3], o[0] + o[1]), f[1] = o[1] === 0 ? 0 : p(o[1], o[1] + o[2], o[1] + o[0]), f[2] = o[2] === 0 ? 0 : p(o[2], o[2] + o[1], o[2] + o[3]), f[3] = o[3] === 0 ? 0 : p(o[3], o[3] + o[0], o[3] + o[2]);
    let m = a.x, h = d.x, y = d.y, g = a.y;
    r.addPoint(r.createPoint(m, y)), r.addPoint(r.createPoint(h, y)), r.addPoint(r.createPoint(h, g)), r.addPoint(r.createPoint(m, g)), r.isClosed = true;
    let v = true;
    for (let w = 0, b = r.points.length; w < b; w++)
      r.points[w].roundness = f[w], w > 0 && f[w] !== f[w - 1] && (v = false);
    v && (r.roundness = f[0]), r.useCubicForRoundedCorners = i !== 1, r.update();
    let S = Tt.create({ shape: r, parameters: { depth: s, extrudeBevelSize: l, extrudeBevelSegments: c } });
    return Object.assign(S, { userData: { ...n, type: "RectangleGeometry" } });
  }
};
var Ih = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r = 100, height: e = r, depth: t = r, widthSegments: o = 64, heightSegments: i = 64, phiStart: s, phiLength: l, thetaStart: c, thetaLength: u } = n.parameters, a = new SphereGeometry(0.5 * r, o, i, s, l, c, u);
    return a.scale(1, e / r, t / r), Object.assign(a, { userData: { ...n, type: "SphereGeometry" } });
  }
};
var Ch = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, widthSegments: 8, heightSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: 0 }) };
  }
  static build(n) {
    let { width: r = 100, height: e = r, widthSegments: t = 8, heightSegments: o = 8 } = n.parameters, i = new PlaneGeometry(r, e, t, o);
    return i.scale(1, 1, 1), Object.assign(i, { userData: { ...n, type: "PlaneGeometry" } });
  }
};
var Nh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, angle: 90, cornerRadius: 24, cornerSegments: 8 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, angle: o, cornerRadius: i, cornerSegments: s } = n.parameters, l = new od(r, e, t, o, i, s);
    return Object.assign(l, { userData: { ...n, type: "BackdropGeometry" } });
  }
};
var od = class extends BufferGeometry {
  constructor(r = 1, e = 1, t = 1, o = 90, i = 10, s = 24) {
    super(), this.type = "BackdropGeometry";
    let l = [], c = [], u = [], a = 1e-3;
    i == 0 && (s = 1), s = Math.max(1, Math.floor(s)), i = Math.min(i, 100), o = Math.min(180 - a, o), o *= Math.PI / 180;
    let d = [], p = Math.PI / 2, f = (j = 0, U = 0, E = 0) => new Vector3(j, U, E), m = f(), h = f(), [y, g, v] = [e / 2, r / 2, t / 2], S = -g, w = +g, [b, T, _] = [f(S, -y, +v), f(S, -y, -v), f(S, +y, -v)], x = (j, U = false) => Math.sin(j - Math.PI / (1 + +U)), C = (j, U = false) => Math.cos(j - Math.PI / (1 + +U));
    _.y = Math.sin(o) * e - y;
    let P = Math.cos(o) * e - v, I = b.z - a;
    o <= p ? (_.z = Math.min(P, I), _.z == I && (_.y -= (P - I) / Math.tan(p - o))) : T.z = Math.min(T.z - P - v, b.z - a), m.subVectors(b, T), h.subVectors(_, T);
    let O = Math.min(m.length(), h.length()) * i / 100, A = O * Math.tan(o / 2), G = O / Math.cos(o / 2), z = m.clone().normalize().add(h.normalize()).setLength(G).add(T);
    m.set(0, x(o, true), C(o, true)), d.push([_, m.clone()]);
    let $ = (Math.PI - o) / s;
    for (let j = 0; j <= s; j++) {
      let U = p + o + j * $;
      m.set(0, Math.sin(U) * A, Math.cos(U) * A), m.add(z), h.set(0, x(U), C(U)), d.push([m.clone(), h.clone()]);
    }
    d.push([b, f(0, 1, 0)]);
    let te = Math.sin($ / 2) * A * 2, K = d.length - 1, q = d[0][0].distanceTo(d[1][0]), k = d[K - 1][0].distanceTo(d[K][0]), R = q + te * s + k;
    d[0].push(1);
    for (let j = 0; j <= s; j++)
      d[j + 1].push(1 - (q + j * te) / R);
    d[K].push(0);
    let [D, B, L] = d[0], F, W, H;
    for (let j = 1; j < d.length; j++)
      [F, W, H] = d[j], l.push(S, D.y, D.z, S, F.y, F.z, w, D.y, D.z, w, D.y, D.z, S, F.y, F.z, w, F.y, F.z), c.push(0, B.y, B.z, 0, W.y, W.z, 0, B.y, B.z, 0, B.y, B.z, 0, W.y, W.z, 0, W.y, W.z), u.push(0, L, 0, H, 1, L, 1, L, 0, H, 1, H), [D, B, L] = [F, W, H];
    this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(u, 2));
  }
};
var sl = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, innerRadiusPercent: 38.19, spikes: 5, cornerRadius: 0, angle: 360, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, n.parameters);
    return { shape: n.shape && n.shape instanceof Se ? n.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e, innerRadiusPercent: t, spikes: o, cornerRadius: i, angle: s, depth: l, extrudeBevelSize: c, extrudeBevelSegments: u } = n.parameters, a = n.shape, d = r * 0.5, p = e * 0.5, f = 0, m = 0, h = s * Math.PI / 360 / o, y = Math.PI / 2 * 3 * -1, g = d * t / 100, v = p * t / 100;
    if (o === 3 && t === 50) {
      h = 2 * Math.PI / o;
      for (let w = 0; w < o; w++) {
        let b = h * w, T = f + Math.sin(b) * d, _ = m + Math.cos(b) * p;
        a.addPoint(a.createPoint(T, _));
      }
    } else
      for (let w = 0; w < o; w++) {
        let b = f + Math.cos(y) * d, T = m + Math.sin(y) * p;
        a.addPoint(a.createPoint(b, T)), y += h, b = f + Math.cos(y) * g, T = m + Math.sin(y) * v, w <= o, a.addPoint(a.createPoint(b, T)), y += h;
      }
    a.isClosed = true;
    for (let w = 0, b = a.points.length; w < b; w++)
      a.points[w].roundness = i;
    a.roundness = i, a.update();
    let S = Tt.create({ shape: a, parameters: { roundness: i, depth: l, extrudeBevelSize: c, extrudeBevelSegments: u } });
    return Object.assign(S, { userData: { ...n, type: "StarGeometry" } });
  }
};
var Eh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r, height: e } = n.parameters, t = new PlaneGeometry(r, e);
    return Object.assign(t, { userData: { ...n, type: "TextFrameGeometry" } });
  }
};
var Mh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, radialSegments: 32, tubularSegments: 64, arc: Math.PI * 2, cornerRadius: 30, cornerSegments: 8 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.round(Math.abs(e.depth ?? e.width * 0.25));
    return { parameters: Object.assign(e, { width: t, height: o, depth: i }) };
  }
  static build(n) {
    let { width: r, height: e, depth: t, radialSegments: o, tubularSegments: i, arc: s, cornerRadius: l, cornerSegments: c } = n.parameters, u = fT(r, e, t, r * 0.5, s, i, 0, 0, o, l, c);
    return u.scale(1, e / r, 1), Object.assign(u, { userData: { ...n, type: "TorusGeometry" } });
  }
};
function fT(n, r, e, t, o, i, s, l, c, u, a) {
  return [r, e] = [e, r], s = r / 2, o /= 2 * Math.PI, o == 1 && (u = 0), new Io(true, n, r, e, t, o, i, s, l, c, u, a);
}
var Lh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, tubularSegments: 64, radialSegments: 32, p: 2, q: 3 }, n.parameters);
    return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), tube: e.tube ?? e.width * 0.125 }) };
  }
  static build(n) {
    let { width: r, tube: e, tubularSegments: t, radialSegments: o, p: i, q: s } = n.parameters, l = r * 0.5;
    l !== e && (l -= e);
    let c = new TorusKnotGeometry(l, e, t, o, i, s);
    return Object.assign(c, { userData: { ...n, type: "TorusKnotGeometry" } });
  }
};
var Bh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1, isRect: false }, n.parameters);
    return { shape: n.shape && n.shape instanceof Se ? n.shape : new Se(), parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width * (e.isRect ? 1 : Math.sqrt(3) / 2)), depth: Math.abs(e.depth ?? 0) }) };
  }
  static build(n) {
    let { width: r = 100, height: e, cornerRadius: t, depth: o, extrudeBevelSize: i, extrudeBevelSegments: s, isRect: l } = n.parameters, c = n.shape, u = r * 0.5, a = e * 0.5;
    l ? (c.addPoint(c.createPoint(-u, a)), c.addPoint(c.createPoint(u, -a)), c.addPoint(c.createPoint(-u, -a))) : (c.addPoint(c.createPoint(0, a)), c.addPoint(c.createPoint(u, -a)), c.addPoint(c.createPoint(-u, -a))), c.isClosed = true;
    for (let p = 0, f = c.points.length; p < f; p++)
      c.points[p].roundness = t;
    c.roundness = t, c.update();
    let d = Tt.create({ shape: c, parameters: { roundness: t, depth: o, extrudeBevelSize: i, extrudeBevelSegments: s } });
    return Object.assign(d, { userData: { ...n, type: "TriangleGeometry" } });
  }
};
function Dh(n, r) {
  let e = 2 * Math.PI;
  return (n % e + e) % e === (r % e + e) % e;
}
function hT(n, r, e) {
  let t = [new Vector3(), new Vector3(), new Vector3()], o = [new Vector3(), new Vector3(), new Vector3()];
  return n.extractBasis(t[0], t[1], t[2]), r.extractBasis(o[0], o[1], o[2]), t.forEach((i, s) => {
    let l = o[s], c = MathUtils.lerp(i.length(), l.length(), e);
    i.lerp(l, e).setLength(c);
  }), new Matrix4().makeBasis(t[0], t[1], t[2]);
}
var Vh = class {
  static create(n) {
    return this.build(this.normalizeInputs(n));
  }
  static normalizeInputs(n, r) {
    let e = Object.assign({}, (r == null ? void 0 : r.parameters) ?? { width: 100, height: 100, depth: 1, subdivisions: 12, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, n.parameters), t = Math.abs(e.width), o = Math.abs(e.height ?? e.width), i = Math.abs(e.depth ?? 0), s = (r == null ? void 0 : r.shapeData) ?? Un.create({ parameters: dc }).userData.shape;
    return { path: n.path ?? rn.defaultData(), parameters: Object.assign(e, { width: t, height: o, depth: i, extrusion: { ...ia, ...e.extrusion } }), shapeData: s };
  }
  static build(n) {
    if (n.path.points.length >= 2) {
      let e = new sd(n);
      return Object.assign(e, { userData: { ...n, type: "PathGeometry" } });
    } else
      return Object.assign(new BufferGeometry(), { userData: { ...n, type: "PathGeometry" } });
  }
};
var sd = class extends BufferGeometry {
  constructor(e) {
    super();
    this.type = "PathExtrusionGeometry", this.inputs = e, this.build();
  }
  _isGeometryClosed() {
    return this.inputs.path.isClosed && this.inputs.parameters.extrusion.depth === 1;
  }
  _isOpenEnded() {
    let e = this.inputs.parameters.extrusion;
    return !(this.inputs.path.isClosed && e.depth === 1) || !Dh(e.twist, 0) || e.startScale !== e.endScale;
  }
  build() {
    let e = this._extractPathPoints();
    if (e.length < 2)
      return;
    let t = this._computeBasisMatrices(e), { depth: o, offset: i } = this.inputs.parameters.extrusion, s = this.inputs.path.isClosed ? e.length : e.length - 1, l = Math.floor(i * s), c = this.inputs.path.isClosed ? Math.ceil((o + i) * s) : Math.ceil(Math.min(1, o + i) * s), u = Math.min(Math.max(2, c - l + 1), s + 2), a = [], d = [];
    for (let O = 0; O < u; O++) {
      let A = this.inputs.path.isClosed ? (O + l) % e.length : Math.min(O + l, e.length - 1);
      a.push(e[A].clone()), d.push(t[A].clone());
    }
    let p = (O, A, G) => {
      a[O] = a[O].clone().lerp(a[A], G), d[O] = hT(d[O], d[A], G);
    }, f = 0, m = i * s % 1;
    (!this.inputs.path.isClosed || o <= 1) && (m || i === 0) && (f = m, p(0, 1, f));
    let h = 0, y = (i + o) * s % 1;
    if ((this.inputs.path.isClosed && o <= 1 || !this.inputs.path.isClosed && i + o < 1) && y && (h = y, p(a.length - 1, a.length - 2, 1 - h)), o === 0) {
      let O = a.length - 1;
      a[O].copy(a[0]), d[O].copy(d[0]);
    }
    this._applyPathModifiers(d, f, h);
    let { regions: g, infos: v, vertices: S } = this._computeShapePoints(5), w = 0, b = 0;
    v.sort((O, A) => O.start - A.start), v.forEach((O) => {
      O.verticesStart = w, O.verticesCount = O.continuous.reduce((A, G, z) => A + (z === 0 || !G ? 2 : 1), 0), b += O.verticesCount, w = b;
    });
    let T = b * u, _, x = 0;
    this._isOpenEnded() && (_ = er({ windingRule: ve.ODD, elementType: De.POLYGONS, polySize: 3, vertexSize: 2, strict: true, contours: g }), x = _.vertexCount);
    let C = T + 2 * x, P = { positions: new Float32Array(C * 3), normals: new Float32Array(C * 3), uvs: new Float32Array(C * 2) }, I = [];
    v.forEach((O) => {
      this._extrudeRegion(O, S, d, a, P, I, this._isGeometryClosed() && !this._isOpenEnded());
    }), _ && (this._closeEnd(_, T, I, P, d[0], a[0], false), this._closeEnd(_, T + x, I, P, d[d.length - 1], a[a.length - 1], true)), this.setAttribute("position", new BufferAttribute(P.positions, 3)), this.setAttribute("normal", new BufferAttribute(P.normals, 3)), this.setAttribute("uv", new BufferAttribute(P.uvs, 2)), this.setIndex(I);
  }
  _extractPathPoints() {
    let t = Fa(this.inputs.path).getPoints(this.inputs.path.subdivisions);
    if (t.length < 2)
      return [];
    let o = [t[0]];
    return t.forEach((s) => {
      o[o.length - 1].distanceToSquared(s) > 1e-3 && o.push(s);
    }), this.inputs.path.isClosed && o[o.length - 1].distanceTo(o[0]) < 1e-3 && o.pop(), o;
  }
  _computeBasisMatrices(e) {
    let t = [], o = e.length, i = this.inputs.path.isClosed, s = new Vector3(), l = new Vector3(), c = new Vector3(), u = new Vector3(), a = new Vector3(0, 1, 0);
    for (let y = 0; y < o; y++) {
      let g = e[y], v;
      y === 0 ? v = i ? e[e.length - 2] : g.clone().multiplyScalar(2).sub(e[1]) : v = e[y - 1];
      let S;
      y === o - 1 ? S = i ? e[1] : g.clone().multiplyScalar(2).sub(e[y - 1]) : S = e[y + 1];
      let w = g.clone().sub(v).normalize(), b = S.clone().sub(g).normalize(), T = w.clone().add(b).normalize();
      c.copy(T), y === 0 && (T.equals(a) || T.clone().negate().equals(a)) && a.set(0, 0, 1);
      let _ = a.clone().cross(T).normalize(), x = T.clone().cross(_).normalize();
      a.copy(x), u.copy(_), y === 0 && (s.copy(x), l.copy(T));
      let C = new Matrix4().makeBasis(_, x, T);
      t.push(C);
    }
    let d = i ? l : c, p = i ? s : new Vector3(0, 1, 0), f = d.clone().cross(u).normalize(), m = Math.acos(p.dot(f));
    if (isNaN(m))
      return t;
    let h = p.clone().cross(f);
    d.dot(h) > 0 && (m *= -1);
    for (let y = 1; y < t.length; y++) {
      let g = new Matrix4().makeRotationZ(m * y / t.length);
      t[y].multiply(g);
    }
    return t;
  }
  _applyPathModifiers(e, t, o) {
    let i = e.length, { angle: s, twist: l, startScale: c, endScale: u } = this.inputs.parameters.extrusion, a = new Matrix4(), d = new Matrix4();
    return e.forEach((p, f) => {
      let m = f === 0 ? 0 : f === i - 1 ? 1 : (f - t) / (i - (o === 0 ? 0 : 1) - (t + (1 - o)));
      a.makeRotationZ(MathUtils.lerp(s, s + l, m));
      let h = MathUtils.lerp(c, u, m);
      d.makeScale(h, h, h), p.multiply(a).multiply(d);
    }), e;
  }
  _computeShapePoints(e = 12, t = ve.ODD) {
    let o = this.inputs.shapeData, i = o.extractShapePointsToFlatArray([], e), s = o.shapeHoles.map((h) => {
      let y = h.extractShapePointsToFlatArray([], e), g = [];
      for (let v = y.length - 1; v >= 1; v -= 2) {
        let S = y[v - 1], w = y[v - 0];
        g.push(S, w);
      }
      return g;
    }), l = er({ windingRule: t, elementType: De.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [i] }), c = er({ windingRule: ve.ODD, elementType: De.BOUNDARY_CONTOURS, vertexSize: 2, strict: true, contours: [...s] });
    if (!l)
      throw new Error("error generating geometry");
    let u = l.elementCount;
    if (c) {
      l.elementCount += c.elementCount;
      for (let h = 0; h < c.elements.length; h++) {
        let y = c.elements[h], g = h % 2 === 0 ? l.vertexCount : 0;
        l.elements.push(y + g);
      }
      for (let h = 0; h < c.vertexIndices.length; h++) {
        let y = c.vertexIndices[h], g = l.vertexCount;
        l.vertexIndices.push(y + g);
      }
      for (let h = 0; h < c.vertices.length; h++) {
        let y = c.vertices[h];
        l.vertices.push(y);
      }
    }
    let a = 1 / 0, d = -1 / 0, p = 1 / 0, f = -1 / 0;
    for (let h = 0, y = l.vertexCount; h < y; h++) {
      let g = h * 2, v = l.vertices[g + 0], S = l.vertices[g + 1];
      v < a && (a = v), v > d && (d = v), S < p && (p = S), S > f && (f = S);
    }
    let m = [];
    for (let h = l.elementCount - 1; h >= 0; h--) {
      let y = h >= u, g = h * 2, v = l.elements[g + 0], S = l.elements[g + 1], w = v + S, b = { start: v, count: S, normals: [], isHole: y, continuous: [], verticesStart: 0, verticesCount: 0 };
      m.push(b);
      let T = v, _ = w - 1, x = v + 1, C = o.roundedCurves.length;
      do {
        let P = T - v, I = l.vertices[_ * 2 + 0], O = l.vertices[_ * 2 + 1], A = l.vertices[T * 2 + 0], G = l.vertices[T * 2 + 1], z = l.vertices[x * 2 + 0], $ = l.vertices[x * 2 + 1], te = A - I, K = G - O, q = Math.sqrt(te * te + K * K);
        te /= q, K /= q;
        let k = A - z, R = G - $, D = Math.sqrt(k * k + R * R);
        k /= D, R /= D, b.normals[P * 2 + 0] = -R, b.normals[P * 2 + 1] = k;
        let B = l.vertexIndices[T];
        if (Array.isArray(B))
          b.continuous[P] = false;
        else {
          let [L, F] = o.getCurveIndexFromVertexId(B - 1, true);
          if (F > 0 && F < 1)
            b.continuous[P] = true;
          else {
            let W = F === 1 ? L + 1 : L - 1;
            W = (W + C) % C;
            let H = F === 1 ? 0 : 1, j = o.roundedCurves[L].getTangent(F), U = o.roundedCurves[W].getTangent(H);
            b.continuous[P] = j.dot(U) > 0.95;
          }
        }
        y && (b.normals[P * 2 + 0] *= -1, b.normals[P * 2 + 1] *= -1), [_, T, x] = [T, x, x + 1], x >= w && (x -= S);
      } while (x !== v + 1);
    }
    return { regions: [i, ...s], infos: m, vertices: l.vertices };
  }
  _insertVertex(e, t, o, i, s) {
    let l = t * 2, c = t * 3;
    e.positions[c + 0] = o.x, e.positions[c + 1] = o.y, e.positions[c + 2] = o.z, e.normals[c + 0] = i.x, e.normals[c + 1] = i.y, e.normals[c + 2] = i.z, e.uvs[l + 0] = s.x, e.uvs[l + 1] = s.y;
  }
  _extrudeRegion(e, t, o, i, s, l, c) {
    let u = new Vector3(), a = new Vector3(), d = new Vector3(), p = new Vector3(), f = new Vector2();
    o.forEach((h, y) => {
      let g = i[y], v = e.verticesStart * o.length + e.verticesCount * y;
      for (let S = 0; S < e.count; S++) {
        let w = (e.start + S) * 2;
        if (u.set(t[w + 0], t[w + 1], 0), d.copy(u).applyMatrix4(h).add(g), e.continuous[S])
          p.set(e.normals[S * 2 + 0], e.normals[S * 2 + 1], 0);
        else {
          let b = S == 0 ? (e.start + e.count - 1) * 2 : w - 2;
          a.set(t[b + 0], t[b + 1], 0), p.copy(u).sub(a), p.set(-p.y, p.x, 0), e.isHole || p.negate();
        }
        if (p.applyMatrix4(h).normalize(), f.set(S === 0 ? 1 : S / e.count, y / (o.length - 1)), this._insertVertex(s, v, d, p, f), v++, !e.continuous[S] || S === 0) {
          if (S === 0)
            p.set(e.normals[S * 2 + 0], e.normals[S * 2 + 1], 0), f.set(0, y / (o.length - 1));
          else {
            let b = S === e.count - 1 ? e.start * 2 : w + 2;
            a.set(t[b + 0], t[b + 1], 0), p.copy(a).sub(u), p.set(-p.y, p.x, 0), e.isHole || p.negate();
          }
          p.applyMatrix4(h).normalize(), this._insertVertex(s, v, d, p, f), v++;
        }
      }
    });
    let m = o.length - 1;
    for (let h = 0; h < m; h++) {
      let y = e.verticesStart * o.length + e.verticesCount * h, g = e.verticesStart * o.length + e.verticesCount * (h + 1), v = 0;
      for (let S = 0; S < e.count; S++) {
        (!e.continuous[S] || S === 0) && v++;
        let w = S === e.count - 1 ? 0 : v + 1, b = y + v, T = y + w, _ = g + w, x = g + v;
        e.isHole ? l.push(b, _, T, b, x, _) : l.push(b, T, _, b, _, x), v++;
      }
    }
  }
  _closeEnd(e, t, o, i, s, l, c) {
    let u = e.vertexCount, a = new Vector3(0, 0, c ? -1 : 1).applyMatrix4(s), d = new Vector3(), p = new Vector2();
    for (let m = 0; m < u; m++) {
      let h = 2 * m;
      d.set(e.vertices[h + 0], e.vertices[h + 1], 0).applyMatrix4(s).add(l), this._insertVertex(i, t + m, d, a, p);
    }
    let f = e.elements;
    for (let m = 0; m < e.elementCount; m++) {
      let h = 3 * m, y = f[h + 0] + t, g = f[h + (c ? 1 : 2)] + t, v = f[h + (c ? 2 : 1)] + t;
      o.push(y, g, v);
    }
  }
};
function gT() {
  let n = new BufferGeometry();
  return n.setAttribute("position", new BufferAttribute(new Float32Array([]), 3)), n.setIndex(new BufferAttribute(new Uint16Array([]), 1)), n;
}
var xT = 12;
var vT = 1;
var qn = class extends BufferGeometry {
  constructor(e, t) {
    super();
    this.charWidths = [];
    this.charCoords = [];
    this.wrappedText = [];
    this.isLowResolution = false;
    this.vectorShapes = [];
    this.userData = { parameters: e, type: "TextGeometry" };
    let o = t.getFont(e.font);
    (o == null ? void 0 : o.isLoaded) ? (this.font = o, this.update(e)) : this.updateFont(e.font, t).then(() => {
      this.update(e), t == null ? void 0 : t.requestRender();
    });
  }
  async updateFont(e, t) {
    let o = t.getFont(e);
    o && (this.font = o, await o.loadingPromise);
  }
  update(e) {
    let t = this.font;
    if (this.userData = { parameters: e, type: "TextGeometry" }, !(t == null ? void 0 : t.isLoaded)) {
      console.warn("Cannot update text because its font is not loaded");
      return;
    }
    let { width: o, height: i, depth: s, extrudeBevelSize: l, extrudeBevelSegments: c, text: u, textTransform: a } = e, d = a === 2 ? u.toUpperCase() : a === 3 ? u.toLowerCase() : u, p = bT(e, t, d), { shapes: f, charWidths: m, charCoords: h } = t.generateShapes(p, e), y = o * 0.5, g = i * 0.5, v = f.map((b) => new Se().fromShape(b));
    this.vectorShapes = v;
    let S = v.map((b) => Tt.create({ shape: b, parameters: { depth: s, extrudeBevelSegments: c, extrudeBevelSize: l, windingRule: s <= 0 ? ve.NONZERO : ve.ODD, subdivisions: this.isLowResolution && s > 0 ? vT : xT } })), w = S.length ? mergeBufferGeometries(S) : gT();
    w.translate(-y, g, 0), this.dispose(), this.wrappedText = p, this.charCoords = h, this.charWidths = m, this.deleteAttribute("extrudeNormal"), Object.entries(w.attributes).forEach(([b, T]) => {
      this.setAttribute(b, T);
    }), this.setIndex(w.index), this.computeBoundingSphere();
  }
  clone() {
    let e = Lr(new BufferGeometry(), qn.prototype);
    return e.copy(this), console.log("CloneGeometry", this, e), e;
  }
  copy(e) {
    return Object.entries(e.attributes).forEach(([t, o]) => {
      this.setAttribute(t, o);
    }), this.setIndex(e.index), this.userData = { parameters: { ...e.userData.parameters }, type: "TextGeometry" }, this;
  }
  async setText(e) {
    this.font && await this.font.loadingPromise, await this.update({ ...this.userData.parameters, text: e });
  }
  get text() {
    return this.userData.parameters.text ?? "";
  }
};
function bT(n, r, e) {
  e = e ?? n.text;
  let t = [""], o = "";
  for (let i of e)
    o += i, i === " " || i === `
` ? (t[t.length - 1] += o, o = "", i === `
` && t.push("")) : r.getTextWidth(t[t.length - 1] + o, n) > n.width && (t[t.length - 1].length && t.push(""), r.getTextWidth(t[t.length - 1] + o, n) > n.width && (o.length === 1 ? (t[t.length - 1] += o, o = "") : (t[t.length - 1] += o.slice(0, -1), o = o[o.length - 1], t.push(""))));
  return t[t.length - 1] += o, t;
}
var zh;
var Yn = new Promise((n) => {
  zh = n;
});
var Fh = false;
async function Uh() {
  if (Fh)
    return;
  let r = false ? "." : "https://unpkg.com/@splinetool/modelling-wasm@0.9.269/build", [e, t] = await Promise.all([import("./process-T6PFDORN.js"), fetch(`${r}/process.wasm`).then((s) => s.arrayBuffer())]), o = e.default, i = await o({ wasmBinary: t });
  zh(i), Fh = true;
}
function Co(n, r, e) {
  let t = { parameters: n, type: n.type };
  if (n.type === "PathGeometry")
    t.path = n.path;
  else if (n.type === "VectorGeometry") {
    let i = Se.createFromState(n.shape, n.width, n.height);
    t.shape = i;
  } else if (n.type === "NonParametricGeometry")
    n.data.groups && n.data.groups.forEach((i) => i.materialIndex = Math.max(i.materialIndex ?? 0, 0)), t.geometry = new BufferGeometryLoader().parse(n);
  else {
    if (n.type === "SubdivGeometry")
      return new Fe(n, e);
    if (n.type === "TextGeometry")
      return new qn(n, r);
  }
  let o;
  try {
    o = ld(t);
  } catch (i) {
    console.error(i);
  }
  if (!o) {
    let i = Se.createFromState(tn.defaultData(), 100, 100);
    t.shape = i, o = ld(t);
  }
  return o;
}
var _T = new Matrix4();
function Xi(n, r, e, t) {
  let o = n.position.array, i = n.normal.array, s = _T.makeScale(r, e, t).invert().elements, l, c, u;
  for (var a = 0, d = o.length; a < d; a += 3)
    o[a] *= r, o[a + 1] *= e, o[a + 2] *= t, l = i[a], c = i[a + 1], u = i[a + 2], i[a] = s[0] * l + s[4] * c + s[8] * u, i[a + 1] = s[1] * l + s[5] * c + s[9] * u, i[a + 2] = s[2] * l + s[6] * c + s[10] * u;
  n.position.needsUpdate = true, n.normal.needsUpdate = true;
}
var al = new Box3();
var Xn = new Vector3();
var de;
Yn.then((n) => {
  de = n;
});
var Hh = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]);
var Wh = new Uint32Array([0, 1, 2, 3]);
var qh = new Uint8Array([4]);
var Fe = class extends BufferGeometry {
  constructor(e, t) {
    super();
    this.data = e;
    this.flatShading = t;
    this.subdivPointer = 0;
    this.rebuild(), this.freeSubdivPointer();
  }
  mutateDirectlyScaleBaked(e, t) {
    this.freeSubdivPointer();
    let o = this.data.scaleBaked, i = Kr.div(t, o);
    this.subdividedGeometry && Xi(this.subdividedGeometry.attributes, ...i), this.originalGeometry && Xi(this.originalGeometry.attributes, ...i), this.data = e;
    let s = this.userData.parameters;
    this.userData.parameters = { width: s.width * i[0], height: s.height * i[1], depth: s.depth * i[2] }, this.originalGeometry.boundingSphere.center.multiply(Xn.fromArray(i));
    let l = Xn.set(s.width, s.height, s.depth).length();
    this.originalGeometry.boundingSphere.radius = l / 2;
  }
  ensureSubdivPointer() {
    return this.subdivPointer === 0 && this.rebuild(), this.subdivPointer;
  }
  rebuild() {
    let e, t, o;
    try {
      ({ originalGeometry: e, subdividedGeometry: t, subdivPointer: o } = Fe.build(this.data, void 0, !this.flatShading, void 0));
    } catch {
      e = new BoxGeometry(100, 100, 100), o = 0;
    }
    this.subdivPointer = o, this.originalGeometry = e, this.subdividedGeometry = t ?? void 0;
    let i = this.subdividedGeometry ?? this.originalGeometry;
    Object.assign(this, i), this.calcBoundingBox();
  }
  freeSubdivPointer() {
    this.subdivPointer && (Fe.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0);
  }
  dispose() {
    super.dispose(), this.freeSubdivPointer();
  }
  calcBoundingBox() {
    let e = this.originalGeometry;
    e.boundingSphere === null && (e.boundingSphere = new Sphere(), this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere));
    let t = e.attributes.position, o = e.boundingSphere.center;
    al.setFromBufferAttribute(t), al.getCenter(o), e.boundingSphere.radius = o.distanceTo(al.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), al.getSize(Xn);
    let i = { width: Xn.x, height: Xn.y, depth: Xn.z };
    return this.userData.parameters = i, i;
  }
  static build(e, t, o, i) {
    let s, l, c, u = (e == null ? void 0 : e.phongAngle) ?? 35;
    o === false && (u = -1), t && (de.free_bvh(t), de.free_subdivision_surface(t));
    try {
      s = Fe.allocate(e, i);
    } catch (a) {
      console.error(a, e), s = Fe.allocate({ positionWASM: Hh, indexWASM: Wh, verticesPerFaceWASM: qh }, i);
    }
    if (de.set_destination_refinement_level(s, 0), l = Fe.buildLevel(s, true, u), e.subdivisions > 0)
      try {
        de.set_destination_refinement_level(s, e.subdivisions), c = Fe.buildLevel(s, false, u);
      } catch {
        try {
          de.set_destination_refinement_level(s, e.subdivisions - 1), c = Fe.buildLevel(s, false, u);
        } catch {
          c = null;
        }
      }
    else
      c = null;
    return { subdivPointer: s, originalGeometry: l, subdividedGeometry: c };
  }
  static primitiveToQuads(e, t, o) {
    e.widthSegments > 16 && (e.widthSegments = 16), e.heightSegments > 16 && (e.heightSegments = 16), e.depthSegments > 16 && (e.depthSegments = 16), e.radialSegments > 16 && (e.radialSegments = 16), e.type === "DodecahedronGeometry" && (e.detail = 0);
    let i;
    if (e.type === "TorusGeometry" && e.arc === Math.PI * 2) {
      let { width: d, height: p, depth: f, arc: m, tubularSegments: h, radialSegments: y } = e;
      i = new Io(true, d, f, p, d * 0.5, m / (2 * Math.PI), h, f / 2, 0, y, 0, 0, true);
    } else
      i = e.shape !== void 0 ? t.geometry : Co(e, o, false);
    let s, l, c, u;
    ({ positions: s, triIndices: u } = hd(i.getAttribute("position"), i.getIndex()));
    let a;
    if (e.type === "CylinderGeometry" && e.cornerRadius === 0 && e.hollow === 0 && e.openEnded === false) {
      let d = e.radialSegments * e.heightSegments * 3 * 2, p = d + e.radialSegments * 3;
      a = [d, p];
    }
    return { indices: l, verticesPerFace: c } = yd(s, u, i, a), { positions: s, indices: l, verticesPerFace: c };
  }
  static allocate(e, t) {
    var _a2;
    let o, i, s, l = [], c = [];
    e.positionWASM && e.positionWASM.length > 0 ? (o = e.positionWASM, i = e.indexWASM, s = e.verticesPerFaceWASM) : (o = Hh, i = Wh, s = qh);
    let u = o.length, a = i.length, d = s.length, p = o.length + l.length + c.length, f = i.length + s.length, m = p * Float32Array.BYTES_PER_ELEMENT + f * Uint32Array.BYTES_PER_ELEMENT, h = p * Float32Array.BYTES_PER_ELEMENT, y = f * Uint32Array.BYTES_PER_ELEMENT, g = de._malloc(m), v = new Float32Array(de.HEAPF32.buffer, g, p), S = new Uint32Array(de.HEAPU32.buffer, g + h, f);
    v.set(o, 0), v.set(l, o.length), v.set(c, o.length + l.length), S.set(i, 0), S.set(s, i.length);
    let w;
    ((_a2 = e == null ? void 0 : e.scaleBaked) == null ? void 0 : _a2.some((T) => T !== 1)) && (w = new Matrix4().makeScale(...e.scaleBaked)), t && (w ? w.premultiply(t) : w = t);
    let b = w ? de.alloc_subdivision_surface2(g, u, g + h, a, g + h + i.length * Uint32Array.BYTES_PER_ELEMENT, d, w.elements) : de.alloc_subdivision_surface(g, u, g + h, a, g + h + i.length * Uint32Array.BYTES_PER_ELEMENT, d);
    return de._free(g), b;
  }
  static buildLevel(e, t, o, i, s) {
    let l = s ? de.get_mesh_data2(e, t ? de.Level.CONTROL : de.Level.REFINED, o, s.elements) : de.get_mesh_data(e, t ? de.Level.CONTROL : de.Level.REFINED, o), c = 8, u = de.HEAPU32.subarray(l >> 2, (l >> 2) + c), a = u.subarray(4, 4 + 4), d = 0, p = de.HEAPU32[u[d] >> 2], f = de.HEAPF32.subarray(p >> 2, (p >> 2) + a[d]);
    d++;
    let m = de.HEAPU32[u[d] >> 2], h = de.HEAPF32.subarray(m >> 2, (m >> 2) + a[d]);
    d++;
    let y = de.HEAPU32[u[d] >> 2], g = de.HEAPU32.subarray(y >> 2, (y >> 2) + a[d]);
    d++;
    let v = de.HEAPU32[u[d] >> 2], S = de.HEAPU32.subarray(v >> 2, (v >> 2) + a[d]);
    if (d++, i === void 0) {
      let w = new BufferGeometry();
      if (w.setIndex(new Uint32BufferAttribute(S, 1)), w.setAttribute("position", new Float32BufferAttribute(f, 3)), w.setAttribute("normal", new Float32BufferAttribute(h, 3)), t) {
        w.setAttribute("faceMap", new Uint32BufferAttribute(g, 1));
        let b = new Float32Array(h.length / 3 * 4).fill(0);
        w.setAttribute("color", new BufferAttribute(b, 4));
      }
      return de.free_mesh_data(l), w.userData.type = "SubdivGeometry", w;
    }
    i.getAttribute("position").copyArray(f), i.getAttribute("normal").copyArray(h), i.attributes.position.needsUpdate = true, i.attributes.normal.needsUpdate = true, de.free_mesh_data(l);
  }
  static freeSubdivPointer(e) {
    de.free_bvh(e), de.free_subdivision_surface(e);
  }
  static buildControlCageWireframe(e, t, o) {
    let i = de.get_wireframe_data_for_base_level(e), s = 4, l = de.HEAPU32.subarray(i >> 2, (i >> 2) + s), c = l.subarray(2, 2 + 2), u = 0, a = de.HEAPU32[l[u] >> 2], d = de.HEAPF32.subarray(a >> 2, (a >> 2) + c[u]);
    u++;
    let p = de.HEAPU32[l[u] >> 2], f = de.HEAPU32.subarray(p >> 2, (p >> 2) + c[u]);
    if (t === void 0) {
      let m = new BufferGeometry();
      m.setAttribute("position", new Float32BufferAttribute(d, 3));
      let h = new Float32Array(d.length);
      for (let y = 0, g = d.length; y < g; )
        h[y++] = o.r, h[y++] = o.g, h[y++] = o.b;
      return m.setAttribute("color", new BufferAttribute(h, 3)), m.setIndex(new Uint32BufferAttribute(f, 1)), de.free_wireframe_data_for_base_level(i), m;
    }
    t.getAttribute("position").copyArray(d), t.attributes.position.needsUpdate = true, de.free_wireframe_data_for_base_level(i);
  }
  static updateCollabMesh(e, t, o) {
    let i = t === 0;
    i || de.set_destination_refinement_level(e, t);
    let s = o ? de.get_topological_data2(e, i ? de.Level.CONTROL : de.Level.REFINED, o.elements) : de.get_topological_data(e, i ? de.Level.CONTROL : de.Level.REFINED), l = 6, c = de.HEAPU32.subarray(s >> 2, (s >> 2) + l), u = c.subarray(3, 3 + 3), a = 0, d = de.HEAPU32[c[a] >> 2], p = new Float32Array(de.HEAPF32.subarray(d >> 2, (d >> 2) + u[a]));
    a++;
    let f = de.HEAPU32[c[a] >> 2], m = new Uint32Array(de.HEAPU32.subarray(f >> 2, (f >> 2) + u[a]));
    a++;
    let h = de.HEAPU32[c[a] >> 2], y = new Uint8Array(de.HEAPU32.subarray(h >> 2, (h >> 2) + u[a]));
    return de.free_topological_data(s), { positions: p, indices: m, verticesPerFace: y };
  }
};
var $h = ["getX", "getY", "getZ"];
function hd(n, r) {
  let e = {}, t = r ? r.count : n.count, o = 0, i = [], s = [], l = 1e4;
  for (let u = 0; u < t; u++) {
    let a = r ? r.getX(u) : u, d = "";
    for (let p = 0; p < 3; p++)
      d += `${~~(n[$h[p]](a) * l)},`;
    if (d in e)
      i.push(e[d]);
    else {
      for (let p = 0; p < 3; p++)
        s.push(n[$h[p]](a));
      e[d] = o, i.push(o), o++;
    }
  }
  let c = [];
  for (let u = 0; u < i.length; u += 3)
    i[u] === i[u + 1] || i[u] === i[u + 2] || i[u + 1] === i[u + 2] || c.push(i[u], i[u + 1], i[u + 2]);
  return { positions: s, triIndices: c };
}
var ll = new Vector3();
var pd = new Vector3();
var fd = new Vector3();
var md = new Vector3();
function yd(n, r, e, t) {
  let o = [], i = [];
  if (e.userData.shape !== void 0 && e.userData.parameters.depth === 0 && e.userData.shape.shapeHoles.length === 0) {
    let s = e.userData.shape.extractShapePointsToFlatArray([]), l = e.userData.parameters.spikes;
    if (e.userData.type === "EllipseGeometry" && l <= 24 && l % 4 === 0 && e.userData.parameters.angle >= 360) {
      let a = s.length / 2 / l;
      s = s.filter((d, p) => Math.floor(p / 2) % a === 0);
    }
    let c = 0;
    for (let a = 0; a < s.length; a += 2)
      c += (s[a] - s[(a === 0 ? s.length : a) - 2]) * (s[a + 1] + s[(a === 0 ? s.length : a) - 1]);
    n.length = 0;
    let u = 0;
    if (c < 0)
      for (let a = 0; a < s.length; a += 2)
        n.push(s[a], s[a + 1], 0), o.push(u++);
    else
      for (let a = s.length - 2; a >= 0; a -= 2)
        n.push(s[a], s[a + 1], 0), o.push(u++);
    return i.push(u), { indices: o, verticesPerFace: i };
  }
  for (let s = 0, l = e.capStartIndex ?? r.length; s < l; )
    if (r[s + 1] === r[s + 3] && r[s + 2] === r[s + 5] || r[s + 0] === r[s + 3] && r[s + 2] === r[s + 4]) {
      ll.set(n[r[s] * 3], n[r[s] * 3 + 1], n[r[s] * 3 + 2]), pd.set(n[r[s + 1] * 3], n[r[s + 1] * 3 + 1], n[r[s + 1] * 3 + 2]), fd.set(n[r[s + 4] * 3], n[r[s + 4] * 3 + 1], n[r[s + 4] * 3 + 2]), md.set(n[r[s + 5] * 3], n[r[s + 5] * 3 + 1], n[r[s + 5] * 3 + 2]), pd.sub(ll).normalize(), fd.sub(ll).normalize(), md.sub(ll).normalize();
      let c = pd.cross(fd).dot(md);
      Math.abs(c) > 5e-3 || t && t.some((u, a) => a % 2 === 1 ? false : s >= t[a] && s < t[a + 1]) ? (o.push(r[s], r[s + 1], r[s + 2]), i.push(3), s += 3) : (o.push(r[s], r[s + 1], r[s + 4], r[s + 5]), i.push(4), s += 6);
    } else
      o.push(r[s], r[s + 1], r[s + 2]), i.push(3), s += 3;
  if (e.capStartIndex !== void 0) {
    let s = [], l = [], c = 0, u = new Float32Array([e.userData.parameters.depth])[0];
    for (let a = 0, d = 0; a < n.length; a += 3, d++)
      n[a + 2] === 0 && (s.push(d), c++), n[a + 2] === u && l.push(d);
    if (e.userData.parameters.extrudeBevelSize === 0) {
      let a = l[0];
      l[0] = l[1], l[1] = a;
    }
    s.reverse(), o.push(...s, ...l), i.push(c, c);
  }
  return { indices: o, verticesPerFace: i };
}
var tr = {};
jg(tr, { calcBoolean: () => MT, calcBooleanTopological: () => ET, freeMeshSet: () => DT, getMeshSet: () => LT, transformMeshSet: () => BT });
var IT;
var Yh = new Promise((n) => {
  IT = n;
});
var ye;
var Kn;
Yh.then((n) => ye = n);
function NT(n, r, e) {
  let t, { positions: o, triIndices: i } = hd(n.getAttribute("position"), n.getIndex()), s;
  if (r && e) {
    let { indices: l, verticesPerFace: c } = yd(o, i, n);
    s = c.length, t = [];
    for (let u = 0, a = 0; u < s; u++) {
      t.push(c[u]);
      for (let d = 0; d < c[u]; d++)
        t.push(l[a++]);
    }
  } else {
    let l = i.length;
    t = Array(l + l / 3), s = 0;
    for (let c = 0, u = 0; u < t.length; )
      t[u++] = 3, s++, t[u++] = i[c++], t[u++] = i[c++], t[u++] = i[c++];
  }
  return { positions: o, faceIndices: t, nFaces: s };
}
function Kh(n) {
  let r = n.length, e = r * Uint32Array.BYTES_PER_ELEMENT, t = r * Float32Array.BYTES_PER_ELEMENT, o = Number.isInteger(n[0]) ? e : t, i = ye._malloc(o);
  return (Number.isInteger(n[0]) ? new Uint32Array(ye.HEAPU32.buffer, i, r) : new Float32Array(ye.HEAPF32.buffer, i, r)).set(n, 0), i;
}
function Zh(n) {
  switch (n) {
    case 0:
      return ye.OP.UNION;
    case 1:
      return ye.OP.INTERSECTION;
    case 2:
      return ye.OP.A_MINUS_B;
    case 3:
      return ye.OP.B_MINUS_A;
    case 4:
      return ye.OP.SYMMETRIC_DIFFERENCE;
    case 5:
      return ye.OP.ALL;
    default:
      throw new Error("Unknown boolean operation " + n);
  }
}
function ET(n, r) {
  Kn === void 0 && (Kn = ye.init_csg());
  let e = Kh(n), t = ye.csg_calc_topological(Kn, e, n.length, Zh(r));
  ye._free(e);
  let o = 6, i = ye.HEAPU32.subarray(t >> 2, (t >> 2) + o), s = i.subarray(3, 3 + 3), l = 0, c = ye.HEAPU32[i[l] >> 2], u = new Float32Array(ye.HEAPF32.subarray(c >> 2, (c >> 2) + s[l]));
  l++;
  let a = ye.HEAPU32[i[l] >> 2], d = new Uint32Array(ye.HEAPU32.subarray(a >> 2, (a >> 2) + s[l]));
  l++;
  let p = ye.HEAPU32[i[l] >> 2], f = new Uint8Array(ye.HEAPU32.subarray(p >> 2, (p >> 2) + s[l]));
  return ye.free_mesh_data(t), { positions: u, indices: d, verticesPerFace: f };
}
function MT(n, r, e, t) {
  Kn === void 0 && (Kn = ye.init_csg());
  let o = Kh(n), i = ye.csg_calc(Kn, o, n.length, t, Zh(r));
  ye._free(o);
  let s = 5, l = ye.HEAPU32.subarray(i >> 2, (i >> 2) + s), c = l.subarray(2, 2 + 3), u = 0, a = ye.HEAPU32[l[u] >> 2], d = ye.HEAPF32.subarray(a >> 2, (a >> 2) + c[u]);
  u++;
  let p = ye.HEAPU32[l[u] >> 2], f = ye.HEAPF32.subarray(p >> 2, (p >> 2) + c[u]);
  u++;
  let m = c[u];
  e.setAttribute("position", new Float32BufferAttribute(d, 3)), e.setAttribute("normal", new Float32BufferAttribute(f, 3));
  let h = ye.HEAPF32.subarray((i >> 2) + 5, (i >> 2) + 5 + 6);
  return e.boundingSphere === null && (e.boundingSphere = new Sphere()), e.boundingSphere.center.set(h[0], h[1], h[2]), e.boundingSphere.radius = (h[3] ** 2 + h[4] ** 2 + h[5] ** 2) ** 0.5, e.userData.parameters = { width: h[3] * 2, height: h[4] * 2, depth: h[5] * 2 }, ye.free_mesh_data(i), m;
}
function LT(n, r, e) {
  if (ye === void 0)
    return -1;
  let t, o, i;
  if (r && n.userData.positions !== void 0) {
    let y = n.userData;
    i = y.verticesPerFace.length, t = y.positions, o = Array(y.verticesPerFace.reduce((g, v) => g + v, 0) + i);
    for (let g = 0, v = 0, S = 0; g < y.verticesPerFace.length; g++) {
      o[S++] = y.verticesPerFace[g];
      for (let w = 0; w < y.verticesPerFace[g]; w++)
        o[S++] = y.indices[v++];
    }
  } else
    ({ positions: t, faceIndices: o, nFaces: i } = NT(n, r, e));
  let s = t.length, l = o.length, c = t.length, u = o.length, a = c * Float32Array.BYTES_PER_ELEMENT + u * Uint32Array.BYTES_PER_ELEMENT, d = c * Float32Array.BYTES_PER_ELEMENT, p = u * Uint32Array.BYTES_PER_ELEMENT, f = ye._malloc(a), m = new Float32Array(ye.HEAPF32.buffer, f, c), h = new Uint32Array(ye.HEAPU32.buffer, f + d, u);
  return m.set(t, 0), h.set(o, 0), ye.get_csg_mesh(f, s, f + d, l, i);
}
function BT(n, r) {
  ye.transform_csg_mesh(n, r.elements);
}
function DT(n) {
  ye.free_csg_mesh(n);
}
var GT = { ConeGeometry: Dm, CubeGeometry: Gm, CylinderGeometry: Bm, DodecahedronGeometry: Rm, EllipseGeometry: Un, HelixGeometry: mh, IcosahedronGeometry: hh, LatheGeometry: yh, NonParametricGeometry: Oh, PolygonGeometry: nl, PyramidGeometry: Ah, RectangleGeometry: il, SphereGeometry: Ih, PlaneGeometry: Ch, BackdropGeometry: Nh, StarGeometry: sl, TextFrameGeometry: Eh, TorusGeometry: Mh, TorusKnotGeometry: Lh, TriangleGeometry: Bh, PathGeometry: Vh, VectorGeometry: Tt };
var ld = (n) => GT[n.type].create(n);
function Zi(n) {
  return n !== null && "booleanOp" in n;
}
var Zn = class extends Ua(Mesh) {
  constructor() {
    super(...arguments);
    this.booleanMeshSetAddress = -1;
    this.booleanWasTransformed = false;
    this.booleanMatrixInvOld = new Matrix4();
  }
  updateVisible() {
    super.updateVisible(), this.visible = !Zi(this.parent) && this.visible, Zi(this.parent) && this.parent.invalidateDownstreamBooleanData();
  }
  freeBooleanPointer() {
    this.booleanMeshSetAddress !== -1 && (tr.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1);
  }
  invalidateDownstreamBooleanData(e = false) {
    return e ? this.booleanWasTransformed = true : this.freeBooleanPointer(), Zi(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this;
  }
  invalidateUpstreamBooleanData() {
    this.freeBooleanPointer();
    for (let e of this.children)
      e instanceof Zn && (e.freeBooleanPointer(), Zi(e) && e.invalidateUpstreamBooleanData());
  }
  updateTransformState(e) {
    let t = super.updateTransformState(e);
    return t && Zi(this.parent) && this.invalidateDownstreamBooleanData(true), t;
  }
};
var cl = new Box3();
function Qi(n, r = 0, e = n.count, t, o) {
  let i = 1 / 0, s = 1 / 0, l = 1 / 0, c = -1 / 0, u = -1 / 0, a = -1 / 0;
  for (let d = r; d < e; d++) {
    let p = n.getX(d), f = n.getY(d), m = n.getZ(d);
    p < i && (i = p), f < s && (s = f), m < l && (l = m), p > c && (c = p), f > u && (u = f), m > a && (a = m);
  }
  cl.min.set(i, s, l), cl.max.set(c, u, a), cl.getCenter(t), cl.getSize(o).multiplyScalar(0.5);
}
var UT = new BufferGeometry();
var kT = new MeshBasicMaterial();
var it = class extends Zn {
  constructor(r, e) {
    super(UT, kT), this.super_Entity(r, e);
  }
  updateState(r, e) {
    this.updateState_Entity(r, e);
  }
  updateEntityBoxSize(r, e) {
    let t = this.geometry.getAttribute("position");
    t !== void 0 ? Qi(t, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : t.count, r, e) : super.updateEntityBoxSize(r, e);
  }
};
var Ji = class {
  constructor(r) {
    r = r ?? {}, this.name = r.name, this.type = r.type, this.node = r.node, this.size = r.size, this.needsUpdate = r.needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(r) {
    this.node.value = r;
  }
};
var Je = class {
  constructor(r) {
    this.hashProperties = void 0;
    this.isNode = true;
    this.shortcuts = {};
    this.uuid = MathUtils.generateUUID(), this.type = r, this.name = "";
  }
  analyze(r, e) {
    e = e ?? {}, r.analyzing = true, this.build(r.addFlow(e.slot, e.cache, e.context), "v4"), r.clearVertexNodeCode(), r.clearFragmentNodeCode(), r.removeFlow(), r.analyzing = false;
  }
  analyzeAndFlow(r, e, t) {
    return t = t ?? {}, this.analyze(r, t), this.flow(r, e, t);
  }
  flow(r, e, t) {
    t = t ?? {}, r.addFlow(t.slot, t.cache, t.context);
    let o = { result: this.build(r, e), code: r.clearNodeCode(), extra: r.context.extra };
    return r.removeFlow(), o;
  }
  build(r, e, t) {
    e = e ?? this.getType(r, e);
    let o = r.getNodeData(t ?? this);
    return r.analyzing && this.appendDepsNode(r, o, e), r.nodes.indexOf(this) === -1 && r.nodes.push(this), this.updateFrame !== void 0 && r.updaters.indexOf(this) === -1 && r.updaters.push(this), this.generate(r, e, t);
  }
  updateFrame(r) {
  }
  generateReadonly(r, e, t, o, i, s) {
    return "";
  }
  generate(r, e, t, o, i) {
    return "";
  }
  parse(r, e, t, o) {
  }
  appendDepsNode(r, e, t) {
    e.deps = (e.deps || 0) + 1;
    let o = r.getTypeLength(t);
    (o > (e.outputMax || 0) || this.getType(r, t)) && (e.outputMax = o, e.output = t);
  }
  setName(r) {
    this.name = r;
  }
  getName() {
    return this.name;
  }
  getType(r, e) {
    return e === "sampler2D" || e === "samplerCube" ? e : this.type;
  }
  getHash() {
    let r = "{", e, t;
    for (e in this)
      t = this[e], t instanceof Je && (r += '"' + e + '":' + t.getHash() + ",");
    if (this.hashProperties)
      for (let o = 0; o < this.hashProperties.length; o++)
        e = this.hashProperties[o], t = this[e], r += '"' + e + '":"' + String(t) + '",';
    return r += '"id":"' + this.uuid + '"}', r;
  }
};
var gd = class {
  constructor() {
    this.nodes = {};
    this.keywords = {};
  }
  add(r) {
    this.nodes[r.name] = r;
  }
  addKeyword(r, e, t) {
    t = t !== void 0 ? t : true, this.keywords[r] = { callback: e, cache: t };
  }
  remove(r) {
    delete this.nodes[r.name];
  }
  removeKeyword(r) {
    delete this.keywords[r];
  }
  get(r) {
    return this.nodes[r];
  }
  getKeyword(r, e) {
    return this.keywords[r].callback(e);
  }
  getKeywordData(r) {
    return this.keywords[r];
  }
  contains(r) {
    return this.nodes[r] !== void 0;
  }
  containsKeyword(r) {
    return this.keywords[r] !== void 0;
  }
};
var qe = new gd();
var le = class extends Je {
  constructor(e, t) {
    super(e);
    this.scope = "";
    t = t ?? {}, this.shared = t.shared !== void 0 ? t.shared : true, this.unique = t.unique !== void 0 ? t.unique : false;
  }
  build(e, t, o, i) {
    if (t = t ?? this.getType(e), this.getShared(e, t)) {
      let s = this.getUnique(e, t);
      s && this.uuid === void 0 && (this.uuid = MathUtils.generateUUID()), o = e.getUUID(o ?? this.getUUID(), !s);
      let l = e.getNodeData(o), c = l.output || this.getType(e);
      if (e.analyzing)
        return (l.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(e, l, t), this.generate(e, t, o)) : super.build(e, t, o);
      if (s)
        return l.name = l.name || super.build(e, t, o), l.name;
      if (!this.getLabel() && (!this.getShared(e, c) || e.context.ignoreCache || l.deps === 1))
        return super.build(e, t, o);
      o = this.getUUID(false);
      let u = this.getTemp(e, o);
      if (u)
        return e.format(u, c, t);
      {
        u = super.generate(e, t, o, l.output, i);
        let a = this.generate(e, c, o);
        return e.addNodeCode(u + " = " + a + ";"), e.format(u, c, t);
      }
    }
    return super.build(e, t, o);
  }
  getShared(e, t) {
    return t !== "sampler2D" && t !== "samplerCube" && this.shared;
  }
  getUnique(e, t) {
    return this.unique;
  }
  setLabel(e) {
    return this.label = e, this;
  }
  getLabel() {
    return this.label;
  }
  getUUID(e) {
    let t = this.uuid;
    return typeof this.scope == "string" && (t = this.scope + "-" + t), t;
  }
  getTemp(e, t) {
    t = t || this.uuid;
    let o = e.getVars()[t];
    return o ? o.name : void 0;
  }
  generate(e, t, o, i, s) {
    return this.getShared(e, t) || console.error("TempNode is not shared"), o = o ?? this.uuid, e.getTempVar(o, i ?? this.getType(e), s, this.getLabel()).name;
  }
};
var Ne = class extends le {
  constructor(e, t) {
    t = t ?? {}, t.shared = t.shared !== void 0 ? t.shared : false;
    super(e, t);
    this.readonly = false;
  }
  setReadonly(e) {
    return this.readonly = e, this.hashProperties = this.readonly ? ["value"] : void 0, this;
  }
  getReadonly() {
    return this.readonly;
  }
  generate(e, t, o, i, s, l) {
    o = e.getUUID(o ?? this.getUUID()), i = i ?? this.getType(e);
    let c = e.getNodeData(o);
    return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(e, t, o, i, s, l) : e.isShader("vertex") ? (c.vertex || (c.vertex = e.createVertexUniform(i, this, s, l, this.getLabel())), e.format(c.vertex.name, i, t)) : (c.fragment || (c.fragment = e.createFragmentUniform(i, this, s, l, this.getLabel())), e.format(c.fragment.name, i, t));
  }
};
var et = class extends Ne {
  constructor(e = 0, t) {
    super("v2");
    this.nodeType = "Vector2";
    this.value = e instanceof Vector2 ? e : new Vector2(e, t);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", i, t);
  }
};
var st = class extends Ne {
  constructor(e = 0, t, o) {
    super("v3");
    this.nodeType = "Vector3";
    this.value = e instanceof Vector3 ? e : new Vector3(e, t, o);
  }
  get x() {
    return this.value.x;
  }
  set x(e) {
    this.value.x = e;
  }
  get y() {
    return this.value.y;
  }
  set y(e) {
    this.value.y = e;
  }
  get z() {
    return this.value.z;
  }
  set z(e) {
    this.value.z = e;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", i, t);
  }
};
var $e = class extends Color {
  constructor(e, t, o, i) {
    super(e, t, o);
    this.isColorA = true;
    this.a = i;
  }
  setRGBA(e, t, o, i) {
    super.setRGB(e, t, o), this.a = i;
  }
  copy(e) {
    return super.copy(e), this.a = "a" in e ? e.a : 1, this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
  setStyle(e, t = "srgb") {
    let o;
    if (e === "transparent")
      return this.setRGBA(0, 0, 0, 0), this;
    if (o = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(e)) {
      let i, s = o[1], l = o[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return this.a = s === "rgba" ? parseFloat(i[4]) : 1, super.setStyle(e, t);
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return this.a = s === "hsla" ? parseFloat(i[4]) : 1, super.setStyle(e, t);
          break;
      }
    }
    return super.setStyle(e, t);
  }
  get x() {
    return this.r;
  }
  get y() {
    return this.g;
  }
  get z() {
    return this.b;
  }
  get w() {
    return this.a;
  }
  set x(e) {
    this.r = e;
  }
  set y(e) {
    this.g = e;
  }
  set z(e) {
    this.b = e;
  }
  set w(e) {
    this.a = e;
  }
};
var Ft = class extends Ne {
  constructor(e) {
    super("v4");
    this.nodeType = "Vector4";
    this.value = e instanceof $e ? e : new $e(e.r, e.g, e.b, e.a);
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", i, t);
  }
};
var $T = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i;
var ey = /[a-z_0-9]+/gi;
var Q = class extends le {
  constructor(e, t, o, i, s) {
    super(s);
    this.src = "";
    this.nodeType = "Function";
    this.useKeywords = true;
    this.includes = [];
    this.extensions = {};
    this.keywords = {};
    this.isMethod = s === void 0, this.isInterface = false, this.parse(e, t, o, i);
  }
  getShared(e, t) {
    return !this.isMethod;
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  getInputByName(e) {
    if (this.inputs) {
      let t = this.inputs.length;
      for (; t--; )
        if (this.inputs[t].name === e)
          return this.inputs[t];
    }
  }
  getIncludeByName(e) {
    if (this.includes) {
      let t = this.includes.length;
      for (; t--; )
        if (this.includes[t].name === e)
          return this.includes[t];
    }
  }
  generate(e, t, o, i, s) {
    let l, c = 0, u = this.src;
    if (this.includes)
      for (let d = 0; d < this.includes.length; d++)
        e.include(this.includes[d], this);
    for (let d in this.extensions)
      e.extensions[d] = true;
    let a = [];
    for (; l = ey.exec(this.src); )
      a.push(l);
    for (let d = 0; d < a.length; d++) {
      let p = a[d], f = p[0], m = this.isMethod ? !this.getInputByName(f) : true, h = f;
      if (this.keywords[f] || this.useKeywords && m && qe.containsKeyword(f)) {
        let y = this.keywords[f];
        if (!y) {
          let g = qe.getKeywordData(f);
          g.cache && (y = e.keywords[f]), y = y || qe.getKeyword(f, e), g.cache && (e.keywords[f] = y);
        }
        h = y.build(e);
      }
      f !== h && u[p.index + c - 1] !== "." && (u = u.substring(0, p.index + c) + h + u.substring(p.index + f.length + c), c += h.length - f.length), this.getIncludeByName(h) === void 0 && qe.contains(h) && e.include(qe.get(h));
    }
    return t === "source" ? u : this.isMethod ? (this.isInterface || e.include(this, void 0, u), this.name) : e.format("( " + u + " )", this.getType(e), t);
  }
  parse(e, t, o, i) {
    if (this.src = e || "", this.includes = t ?? [], this.extensions = o ?? {}, this.keywords = i ?? {}, this.isMethod) {
      let s = $T.exec(this.src);
      if (this.inputs = [], s && s.length == 4) {
        this.type = s[1], this.name = s[2];
        let l = s[3].match(ey);
        if (l) {
          let c = 0;
          for (; c < l.length; ) {
            let u = l[c++], a;
            u === "in" || u === "out" || u === "inout" ? a = l[c++] : (a = u, u = "");
            let d = l[c++];
            this.inputs.push({ name: d, type: a, qualifier: u });
          }
        }
        this.isInterface = this.src.indexOf("{") === -1;
      } else
        this.type = "", this.name = "";
    }
  }
};
var YT = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i;
var xd = class extends le {
  constructor(e = "", t) {
    super();
    this.src = "";
    this.useDefine = false;
    this.nodeType = "Const";
    this.parse(e || xd.PI, void 0, void 0, void 0, t);
  }
  getType(e) {
    return e.getTypeByFormat(this.type);
  }
  parse(e, t, o, i, s) {
    this.src = e || "";
    let l, c, u = "", a = YT.exec(e);
    this.useDefine = s ?? this.src.charAt(0) === "#", a && a.length > 1 ? (c = a[1], l = a[2], u = a[3]) : (l = this.src, c = "f"), this.name = l, this.type = c, this.value = u;
  }
  build(e, t) {
    if (t === "source") {
      if (this.value)
        return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";";
      if (this.useDefine)
        return this.src;
    }
    return e.include(this), e.format(this.name, this.getType(e), t);
  }
  generate(e, t, o, i, s) {
    return e.format(this.name, this.getType(e), t);
  }
};
var be = xd;
be.PI = "PI", be.PI2 = "PI2", be.RECIPROCAL_PI = "RECIPROCAL_PI", be.RECIPROCAL_PI2 = "RECIPROCAL_PI2", be.LOG2 = "LOG2", be.EPSILON = "EPSILON";
var XT = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim");
var KT = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim");
var Qn = class extends le {
  constructor(e = "") {
    super();
    this.inputs = [];
    this.src = "";
    this.nodeType = "Struct";
    this.parse(e);
  }
  getType(e) {
    return e.getTypeByFormat(this.name);
  }
  getInputByName(e) {
    let t = this.inputs.length;
    for (; t--; )
      if (this.inputs[t].name === e)
        return this.inputs[t];
  }
  generate(e, t, o, i, s) {
    return t === "source" ? this.src + ";" : e.format("( " + this.src + " )", this.getType(e), t);
  }
  parse(e = "") {
    this.src = e, this.inputs = [];
    let t = XT.exec(e);
    if (t) {
      let o = t[2], i;
      for (; i = KT.exec(o); )
        this.inputs.push({ type: i[1], name: i[2] });
      this.name = t[1];
    } else
      this.name = "";
    this.type = this.name;
  }
};
var Jn = class extends le {
  constructor(e) {
    super("v2", { shared: false });
    this.nodeType = "UV";
    this.index = e ?? 0;
  }
  generate(e, t) {
    e.requires.uv[this.index] = true;
    let o = this.index > 0 ? this.index + 1 : "", i = e.isShader("vertex") ? "uv" + o : "vUv" + o;
    return e.format(i, this.getType(e), t);
  }
};
qe.addKeyword("uv", function() {
  return new Jn();
});
qe.addKeyword("uv2", function() {
  return new Jn(1);
});
var No = class extends le {
  constructor(e, t) {
    super("v4");
    this.nodeType = "ColorSpace";
    this.input = e, this.method = t ?? No.LINEAR_TO_LINEAR, this.hashProperties = ["method"];
  }
  static getEncodingComponents(e) {
    switch (e) {
      case LinearEncoding:
        return ["Linear"];
      case sRGBEncoding:
        return ["sRGB"];
      default:
        return [];
    }
  }
  generate(e, t) {
    var _a2;
    let o = this.input.build(e, "v4"), i = this.getType(e), s = No.Nodes[this.method], l = e.include(s);
    if (l === No.LINEAR_TO_LINEAR)
      return e.format(o, i, t);
    if (((_a2 = s.inputs) == null ? void 0 : _a2.length) === 2) {
      let c = this.factor.build(e, "f");
      return e.format(l + "( " + o + ", " + c + " )", i, t);
    } else
      return e.format(l + "( " + o + " )", i, t);
  }
  fromEncoding(e) {
    let t = No.getEncodingComponents(e);
    this.method = "LinearTo" + t[0], this.factor = t[1];
  }
  fromDecoding(e) {
    let t = No.getEncodingComponents(e);
    this.method = t[0] + "ToLinear", this.factor = t[1];
  }
};
var mt = No;
mt.Nodes = { LinearToLinear: new Q(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)), sRGBToLinear: new Q(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)), LinearTosRGB: new Q(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`)) }, mt.LINEAR_TO_LINEAR = "LinearToLinear", mt.SRGB_TO_LINEAR = "sRGBToLinear", mt.LINEAR_TO_SRGB = "LinearTosRGB";
var _e = class extends Q {
  constructor(e = "", t, o, i, s) {
    super(e, s, i, o, t);
    this.nodeType = "Expression";
  }
};
var Pt = class extends Ne {
  constructor(e = new Texture(), t, o, i) {
    super("v4", { shared: true });
    this.nodeType = "Texture";
    this.value = e, this.uv = t ?? new Jn(), this.bias = o, this.project = i !== void 0 ? i : false;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "t");
  }
  generate(e, t) {
    if (t === "sampler2D")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), i = this.uv.build(e, this.project ? "v4" : "v2"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let l, c;
    this.project ? l = "texture2DProj" : l = s ? "tex2DBias" : "tex2D", s ? c = l + "( " + o + ", " + i + ", " + s + " )" : c = l + "( " + o + ", " + i + " )";
    let u = { include: e.isShader("vertex"), ignoreCache: true }, a = this.getType(e);
    return e.addContext(u), this.colorSpace = this.colorSpace ?? new mt(new _e("", a)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(c), c = this.colorSpace.build(e, a), e.removeContext(), e.format(c, a, t);
  }
};
var J = class extends Ne {
  constructor(e) {
    super("f");
    this.nodeType = "Float";
    this.value = e ?? 0;
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format(this.value + (this.value % 1 ? "" : ".0"), i, t);
  }
};
var es = class extends le {
  constructor(e, t) {
    super();
    this.inputs = [];
    this.nodeType = "FunctionCall";
    this.value = e, this.inputs = t ?? [];
  }
  getFunction() {
    return this.value;
  }
  getType(e) {
    return this.value.getType(e);
  }
  generate(e, t, o, i, s) {
    i = this.getType(e);
    let l = this.value, c = l.build(e, t) + "( ", u = [];
    if (l.inputs) {
      for (let a = 0; a < l.inputs.length; a++) {
        let d = l.inputs[a], p = this.inputs[a] || this.inputs[d.name];
        u.push(p.build(e, e.getTypeByFormat(d.type)));
      }
      c += u.join(", ") + " )";
    }
    return e.format(c, i, t);
  }
};
var vd = class extends le {
  constructor(e, t, o = vd.ADD) {
    super();
    this.nodeType = "Operator";
    this.type = e.type, this.a = e, this.b = t, this.op = o;
  }
  getType(e) {
    let t = this.a.getType(e), o = this.b.getType(e);
    return e.isTypeMatrix(t) ? "v4" : e.getTypeLength(o) > e.getTypeLength(t) ? o : t;
  }
  generate(e, t) {
    let o = this.getType(e);
    this.type = o;
    let i = this.a.build(e, o), s = this.b.build(e, o);
    return e.format("( " + i + " " + this.op + " " + s + " )", o, t);
  }
};
var Ot = vd;
Ot.ADD = "+", Ot.SUB = "-", Ot.MUL = "*", Ot.DIV = "/";
var Ae = class extends le {
  constructor(e, t = Ae.ABS, o, i) {
    super();
    this.nodeType = "Math";
    this.a = e, typeof t != "string" ? this.b = t : i = t, typeof o != "string" ? this.c = o : i = o, this.method = i, this.hashProperties = ["method"];
  }
  getNumInputs(e) {
    switch (this.method) {
      case Ae.MIX:
      case Ae.CLAMP:
      case Ae.REFRACT:
      case Ae.SMOOTHSTEP:
      case Ae.FACEFORWARD:
        return 3;
      case Ae.MIN:
      case Ae.MAX:
      case Ae.MOD:
      case Ae.STEP:
      case Ae.REFLECT:
      case Ae.DISTANCE:
      case Ae.DOT:
      case Ae.CROSS:
      case Ae.POW:
        return 2;
      default:
        return 1;
    }
  }
  getInputType(e) {
    let t = e.getTypeLength(this.a.getType(e)), o = this.b ? e.getTypeLength(this.b.getType(e)) : 0, i = this.c ? e.getTypeLength(this.c.getType(e)) : 0;
    return t > o && t > i ? this.a.getType(e) : o > i ? this.b.getType(e) : this.c.getType(e);
  }
  getType(e) {
    switch (this.method) {
      case Ae.LENGTH:
      case Ae.DISTANCE:
      case Ae.DOT:
        return "f";
      case Ae.CROSS:
        return "v3";
    }
    return this.getInputType(e);
  }
  generate(e, t) {
    let o, i, s, l = this.a ? e.getTypeLength(this.a.getType(e)) : 0, c = this.b ? e.getTypeLength(this.b.getType(e)) : 0, u = this.c ? e.getTypeLength(this.c.getType(e)) : 0, a = this.getInputType(e), d = this.getType(e);
    switch (this.type = d, this.method) {
      case Ae.NEGATE:
        return e.format("( -" + this.a.build(e, a) + " )", a, t);
      case Ae.INVERT:
        return e.format("( 1.0 - " + this.a.build(e, a) + " )", a, t);
      case Ae.CROSS:
        o = this.a.build(e, "v3"), i = this.b.build(e, "v3");
        break;
      case Ae.STEP:
        o = this.a.build(e, l === 1 ? "f" : a), i = this.b.build(e, a);
        break;
      case Ae.MIN:
      case Ae.MAX:
      case Ae.MOD:
        o = this.a.build(e, a), i = this.b.build(e, c === 1 ? "f" : a);
        break;
      case Ae.REFRACT:
        o = this.a.build(e, a), i = this.b.build(e, a), s = this.c.build(e, "f");
        break;
      case Ae.MIX:
        o = this.a.build(e, a), i = this.b.build(e, a), s = this.c.build(e, u === 1 ? "f" : a);
        break;
      default:
        o = this.a.build(e, a), this.b && (i = this.b.build(e, a)), this.c && (s = this.c.build(e, a));
        break;
    }
    let p = [];
    p.push(o), i && p.push(i), s && p.push(s);
    let f = this.getNumInputs(e);
    if (p.length !== f)
      throw Error(`Arguments not match used in "${this.method}". Require ${f}, currently ${p.length}.`);
    return e.format(this.method + "( " + p.join(", ") + " )", d, t);
  }
};
var fe = Ae;
fe.RAD = "radians", fe.DEG = "degrees", fe.EXP = "exp", fe.EXP2 = "exp2", fe.LOG = "log", fe.LOG2 = "log2", fe.SQRT = "sqrt", fe.INV_SQRT = "inversesqrt", fe.FLOOR = "floor", fe.CEIL = "ceil", fe.NORMALIZE = "normalize", fe.FRACT = "fract", fe.SATURATE = "saturate", fe.SIN = "sin", fe.COS = "cos", fe.TAN = "tan", fe.ASIN = "asin", fe.ACOS = "acos", fe.ARCTAN = "atan", fe.ABS = "abs", fe.SIGN = "sign", fe.LENGTH = "length", fe.NEGATE = "negate", fe.INVERT = "invert", fe.MIN = "min", fe.MAX = "max", fe.MOD = "mod", fe.STEP = "step", fe.REFLECT = "reflect", fe.DISTANCE = "distance", fe.DOT = "dot", fe.CROSS = "cross", fe.POW = "pow", fe.MIX = "mix", fe.CLAMP = "clamp", fe.REFRACT = "refract", fe.SMOOTHSTEP = "smoothstep", fe.FACEFORWARD = "faceforward";
var ei = class extends le {
  constructor(e, t, o) {
    super("v4");
    this.nodeType = "TextureCubeUV";
    this.value = e, this.uv = t, this.bias = o;
  }
  bilinearCubeUV(e, t, o, i) {
    let s = new es(ei.Nodes.bilinearCubeUV, [t, o, i]);
    this.colorSpaceTL = this.colorSpaceTL ?? new mt(new _e("", "v4")), this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(s.build(e) + ".tl"), this.colorSpaceTR = this.colorSpaceTR ?? new mt(new _e("", "v4")), this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(s.build(e) + ".tr"), this.colorSpaceBL = this.colorSpaceBL ?? new mt(new _e("", "v4")), this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(s.build(e) + ".bl"), this.colorSpaceBR = this.colorSpaceBR ?? new mt(new _e("", "v4")), this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(s.build(e) + ".br");
    let l = { include: e.isShader("vertex"), ignoreCache: true };
    e.addContext(l), this.colorSpaceTLExp = new _e(this.colorSpaceTL.build(e, "v4"), "v4"), this.colorSpaceTRExp = new _e(this.colorSpaceTR.build(e, "v4"), "v4"), this.colorSpaceBLExp = new _e(this.colorSpaceBL.build(e, "v4"), "v4"), this.colorSpaceBRExp = new _e(this.colorSpaceBR.build(e, "v4"), "v4"), e.removeContext();
    let c = new _e("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4");
    return c.keywords.cubeUV_TL = this.colorSpaceTLExp, c.keywords.cubeUV_TR = this.colorSpaceTRExp, c.keywords.cubeUV_BL = this.colorSpaceBLExp, c.keywords.cubeUV_BR = this.colorSpaceBRExp, c.keywords.cubeUV = s, c;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = this.uv, i = this.bias || e.context.roughness, s = new es(ei.Nodes.roughnessToMip, [i]), l = new fe(s, ei.Nodes.m0, ei.Nodes.cubeUV_maxMipLevel, fe.CLAMP), c = new fe(l, fe.FLOOR), u = new fe(l, fe.FRACT), a = this.bilinearCubeUV(e, this.value, o, c), d = this.bilinearCubeUV(e, this.value, o, new Ot(c, new J(1).setReadonly(true), Ot.ADD)), p = new fe(a, d, u, fe.MIX);
      return e.format(p.build(e), "v4", t);
    } else
      return console.warn("TextureCubeUVNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t);
  }
};
var ti = ei;
ti.Nodes = function() {
  let e = new Qn(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), t = new be("float cubeUV_maxMipLevel 8.0", true), o = new be("float cubeUV_minMipLevel 4.0", true), i = new be("float cubeUV_maxTileSize 256.0", true), s = new be("float cubeUV_minTileSize 16.0", true), l = new Q(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
  l.useKeywords = false;
  let c = new Q(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
  c.useKeywords = false;
  let u = new Q(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [e, l, c, t, o, i, s]);
  u.useKeywords = false;
  let a = new be("float r0 1.0", true), d = new be("float v0 0.339", true), p = new be("float m0 -2.0", true), f = new be("float r1 0.8", true), m = new be("float v1 0.276", true), h = new be("float m1 -1.0", true), y = new be("float r4 0.4", true), g = new be("float v4 0.046", true), v = new be("float m4 2.0", true), S = new be("float r5 0.305", true), w = new be("float v5 0.016", true), b = new be("float m5 3.0", true), T = new be("float r6 0.21", true), _ = new be("float v6 0.0038", true), x = new be("float m6 4.0", true), C = [a, d, p, f, m, h, y, g, v, S, w, b, T, _, x], P = new Q(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, C);
  return { bilinearCubeUV: u, roughnessToMip: P, m0: p, cubeUV_maxMipLevel: t };
}();
var Eo = class extends le {
  constructor(e) {
    super("v3");
    this.nodeType = "Normal";
    this.scope = e ?? Eo.VIEW;
  }
  getShared() {
    return this.scope === Eo.WORLD;
  }
  build(e, t, o, i) {
    let s = e.context[this.scope + "Normal"];
    return s ? s.build(e, t, o, i) : super.build(e, t, o);
  }
  generate(e, t, o, i, s) {
    let l;
    switch (this.scope) {
      case Eo.VIEW:
        e.isShader("vertex") ? l = "transformedNormal" : l = "geometryNormal";
        break;
      case Eo.LOCAL:
        e.isShader("vertex") ? l = "objectNormal" : (e.requires.normal = true, l = "vObjectNormal");
        break;
      case Eo.WORLD:
        e.isShader("vertex") ? l = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (e.requires.worldNormal = true, l = "vWNormal");
        break;
    }
    return e.format(l, this.getType(e), t);
  }
};
var tt = Eo;
tt.LOCAL = "local", tt.WORLD = "world", tt.VIEW = "view", tt.NORMAL = "normal";
qe.addKeyword("viewNormal", function() {
  return new tt(tt.VIEW);
});
qe.addKeyword("localNormal", function() {
  return new tt(tt.NORMAL);
});
qe.addKeyword("worldNormal", function() {
  return new tt(tt.WORLD);
});
var xr = class extends le {
  constructor(e) {
    super("v3");
    this.nodeType = "Position";
    this.scope = e ?? xr.LOCAL;
  }
  getType() {
    switch (this.scope) {
      case xr.PROJECTION:
        return "v4";
    }
    return this.type;
  }
  getShader() {
    switch (this.scope) {
      case xr.LOCAL:
      case xr.WORLD:
        return false;
    }
    return true;
  }
  generate(e, t, o, i, s) {
    let l;
    switch (this.scope) {
      case xr.LOCAL:
        e.isShader("vertex") ? l = "transformed" : (e.requires.position = true, l = "vPosition");
        break;
      case xr.WORLD:
        if (e.isShader("vertex"))
          return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
        e.requires.worldPosition = true, l = "vWPosition";
        break;
      case xr.VIEW:
        l = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
        break;
      case xr.PROJECTION:
        l = e.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )";
        break;
    }
    return e.format(l, this.getType(), t);
  }
};
var At = xr;
At.LOCAL = "local", At.WORLD = "world", At.VIEW = "view", At.PROJECTION = "projection";
qe.addKeyword("position", function() {
  return new At();
});
qe.addKeyword("worldPosition", function() {
  return new At(At.WORLD);
});
qe.addKeyword("viewPosition", function() {
  return new At(At.VIEW);
});
var rr = class extends le {
  constructor(e) {
    super("v3");
    this.nodeType = "Reflect";
    this.scope = e ?? rr.CUBE;
  }
  getUnique(e) {
    return !e.context.viewNormal;
  }
  getType() {
    switch (this.scope) {
      case rr.SPHERE:
        return "v2";
    }
    return this.type;
  }
  generate(e, t) {
    let o = this.getUnique(e);
    if (e.isShader("fragment")) {
      let i;
      switch (this.scope) {
        case rr.VECTOR: {
          let s = new tt(tt.VIEW), l = e.context.roughness, c = s.build(e, "v3"), u = new At(At.VIEW).build(e, "v3"), a = l ? l.build(e, "f") : void 0, d = `reflect( -normalize( ${u} ), ${c} )`;
          a && (d = `normalize( mix( ${d}, ${c}, ${a} * ${a} ) )`);
          let p = `inverseTransformDirection( ${d}, viewMatrix )`;
          o ? (e.addNodeCode(`vec3 reflectVec = ${p};`), i = "reflectVec") : i = p;
          break;
        }
        case rr.CUBE: {
          let s = new rr(rr.VECTOR).build(e, "v3"), l = "vec3( -" + s + ".x, " + s + ".yz )";
          o ? (e.addNodeCode(`vec3 reflectCubeVec = ${l};`), i = "reflectCubeVec") : i = l;
          break;
        }
        case rr.SPHERE: {
          let l = "normalize( ( viewMatrix * vec4( " + new rr(rr.VECTOR).build(e, "v3") + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
          o ? (e.addNodeCode(`vec2 reflectSphereVec = ${l};`), i = "reflectSphereVec") : i = l;
          break;
        }
      }
      return e.format(i, this.getType(), t);
    } else
      return console.warn("ReflectNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.type, t);
  }
};
var vr = rr;
vr.CUBE = "cube", vr.SPHERE = "sphere", vr.VECTOR = "vector";
var dl = class extends le {
  constructor(e = new Pt(), t, o) {
    super("v4");
    this.nodeType = "TextureCube";
    this.value = e, this.radianceNode = new ti(this.value, t ?? new vr(vr.VECTOR), o), this.irradianceNode = new ti(this.value, new tt(tt.WORLD), new J(1).setReadonly(true));
  }
  generate(e, t) {
    return e.isShader("fragment") ? (e.require("irradiance"), e.context.bias && e.context.bias.setTexture(this.value), (e.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(e, t)) : (console.warn("TextureCubeNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), t));
  }
};
var ul = class extends Ne {
  constructor(e = new CubeTexture(), t, o) {
    super("v4", { shared: true });
    this.nodeType = "CubeTexture";
    this.value = e, this.uv = t ?? new vr(), this.bias = o;
  }
  getTexture(e, t) {
    return super.generate(e, t, this.value.uuid, "tc");
  }
  generate(e, t) {
    var _a2;
    if (t === "samplerCube")
      return this.getTexture(e, t);
    let o = this.getTexture(e, t), i = (_a2 = this.uv) == null ? void 0 : _a2.build(e, "v3"), s = this.bias ? this.bias.build(e, "f") : void 0;
    s === void 0 && e.context.bias && (s = e.context.bias.setTexture(this).build(e, "f"));
    let l;
    s ? l = "texCubeBias( " + o + ", " + i + ", " + s + " )" : l = "texCube( " + o + ", " + i + " )";
    let c = { include: e.isShader("vertex"), ignoreCache: true }, u = this.getType(e);
    return e.addContext(c), this.colorSpace = this.colorSpace ?? new mt(new _e("", u)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(e, u), e.removeContext(), e.format(l, u, t);
  }
};
var ry = ["x", "y", "z", "w"];
var iP = ["float", "vec2", "vec3", "vec4"];
var sP = { float: "f", vec2: "v2", vec3: "v3", vec4: "v4", mat4: "v4", int: "i", bool: "b", "float[]": "f[]", "vec4[]": "v4[]" };
var aP = { t: "sampler2D", tc: "samplerCube", b: "bool", i: "int", f: "float", c: "vec3", v2: "vec2", v3: "vec3", v4: "vec4", m3: "mat3", m4: "mat4", "f[]": "float[]", "v4[]": "vec4[]" };
var pl = class {
  constructor() {
    this.includes = { consts: {}, functions: {}, structs: {} };
    this.cache = "";
    this.slot = "";
    this.shader = "";
    this.context = {};
    this.getIncludesCode = function() {
      function r(e, t) {
        return e.deps.length - t.deps.length;
      }
      return function(t, o) {
        let i = this.getIncludes(t, o);
        if (!i)
          return "";
        let s = "";
        i = i.sort(r);
        for (let l = 0; l < i.length; l++)
          i[l].src && (s += i[l].src + `
`);
        return s;
      };
    }();
    this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.fragmentParsVariables = {}, this.vertexParsVariables = {}, this.requires = { uv: [], color: [], transparent: false, irradiance: false, position: false, worldPosition: false, normal: false, worldNormal: false, vWorldViewDir: false, modelMatrix: false, viewMatrix: false, projectionMatrix: false }, this.includes = { consts: [], functions: [], structs: [] }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = { vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`), fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`) }, this.code = { vertex: "", fragment: "" }, this.nodeCode = { vertex: "", fragment: "" }, this.resultCode = { vertex: "", fragment: "" }, this.finalCode = { vertex: "", fragment: "" }, this.inputs = { uniforms: { list: [], vertex: [], fragment: [] }, arrayUniforms: { list: [], vertex: [], fragment: [] }, vars: { varying: [], vertex: [], fragment: [] } }, this.defines = {}, this.uniforms = {}, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.updaters = [], this.nodes = [], this.analyzing = false;
  }
  build(r, e) {
    this.buildShader("vertex", r), this.buildShader("fragment", e);
    for (let t = 0; t < this.requires.uv.length; t++)
      if (this.requires.uv[t]) {
        let o = t > 0 ? t + 1 : "";
        this.addVaryCode("varying vec2 vUv" + o + ";"), t > 0 && this.addVertexParsCode("attribute vec2 uv" + o + ";"), this.addVertexFinalCode("vUv" + o + " = uv" + o + ";");
      }
    return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition, this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this;
  }
  buildShader(r, e) {
    this.resultCode[r] = e.build(this.setShader(r), "v4");
  }
  setMaterial(r, e) {
    return this.defines = {}, this;
  }
  addFlow(r, e, t) {
    return this.addSlot(r).addCache(e).addContext(t);
  }
  removeFlow() {
    return this.removeSlot().removeCache().removeContext();
  }
  addCache(r) {
    return this.cache = r ?? "", this.caches.push(this.cache), this;
  }
  removeCache() {
    return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this;
  }
  addContext(r) {
    return this.context = Object.assign({}, this.context, r), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this;
  }
  removeContext() {
    return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this;
  }
  addSlot(r) {
    return this.slot = r || "", this.slots.push(this.slot), this;
  }
  removeSlot() {
    return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this;
  }
  addFragmentVariable(r, e) {
    this.fragmentVariables[r] === void 0 && (this.addFragmentCode(`${e} ${r};`), this.fragmentVariables[r] = "");
  }
  addFragmentParsVariable(r, e) {
    this.fragmentParsVariables[r] === void 0 && (this.addFragmentParsCode(`${e} ${r};`), this.fragmentParsVariables[r] = "");
  }
  addVertexParsVariable(r, e) {
    this.vertexParsVariables[r] === void 0 && (this.addVertexParsCode(`${e} ${r};`), this.vertexParsVariables[r] = "");
  }
  addVertexCode(r) {
    this.addCode(r, "vertex");
  }
  addFragmentCode(r) {
    this.addCode(r, "fragment");
  }
  addCode(r, e) {
    this.code[e ?? this.shader] += r + `
`;
  }
  addVertexNodeCode(r) {
    this.addNodeCode(r, "vertex");
  }
  addFragmentNodeCode(r) {
    this.addNodeCode(r, "fragment");
  }
  addNodeCode(r, e) {
    this.nodeCode[e ?? this.shader] += r + `
`;
  }
  clearNodeCode(r) {
    r = r ?? this.shader;
    let e = this.nodeCode[r];
    return this.nodeCode[r] = "", e;
  }
  clearVertexNodeCode() {
    return this.clearNodeCode("vertex");
  }
  clearFragmentNodeCode() {
    return this.clearNodeCode("fragment");
  }
  addVertexFinalCode(r) {
    this.addFinalCode(r, "vertex");
  }
  addFragmentFinalCode(r) {
    this.addFinalCode(r, "fragment");
  }
  addFinalCode(r, e) {
    this.finalCode[e ?? this.shader] += r + `
`;
  }
  addVertexParsCode(r) {
    this.addParsCode(r, "vertex");
  }
  addFragmentParsCode(r) {
    this.addParsCode(r, "fragment");
  }
  addParsCode(r, e) {
    this.parsCode[e ?? this.shader] += r + `
`;
  }
  addVaryCode(r) {
    this.addVertexParsCode(r), this.addFragmentParsCode(r);
  }
  isCache(r) {
    return this.caches.indexOf(r) !== -1;
  }
  isSlot(r) {
    return this.slots.indexOf(r) !== -1;
  }
  define(r, e) {
    this.defines[r] = e === void 0 ? 1 : e;
  }
  require(r) {
    this.requires[r] = true;
  }
  isDefined(r) {
    return this.defines[r] !== void 0;
  }
  getVar(r, e, t, o = "varying", i = "V", s = "") {
    let l = this.getVars(o), c = l[r];
    if (!c) {
      let u = l.length;
      c = { name: t || "node" + i + u + (s ? "_" + s : ""), type: e }, l.push(c), l[r] = c;
    }
    return c;
  }
  getTempVar(r, e, t, o) {
    return this.getVar(r, e, t, this.shader, "T", o);
  }
  getAttribute(r, e) {
    if (!this.attributes[r]) {
      let t = this.getVar(r, e);
      this.addVertexParsCode("attribute " + e + " " + r + ";"), this.addVertexFinalCode(t.name + " = " + r + ";"), this.attributes[r] = { varying: t, name: r, type: e };
    }
    return this.attributes[r];
  }
  getCode(r) {
    return [this.prefixCode, this.parsCode[r], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[r], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[r], "uniform"), this.getIncludesCode("consts", r), this.getIncludesCode("structs", r), this.getIncludesCode("functions", r), "void main() {", this.getVarListCode(this.getVars(r)), this.code[r], this.resultCode[r], this.finalCode[r], "}"].join(`
`);
  }
  getVarListCode(r, e) {
    e = e ?? "";
    let t = "";
    for (let o = 0, i = r.length; o < i; ++o) {
      let s = r[o], l = s.type, c = s.name, u = s.size, a = this.getFormatByType(l);
      if (a === void 0)
        throw new Error("Node pars " + a + " not found.");
      a.includes("[]") ? t += e + " " + a.substring(0, a.length - 2) + " " + c + `[${u}];
` : t += e + " " + a + " " + c + `;
`;
    }
    return t;
  }
  getVars(r) {
    return this.inputs.vars[r ?? this.shader];
  }
  getNodeData(r) {
    let e = r instanceof Je ? r.uuid : r;
    return this.nodeData[e] = this.nodeData[e] || {};
  }
  createUniform(r, e, t, o, i, s) {
    if (e.includes("[]")) {
      let l = this.inputs.arrayUniforms, c = l.list.length, u = new Ji({ type: e, size: t.size, name: o || "nodeUA" + c + (s ? "_" + s : ""), node: t, needsUpdate: i });
      return l.list.push(u), l[r].push(u), l[r][u.name] = u, this.uniforms[u.name] = u, u;
    } else {
      let l = this.inputs.uniforms, c = l.list.length, u = new Ji({ type: e, name: o || "nodeU" + c + (s ? "_" + s : ""), node: t, needsUpdate: i });
      return l.list.push(u), l[r].push(u), l[r][u.name] = u, this.uniforms[u.name] = u, u;
    }
  }
  createVertexUniform(r, e, t, o, i) {
    return this.createUniform("vertex", r, e, t, o, i);
  }
  createFragmentUniform(r, e, t, o, i) {
    return this.createUniform("fragment", r, e, t, o, i);
  }
  include(r, e, t) {
    var _a2;
    let o;
    if (r = typeof r == "string" ? qe.get(r) : r, this.context.include === false)
      return r.name;
    r instanceof Q ? o = this.includes.functions : r instanceof be ? o = this.includes.consts : r instanceof Qn && (o = this.includes.structs);
    let i = o[this.shader] = o[this.shader] || [];
    if (r) {
      let s = i[r.name];
      if (s || (s = i[r.name] = { node: r, deps: [] }, i.push(s), s.src = r.build(this, "source")), r instanceof Q && e && i[e.name] && i[e.name].deps.indexOf(r) === -1 && (i[e.name].deps.push(r), (_a2 = r.includes) == null ? void 0 : _a2.length)) {
        let l = 0;
        do
          this.include(r.includes[l++], e);
        while (l < r.includes.length);
      }
      return t && (s.src = t), r.name;
    } else
      throw new Error("Include not found.");
  }
  colorToVectorProperties(r) {
    return r.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w");
  }
  colorToVector(r) {
    return r.replace(/c/g, "v3");
  }
  getIncludes(r, e) {
    return this.includes[r][e || this.shader];
  }
  getConstructorFromLength(r) {
    return iP[r - 1];
  }
  isTypeMatrix(r) {
    return /^m/.test(r);
  }
  getTypeLength(r) {
    return r === "f" ? 1 : parseInt(this.colorToVector(r).substr(1));
  }
  getTypeFromLength(r) {
    return r === 1 ? "f" : "v" + r;
  }
  findNode(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t == null ? void 0 : t.isNode)
        return t;
    }
  }
  resolve(...r) {
    for (let e = 0; e < arguments.length; e++) {
      let t = r[e];
      if (t !== void 0) {
        if (t.isNode)
          return t;
        if (t.isTexture)
          switch (t.mapping) {
            case CubeReflectionMapping:
            case CubeRefractionMapping:
              return new ul(t);
            case CubeUVReflectionMapping:
              return new dl(new Pt(t));
            default:
              return new Pt(t);
          }
        else {
          if (t.isVector2)
            return new et(t);
          if (t.isVector3)
            return new st(t);
          if (t.isVector4)
            return new Ft(t);
        }
      }
    }
  }
  format(r, e, t) {
    switch (this.colorToVector(t + " <- " + e)) {
      case "f <- v2":
        return r + ".x";
      case "f <- v3":
        return r + ".x";
      case "f <- v4":
        return r + ".x";
      case "f <- i":
      case "f <- b":
        return "float( " + r + " )";
      case "v2 <- f":
        return "vec2( " + r + " )";
      case "v2 <- v3":
        return r + ".xy";
      case "v2 <- v4":
        return r + ".xy";
      case "v2 <- i":
      case "v2 <- b":
        return "vec2( float( " + r + " ) )";
      case "v3 <- f":
        return "vec3( " + r + " )";
      case "v3 <- v2":
        return "vec3( " + r + ", 0.0 )";
      case "v3 <- v4":
        return r + ".xyz";
      case "v3 <- i":
      case "v3 <- b":
        return "vec2( float( " + r + " ) )";
      case "v4 <- f":
        return "vec4( " + r + " )";
      case "v4 <- v2":
        return "vec4( " + r + ", 0.0, 1.0 )";
      case "v4 <- v3":
        return "vec4( " + r + ", 1.0 )";
      case "v4 <- i":
      case "v4 <- b":
        return "vec4( float( " + r + " ) )";
      case "i <- f":
      case "i <- b":
        return "int( " + r + " )";
      case "i <- v2":
        return "int( " + r + ".x )";
      case "i <- v3":
        return "int( " + r + ".x )";
      case "i <- v4":
        return "int( " + r + ".x )";
      case "b <- f":
        return "( " + r + " != 0.0 )";
      case "b <- v2":
        return "( " + r + " != vec2( 0.0 ) )";
      case "b <- v3":
        return "( " + r + " != vec3( 0.0 ) )";
      case "b <- v4":
        return "( " + r + " != vec4( 0.0 ) )";
      case "b <- i":
        return "( " + r + " != 0 )";
    }
    return r;
  }
  getTypeByFormat(r) {
    return sP[r] || r;
  }
  getFormatByType(r) {
    return aP[r] || r;
  }
  getUUID(r, e) {
    return e = e !== void 0 ? e : true, e && this.cache && (r = this.cache + "-" + r), r;
  }
  getElementByIndex(r) {
    return ry[r];
  }
  getIndexByElement(r) {
    return ry.indexOf(r);
  }
  isShader(r) {
    return this.shader === r;
  }
  setShader(r) {
    return this.shader = r, this;
  }
  mergeDefines(r) {
    for (let e in r)
      this.defines[e] = r[e];
    return this.defines;
  }
  mergeUniform(r) {
    for (let e in r)
      this.uniforms[e] = r[e];
    return this.uniforms;
  }
  getTextureEncodingFromMap(r) {
    let e;
    return r ? r.isTexture && (e = r.encoding) : e = LinearEncoding, e === LinearEncoding && this.context.gamma && (e = sRGBEncoding), e;
  }
};
var Te = class extends Ne {
  constructor(e = 0, t, o, i) {
    super("c");
    this.nodeType = "Color";
    this.value = e instanceof $e ? e : new $e(e || 0, t, o, i);
  }
  setRGBA(e) {
    this.value.setRGBA(e.r, e.g, e.b, e.a);
  }
  generate(e, t, o, i, s, l) {
    o = e.getUUID(o ?? this.getUUID()), i = i ?? this.getType(e);
    let c = e.getNodeData(o), u = this.getReadonly() && this.generateReadonly !== void 0;
    if (this.alpha) {
      let a = this.alpha.build(e, "f");
      e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${a};`);
    }
    return u ? this.generateReadonly(e, t, o, i, s, l) : e.isShader("vertex") ? (c.vertex || (c.vertex = e.createVertexUniform(i, this, s, l, this.getLabel())), e.format(c.vertex.name, i, t)) : (c.fragment || (c.fragment = e.createFragmentUniform(i, this, s, l, this.getLabel())), e.format(c.fragment.name, i, t));
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", i, t);
  }
};
var xe = class extends Ne {
  constructor(e) {
    super("i");
    this.nodeType = "Int";
    this.value = Math.floor(e ?? 0);
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format(this.value.toString(), i, t);
  }
};
var Mo = class extends Je {
  constructor() {
    super("basic");
    this.nodeType = "Basic";
    this.color = new Te(5855577), this.shadingAlpha = new J(1), this.shadingBlend = new xe(0);
  }
  get category() {
    return "phong";
  }
  generate(e) {
    let t;
    if (e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), i.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      this.color === void 0 && (this.color = new Te(5855577)), this.color.analyze(e, { slot: "color" }), this.alpha && this.alpha.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" });
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.alpha ? this.alpha.flow(e, "f") : void 0, s = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0;
      e.requires.transparent = i !== void 0, e.addParsCode(["varying vec3 vWPosition;", "#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#include <normal_pars_fragment>"].join(`
`));
      let l = ["#include <normal_fragment_begin>", o.code];
      i && l.push(i.code, "#ifdef ALPHATEST", " if ( " + i.result + " <= ALPHATEST ) discard;", "#endif"), s ? l.push(s.code, `vec3 outgoingLight = ${o.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${s.result}, 1.0, SPE_BLENDING_NORMAL);`) : l.push(`vec3 finalColor = ${o.result};`), i ? l.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${i.result} );`) : l.push("gl_FragColor = vec4(" + o.result + ", 1.0 );"), l.push("#include <fog_fragment>", "#include <dithering_fragment>"), t = l.join(`
`);
    }
    return t;
  }
};
var or = class extends Ne {
  constructor(e = 1, t) {
    super("f[]");
    this.nodeType = "FloatArray";
    this.size = e, this.value = Array.isArray(t) ? t : typeof t == "number" ? new Array(e).fill(t) : new Array(e).fill(0);
  }
};
var at = { normalRenderTarget: new Pt(), normalRenderTargetDepth: new Pt(), transmissionRenderTarget: new Pt(), transmissionSize: new et(2048, 2048), transmissionRenderTargetDepth: new Pt(), pixelRatioNode: new J(1), resolution: new et(), penumbraSize: new or(5, 0.5) };
for (let n of Object.values(at))
  n.isRenderGlobal = true;
var ts = class extends Je {
  constructor() {
    super("lambert");
    this.nodeType = "Lambert";
    this.color = new Te(5855577), this.emissive = new Te(0), this.emissiveIntensity = new J(1), this.shadingAlpha = new J(1), this.shadingBlend = new xe(0);
  }
  get category() {
    return "lambert";
  }
  build(e) {
    let t;
    if (e.define("LAMBERT"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: at.penumbraSize }), this.color === void 0 && (this.color = new Te(5855577)), this.color.analyze(e, { slot: "color" }), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.emissive.flow(e, "c", { slot: "emissive" }), s = this.emissiveIntensity.flow(e, "f", { slot: "emissive" }), l = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, a = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = a !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#include <normal_pars_fragment>", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let d = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`, "#include <clipping_planes_fragment>"];
      d.push(o.code, "vec3 diffuseColor = " + o.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), a && d.push(a.code, "#ifdef ALPHATEST", "if ( " + a.result + " <= ALPHATEST ) discard;", "#endif"), d.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), i && d.push(i.code, "reflectedLight.directDiffuse += " + i.result + " * " + s.result + ";"), d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), a ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${a.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = d.join(`
`);
    }
    return t;
  }
};
var fl = class extends Je {
  constructor() {
    super("phong");
    this.nodeType = "Phong";
    this.color = new Te(5855577), this.specular = new Te(1118481), this.shininess = new J(30), this.shadingAlpha = new J(1), this.shadingBlend = new xe(0);
  }
  get category() {
    return "phong";
  }
  build(e) {
    let t;
    if (e.define("PHONG"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: at.penumbraSize }), this.color === void 0 && (this.color = new Te(5855577)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.specular.flow(e, "c"), s = this.shininess.flow(e, "f"), l = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, a = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = a !== void 0, e.addParsCode(["varying vec3 vWPosition;", "uniform vec3 emissive;", `uniform float penumbraSize[${5}];`, "#include <normal_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`));
      let d = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	BlinnPhongMaterial material;"];
      d.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", i.code, "	vec3 specular = " + i.result + ";", s.code, "	float shininess = max( 0.0001, " + s.result + " );", "	float specularStrength = 1.0;"), a && d.push(a.code, "#ifdef ALPHATEST", "if ( " + a.result + " <= ALPHATEST ) discard;", "#endif"), d.push("material.diffuseColor = diffuseColor;"), d.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), a ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${a.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = d.join(`
`);
    }
    return t;
  }
};
var rs = class extends Je {
  constructor() {
    super("standard");
    this.nodeType = "Standard";
    this.color = new Te(5855577), this.roughness = new J(0.3), this.metalness = new J(0), this.reflectivity = new J(0.5), this.shadingAlpha = new J(1), this.shadingBlend = new xe(0);
  }
  get category() {
    return "physical";
  }
  build(e) {
    let t;
    if (e.define("STANDARD"), e.requires.lights = true, e.extensions.derivatives = true, e.extensions.shaderTextureLOD = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), UniformsLib.LTC_1 && (e.uniforms.ltc_1 = { value: void 0 }, e.uniforms.ltc_2 = { value: void 0 }), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: at.penumbraSize });
      let o = { gamma: true };
      this.color === void 0 && (this.color = new Te(5855577)), this.color.analyze(e, { slot: "color", context: o }), this.roughness.analyze(e), this.metalness.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e), this.reflectivity && this.reflectivity.analyze(e);
      let i = this.color.flow(e, "c", { slot: "color", context: o }), s = this.roughness.flow(e, "f"), l = this.metalness.flow(e, "f"), c = this.shadingAlpha.flow(e, "f"), u = this.shadingBlend.flow(e, "i"), a = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, d = this.alpha ? this.alpha.flow(e, "f") : void 0, p = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0;
      e.requires.transparent = d !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", `uniform float penumbraSize[${5}];`, "#include <normal_pars_fragment>", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>"].join(`
`));
      let f = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"];
      f.push(i.code, "	vec3 diffuseColor = " + i.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", s.code, "	float roughnessFactor = " + s.result + ";", l.code, "	float metalnessFactor = " + l.result + ";"), d && f.push(d.code, "#ifdef ALPHATEST", "	if ( " + d.result + " <= ALPHATEST ) discard;", "#endif"), f.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), f.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), p ? f.push(p.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + p.result + " ) ), diffuseColor, metalnessFactor );") : f.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), f.push("#include <lights_fragment_begin>"), f.push("#include <lights_fragment_end>"), f.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"), f.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${c.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${c.result}, ${u.result} );
				}
				`), a && f.push(a.code, `outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`), d ? f.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`) : f.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), f.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = f.join(`
`);
    }
    return t;
  }
};
var os = class extends Je {
  constructor() {
    super("toon");
    this.nodeType = "Toon";
    this.color = new Te(5855577), this.specular = new Te(1118481), this.shininess = new J(30), this.shadingAlpha = new J(1), this.shadingBlend = new xe(0);
  }
  get category() {
    return "toon";
  }
  build(e) {
    let t;
    if (e.define("TOON"), e.requires.lights = true, e.extensions.derivatives = true, e.isShader("vertex")) {
      let o = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0;
      e.mergeUniform(UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`));
      let i = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];
      o && i.push(o.code, o.result ? "displaced_position = " + o.result + ";" : ""), i.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), i.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), t = i.join(`
`);
    } else {
      e.mergeUniform({ penumbraSize: at.penumbraSize }), this.color === void 0 && (this.color = new Te(5855577)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e);
      let o = this.color.flow(e, "c", { slot: "color" }), i = this.specular.flow(e, "c"), s = this.shininess.flow(e, "f"), l = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, a = this.alpha ? this.alpha.flow(e, "f") : void 0;
      e.requires.transparent = a !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "varying vec3 vWPosition;", "#include <normal_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>"].join(`
`));
      let d = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	ToonMaterial material;"];
      d.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", i.code, "	vec3 specular = " + i.result + ";", s.code, "	float shininess = max( 0.0001, " + s.result + " );", "	float specularStrength = 1.0;"), a && d.push(a.code, "#ifdef ALPHATEST", "if ( " + a.result + " <= ALPHATEST ) discard;", "#endif"), d.push("material.diffuseColor = diffuseColor;"), d.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), a ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${a.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), t = d.join(`
`);
    }
    return t;
  }
};
var co = class extends Ne {
  constructor(e) {
    super("b");
    this.nodeType = "Bool";
    this.value = e ?? false;
  }
  generateReadonly(e, t, o, i) {
    return e.format(this.value ? "true" : "false", i, t);
  }
};
var ri = class extends Ne {
  constructor(e) {
    super("m3");
    this.nodeType = "Matrix3";
    this.value = e ?? new Matrix3();
  }
  generateReadonly(e, t, o, i, s, l) {
    return e.format("mat3(" + this.value.elements.join(", ") + ")", i, t);
  }
  get elements() {
    return this.value.elements;
  }
  set elements(e) {
    this.value.fromArray(e);
  }
};
var nr = class extends Ne {
  constructor(e = 1, t) {
    super("v4[]");
    this.nodeType = "Vector4Array";
    this.size = e, this.value = Array.isArray(t) ? t : t instanceof Vector4 ? new Array(e).fill(t) : new Array(e).fill(new Vector4(0));
  }
};
var ns = ((i) => (i.SIMPLEX = "simplex3d", i.SIMPLEX_FRACTAL = "simplex3dFractal", i.ASHIMA = "simplexAshima", i.FBM = "fbm", i.PERLIN = "perlin", i))(ns || {});
var dt = function() {
  let r = new Q(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), e = new Q(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [r]);
  e.keywords.F3 = new be("float F3 0.3333333"), e.keywords.G3 = new be("float G3 0.1666667");
  let t = new Q(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [e]), o = new Q("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), i = new Q("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), s = new Q(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [o, i]), l = new Q("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), c = new Q("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [l]), u = new Q(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [c]), a = new Q(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [u]);
  a.keywords.NUM_OCTAVES = new be(`int NUM_OCTAVES ${5}`);
  let d = new Q("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), p = new Q(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [o, i, d]);
  return { simplex: e, simplexFractal: t, simplexAshima: s, fbm: a, perlin: p };
}();
var is = class extends le {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f) {
    super("v3");
    this.nodeType = "Noise";
    this.scale = e, this.size = t, this.move = o, this.fA = i, this.fB = s, this.distortion = l, this.colorA = c, this.colorB = u, this.colorC = a, this.colorD = d, this.alpha = p, this.noiseType = f, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t, o, i, s) {
    e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
    let l = Object.values(ns)[this.noiseType.value], c = new Q(`vec3 ${l}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${l}(st),
							  ${l}(st + vec3(1.0)),
							  ${l}(st + vec3(1.0)));
				vec3 r = vec3(${l}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${l}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${l}(st * q));
				float f = ${l}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`, [dt.simplex, dt.simplexFractal, dt.simplexAshima, dt.fbm, dt.perlin]), u = e.include(c), a = [];
    return a.push(this.scale.build(e, "f")), a.push(this.size.build(e, "v3")), a.push(this.move.build(e, "f")), a.push(this.fA.build(e, "v2")), a.push(this.fB.build(e, "v2")), a.push(this.distortion.build(e, "v2")), a.push(this.colorA.build(e, "v4")), a.push(this.colorB.build(e, "v4")), a.push(this.colorC.build(e, "v4")), a.push(this.colorD.build(e, "v4")), a.push(this.alpha.build(e, "f")), a.push(this.calpha), e.format(u + "(" + a.join(",") + ")", this.getType(e), t);
  }
};
is.numOctaves = 5;
var Sd = class extends le {
  constructor(e, t, o, i, s, l, c) {
    super("v3");
    this.nodeType = "Fresnel";
    this.color = e, this.bias = t, this.scale = o, this.intensity = i, this.factor = s, this.alpha = l, this.mode = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Sd.Nodes.fresnel), i = [];
      return i.push(this.color.build(e, "c")), i.push(this.bias.build(e, "f")), i.push(this.scale.build(e, "f")), i.push(this.intensity.build(e, "f")), i.push(this.factor.build(e, "f")), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("FresnelNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ss = Sd;
ss.Nodes = function() {
  return { fresnel: new Q(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`) };
}();
var wd = class extends le {
  constructor(e, t, o, i, s, l, c) {
    super("v3");
    this.nodeType = "Rainbow";
    this.filmThickness = e, this.movement = t, this.wavelengths = o, this.noiseStrength = i, this.noiseScale = s, this.offset = l, this.alpha = c, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(wd.Nodes.rainbow), i = [];
      return i.push(this.filmThickness.build(e, "f")), i.push(this.movement.build(e, "f")), i.push(this.wavelengths.build(e, "v3")), i.push(this.noiseStrength.build(e, "f")), i.push(this.noiseScale.build(e, "f")), i.push(this.offset.build(e, "v3")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("RainbowNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var as = wd;
as.Nodes = function() {
  let e = new Q(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [dt.simplex]);
  return { rainbow: new Q(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`, [e]) };
}();
var _d = class extends le {
  constructor(e, t, o, i, s, l, c, u, a, d, p, f, m, h, y, g) {
    super("v3");
    this.nodeType = "Outline";
    this.firstTime = true, this.outlineColor = e, this.contourColor = t, this.outlineWidth = o, this.contourWidth = i, this.contourThreshold = s, this.outlineThreshold = l, this.contourFrequency = c, this.outlineSmoothing = u, this.contourDirection = a, this.positionalLines = d, this.compensation = p, this.resolution = f, this.normalMap = m, this.depthMap = h, this.pixelRatio = y, this.alpha = g, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("vWorldViewDir"), e.require("worldNormal"), e.extensions.derivatives = true, this.firstTime) {
      let o = this.outlineWidth.build(e, "f"), i = this.resolution.build(e, "v2"), s = this.compensation.build(e, "b"), l = this.pixelRatio.build(e, "f");
      e.addVertexParsVariable("randomColor", "attribute vec3"), e.addVertexParsVariable("extrudeNormal", "attribute vec3"), e.addVertexParsVariable(o, "uniform float"), e.addVertexParsVariable(i, "uniform vec2"), e.addVertexParsVariable(s, "uniform bool"), e.addVertexParsVariable(l, "uniform float"), e.addVertexParsVariable("vID", "flat out float"), e.addFragmentParsVariable("vID", "flat in float");
      let c = `g${this.uuid.toString().replace(/-/g, "")}`;
      e.addVertexFinalCode(`
                vID = randomColor.r;
                if (${s}) {
                    vec4 ${c}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${c}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    vec2 ${c}_offset = normalize(${c}_clipNormal.xy) / ${i} * (${o} / 2.0) * ${c}_clipPosition.w * 2.0 * ${l};
                    ${c}_clipPosition.xy += ${c}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${c}_clipPosition;
                }
            `);
    }
    if (e.isShader("fragment")) {
      e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(_d.Nodes.outline), i = [];
      return i.push(this.outlineColor.build(e, "c")), i.push(this.contourColor.build(e, "c")), i.push(this.outlineWidth.build(e, "f")), i.push(this.contourWidth.build(e, "f")), i.push(this.contourThreshold.build(e, "f")), i.push(this.outlineThreshold.build(e, "f")), i.push(this.contourFrequency.build(e, "f")), i.push(this.outlineSmoothing.build(e, "f")), i.push(this.contourDirection.build(e, "v3")), i.push(this.positionalLines.build(e, "b")), i.push(this.resolution.build(e, "v2")), i.push(this.normalMap.getTexture(e, "t")), i.push(this.depthMap.getTexture(e, "t")), i.push(this.pixelRatio.build(e, "f")), i.push(this.compensation.build(e, "b")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), this.firstTime = !this.firstTime, e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("OutlineNode is not compatible with " + e.shader + " shader."), "";
  }
};
var ls = _d;
ls.Nodes = function() {
  let e = new Q(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 texelSize = (vec2(1.0) / resolution) * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -texelSize.x, -texelSize.y);
	uvSamples[1] = uv + vec2(0.0, -texelSize.y);
	uvSamples[2] = uv + vec2(  texelSize.x, -texelSize.y);
	uvSamples[3] = uv + vec2( -texelSize.x, 0.0);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  texelSize.x, 0.0);
	uvSamples[6] = uv + vec2( -texelSize.x, texelSize.y);
	uvSamples[7] = uv + vec2(0.0, texelSize.y);
	uvSamples[8] = uv + vec2(  texelSize.x, texelSize.y);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec4 sobel_edge_h = normalSamples[2] + (2.0*normalSamples[5]) + normalSamples[8] - (normalSamples[0] + (2.0*normalSamples[3]) + normalSamples[6]);
  	vec4 sobel_edge_v = normalSamples[0] + (2.0*normalSamples[1]) + normalSamples[2] - (normalSamples[6] + (2.0*normalSamples[7]) + normalSamples[8]);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);
  return { outline: new Q(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return result;
             }`, [e]) };
}();
var Td = class extends le {
  constructor(e, t, o, i, s, l, c, u) {
    super("v3");
    this.nodeType = "Transmission";
    this.thickness = e, this.ior = t, this.roughness = o, this.transmissionSamplerSize = i, this.transmissionSamplerMap = s, this.transmissionDepthMap = l, this.aspectRatio = c, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true, e.isShader("fragment")) {
      e.define("NUM_SAMPLES", 30), e.require("worldPosition"), e.requires.worldNormal = true, e.requires.modelMatrix = true, e.requires.projectionMatrix = true, e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Td.Nodes.transmission), i = [];
      return i.push(this.thickness.build(e, "f")), i.push(this.ior.build(e, "f")), i.push(this.roughness.build(e, "f")), i.push(this.transmissionSamplerSize.build(e, "v2")), i.push(this.transmissionSamplerMap.getTexture(e, "t")), i.push(this.transmissionDepthMap.getTexture(e, "t")), i.push(this.aspectRatio.build(e, "v2")), i.push("normal"), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("TransmissionNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var cs = Td;
cs.Nodes = function() {
  let e = new Q(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`), t = new Q(`
            vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec3 O = vec3(0);
                float a = 0.0;
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = unpackRGBAToDepth(texture2D(dm, uv));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    float gaussian = gaussian(d);
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian * texture2DLodEXT( sp, uv, lod).rgb;
                    #else
                    O += gaussian * textureLod( sp, uv, lod).rgb;
                    #endif
                    a += gaussian;
                }
                return O / a;
            }`, [e]), o = new Q(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), i = new Q(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `), s = new Q(`
vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`, [i, t]), l = new Q(`
vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    }`, [s, o]);
  return { transmission: new Q(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission;
            }`, [l]) };
}();
var oi = class extends le {
  constructor(e, t, o, i, s, l, c, u, a, d, p) {
    super("v3");
    this.nodeType = "Depth";
    this.gradientType = e, this.smooth = t, this.near = o, this.far = i, this.isVector = s, this.isWorldSpace = l, this.origin = c, this.direction = u, this.colors = a, this.steps = d, this.alpha = p, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, i = new Q(`vec3 ${o}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${o}_MAX_COLORS], float steps[${o}_MAX_COLORS], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${o}_IS_VECTOR
                   #ifdef ${o}_LINEAR
                       #ifdef ${o}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${o}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${o}_SMOOTH
				for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`, [oi.Nodes.vectorLinearWorldSpaceDepth, oi.Nodes.vectorLinearObjectSpaceDepth, oi.Nodes.vectorSphericalObjectSpaceDepth, oi.Nodes.vectorSphericalWorldSpaceDepth]);
    if (e.isShader("fragment")) {
      e.define(`${o}_MAX_COLORS`, this.colors.value.length), this.smooth.value && e.define(`${o}_SMOOTH`), this.isVector.value > 0.5 && e.define(`${o}_IS_VECTOR`), this.gradientType.value === 0 && e.define(`${o}_LINEAR`), this.isWorldSpace.value > 0.5 && e.define(`${o}_WORLDSPACE`), e.require("worldPosition"), e.addFragmentVariable(this.calpha, "float");
      let s = e.include(i), l = [];
      return l.push(this.near.build(e, "f")), l.push(this.far.build(e, "f")), l.push(this.origin.build(e, "v3")), l.push(this.direction.build(e, "v3")), l.push(this.colors.build(e, "v4[]")), l.push(this.steps.build(e, "f[]")), l.push(this.alpha.build(e, "f")), l.push(this.calpha), e.format(s + "(" + l.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("DepthNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ds = oi;
ds.Nodes = function() {
  let e = new Q(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), t = new Q(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), o = new Q(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`), i = new Q(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
  return { vectorLinearWorldSpaceDepth: e, vectorLinearObjectSpaceDepth: t, vectorSphericalWorldSpaceDepth: o, vectorSphericalObjectSpaceDepth: i };
}();
var us = class extends le {
  constructor(e, t, o, i) {
    super("v3");
    this.nodeType = "Blend";
    this.a = e, this.b = t, this.alpha = o, this.mode = i;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = [];
      return o.push(this.a.build(e, "c")), o.push(this.b.build(e, "c")), o.push(this.alpha.build(e, "f")), o.push(this.mode.build(e, "i")), e.format("spe_blend(" + o.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("BlendNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var Pd = ((e) => (e.NOISE = "noise", e.MAP = "map", e))(Pd || {});
var Od = class extends le {
  constructor(e, t, o, i, s) {
    super("v3");
    this.displacementTypeIndex = new xe(0);
    this.nodeType = "VertexDisplacement";
    this.intensity = e, this.movementOrTexture = t, Object.values(Pd)[this.displacementTypeIndex.value] === "map" && (this.mat = new ri(this.movementOrTexture.value.matrix)), this.cropOrOffset = o, this.scale = i, this.noiseFunctionIndex = s;
  }
  generate(e, t) {
    if (e.isShader("vertex")) {
      e.define("USE_LAYER_DISPLACE");
      let o, i = [];
      switch (i.push("displaced_position"), i.push("displaced_normal"), Object.values(Pd)[this.displacementTypeIndex.value]) {
        case "map": {
          o = e.include(Od.Nodes.map), i.push(this.movementOrTexture.getTexture(e, "t")), i.push("uv"), i.push(this.cropOrOffset.build(e, "f")), this.mat && i.push(this.mat.build(e, "mat3"));
          break;
        }
        case "noise": {
          let l = Object.values(ns)[this.noiseFunctionIndex.value], c = new Q(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`), u = new Q(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${l}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`, [dt.simplex, dt.simplexFractal, dt.simplexAshima, dt.fbm, dt.perlin]), a = new Q(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [u, c]);
          o = e.include(a), i.push(this.scale.build(e, "f")), i.push(this.cropOrOffset.build(e, "v3")), i.push(this.movementOrTexture.build(e, "f"));
          break;
        }
      }
      return i.push(this.intensity.build(e, "f")), i.push("displaced_normal"), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("VertexDisplacementNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ps = Od;
ps.Nodes = function() {
  let e = new Q(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), t = new Q(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
  return { map: new Q(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [e, t]) };
}();
var Ad = class extends le {
  constructor(e, t, o, i, s, l, c, u) {
    super("v3");
    this.nodeType = "Gradient";
    this.gradientType = e, this.smooth = t, this.colors = o, this.steps = i, this.offset = s, this.morph = l, this.angle = c, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.define("GRAD_MAX", 10), e.require("uv"), e.requires.uv = [true], e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Ad.Nodes.gradient), i = [];
      return i.push(this.gradientType.build(e, "i")), i.push(this.smooth.build(e, "b")), i.push(this.colors.build(e, "v4[]")), i.push(this.steps.build(e, "f[]")), i.push(this.offset.build(e, "v2")), i.push(this.morph.build(e, "v2")), i.push(this.angle.build(e, "f")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("GradientNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var fs = Ad;
fs.Nodes = function() {
  return { gradient: new Q(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`) };
}();
var hs = class extends le {
  constructor(e, t, o, i, s, l, c, u, a, d) {
    super("v3");
    this.nodeType = "CustomTexture";
    this.firstTime = true, this.texture = e, this.textureSize = t, this.crop = o, this.projection = i, this.axis = s, this.side = l, this.size = c, this.mat = u, this.alpha = a, this.mode = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    e.require("position"), e.require("normal"), e.require("uv"), e.requires.uv = [true], e.extensions.shaderTextureLOD = true, e.extensions.derivatives = true;
    let o = `g${this.uuid.toString().replace(/-/g, "")}`, i;
    switch (this.projection.value) {
      case 3:
        i = e.include(hs.Nodes.cylindrical);
        break;
      case 2:
        i = e.include(hs.Nodes.spherical);
        break;
      case 1:
        let l = ["vec3(1.0, 0.0, 0.0)", "vec3(0.0, 1.0, 0.0)", "vec3(0.0, 0.0, 1.0)"][this.axis.value], c = new Q(`
		vec3 ${o}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${o}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value === 2 ? "" : `lalpha *= step(0.0, ${this.side.value === 1 ? "-1.0 * " : ""}dot(vObjectNormal, mat * ${l}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
        i = e.include(c);
        break;
      default:
        i = e.include(hs.Nodes.uv);
        break;
    }
    if (this.projection.value === 1 && this.firstTime) {
      e.addVertexParsCode(`varying vec2 ${o}_vCustomUv;`), e.addFragmentParsCode(`varying vec2 ${o}_vCustomUv;`);
      let l = ["zy", "xz", "xy"][this.axis.value];
      e.addVertexFinalCode(`${o}_vCustomUv = (1. + (transformed.${l})) / 2.;`);
    }
    e.addFragmentVariable(this.calpha, "float");
    let s = [];
    return s.push(this.texture.generate(e, "t")), s.push(this.textureSize.build(e, "v2")), s.push(this.crop.build(e, "f")), s.push(this.mat.build(e, "mat3")), s.push(this.size.build(e, "v2")), s.push(this.alpha.build(e, "f")), s.push(this.mode.build(e, "i")), s.push(this.calpha), this.firstTime = !this.firstTime, e.format(i + "(" + s.join(",") + ")", this.getType(e), t);
  }
};
var ms = hs;
ms.Nodes = function() {
  let e = new Q(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), t = new Q(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`), o = new Q(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);
  return { cylindrical: e, spherical: t, uv: o };
}();
var Id = class extends le {
  constructor(e, t) {
    super("v3");
    this.nodeType = "CustomNormal";
    this.cnormal = e, this.alpha = t;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      let o = e.include(Id.Nodes.customNormal), i = [];
      return i.push(this.cnormal.build(e, "v3")), i.push("normal"), i.push(this.alpha.build(e, "f")), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("CustomNormalNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var ys = Id;
ys.Nodes = function() {
  return { customNormal: new Q(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`) };
}();
function ht(n, r) {
  return r.color(n);
}
function ay(n, r) {
  switch (n.type) {
    case "fresnel":
      return gP(n, r);
    case "gradient":
      return xP(n);
    case "depth":
      return vP(n);
    case "normal":
      return bP(n);
    case "noise":
      return SP(n, r);
    case "rainbow":
      return wP(n);
    case "toon":
      return _P(n, r);
    case "outline":
      return TP(n, r);
    case "transmission":
      return PP(n, r);
    case "color":
      return yP(n, r);
  }
}
function hP(n) {
  return { type: n.type };
}
function wr(n) {
  let { alpha: r, mode: e } = n;
  return { ...hP(n), alpha: r, mode: e };
}
function yP(n, r) {
  return { ...wr(n), color: ht(n.color, r) };
}
function gP(n, r) {
  let { bias: e, scale: t, intensity: o, factor: i, color: s } = n;
  return { ...wr(n), color: ht(s, r), bias: e, scale: t, intensity: o, factor: i };
}
function xP(n) {
  let { gradientType: r, smooth: e, colors: t, steps: o, angle: i, offset: s, morph: l } = n;
  return { ...wr(n), gradientType: r, smooth: e, colors: t.map((c) => new Vector4(c[0], c[1], c[2], c[3])), num: t.length, steps: o, offset: new Vector2(...s), morph: new Vector2(...l), angle: i };
}
function vP(n) {
  let { gradientType: r, near: e, far: t, isVector: o, isWorldSpace: i, origin: s, direction: l, colors: c, steps: u, smooth: a } = n;
  return { ...wr(n), gradientType: r, near: e, far: t, isVector: o, isWorldSpace: i, origin: new Vector3(...s), direction: l ? new Vector3(...l) : new Vector3(1, 0, 0), colors: c.map((d) => d !== void 0 ? new Vector4(d[0], d[1], d[2], d[3]) : new Vector4(0, 0, 0, 0)), steps: u.slice(0, c.length), smooth: a };
}
function bP(n) {
  let { cnormal: r } = n;
  return { ...wr(n), cnormal: new Vector3(r[0], r[1], r[2]) };
}
function SP(n, r) {
  return { ...wr(n), scale: n.scale, move: n.move, fA: new Vector2(...n.fA), fB: new Vector2(...n.fB), size: new Vector3(...n.size), distortion: new Vector2(...n.distortion), colorA: ht(n.colorA, r), colorB: ht(n.colorB, r), colorC: ht(n.colorC, r), colorD: ht(n.colorD, r), noiseType: n.noiseType };
}
function wP(n) {
  return { ...wr(n), filmThickness: n.filmThickness, movement: n.movement, wavelengths: new Vector3(...n.wavelengths), noiseStrength: n.noiseStrength, noiseScale: n.noiseScale, offset: new Vector3(...n.offset) };
}
function _P(n, r) {
  return { ...wr(n), positioning: n.positioning, colors: n.colors.map((e) => new Vector4(e[0], e[1], e[2], e[3])), num: n.colors.length, steps: n.steps, source: new Vector3(...n.source), isWorldSpace: n.isWorldSpace, noiseStrength: n.noiseStrength, noiseScale: n.noiseScale, shadowColor: ht(n.shadowColor, r), offset: new Vector3(...n.offset) };
}
function TP(n, r) {
  return { ...wr(n), outlineColor: ht(n.outlineColor, r), contourColor: ht(n.contourColor, r), outlineWidth: n.outlineWidth, contourWidth: n.contourWidth, outlineThreshold: n.outlineThreshold, contourThreshold: n.contourThreshold, outlineSmoothing: n.outlineSmoothing, contourFrequency: n.contourFrequency, contourDirection: new Vector3(...n.contourDirection), positionalLines: n.positionalLines, compensation: n.compensation };
}
function PP(n, r) {
  return { ...wr(n), thickness: n.thickness, ior: n.ior, roughness: n.roughness };
}
var uo = class extends $e {
};
var hl = class {
  constructor(r = 1e3 * 10) {
    this.timeout = r;
    this.cache = /* @__PURE__ */ new Map();
    this.head = { data: null, time: 0, src: null, next: null, prev: null };
    this.tail = { data: null, time: 1 / 0, src: null, next: null, prev: null };
    this.hasClean = false;
    this.head.next = this.tail, this.tail.prev = this.head;
  }
  log(...r) {
  }
  remove(r) {
    let e = this.cache.get(r);
    e && (this.dispose(r, e.data), this.cache.delete(r), e.prev.next = e.next, e.next.prev = e.prev);
  }
  scheduleCleanup() {
    this.hasClean || (this.log("scheduled cleanup"), this.hasClean = true, setTimeout(() => {
      this.hasClean = false, this.log("cleaning");
      let r = Date.now(), e = this.head.next;
      for (; e.time < r - this.timeout; )
        this.dispose(e.src, e.data), this.cache.delete(e.src), e = e.next, e.prev = this.head, this.head.next = e;
      this.head.next !== this.tail ? this.scheduleCleanup() : this.log("no more cleanup");
    }, this.timeout + 1e3));
  }
  has(r) {
    var _a2;
    return (_a2 = this.cache.get(r)) == null ? void 0 : _a2.data;
  }
  load(r) {
    let e = Date.now(), t = this.cache.get(r);
    return t === void 0 ? (t = { data: this.create(r), src: r, time: e, next: null, prev: null }, this.cache.set(r, t)) : (t.time = e, t.prev.next = t.next, t.next.prev = t.prev), t.prev = this.tail.prev, t.next = this.tail, this.tail.prev.next = t, this.tail.prev = t, this.scheduleCleanup(), t.data;
  }
};
var Nd = class extends hl {
  create(r) {
    return URL.createObjectURL(new Blob([r]));
  }
  dispose(r, e) {
    URL.revokeObjectURL(e);
  }
};
var Cd;
function ly(n) {
  return typeof n == "string" ? n : (Cd || (Cd = new Nd()), Cd.load(n));
}
var yl = class {
  constructor(r, e) {
    this.data = r;
    this.cache = e;
    this.refCount = 0;
  }
  deref() {
    if (this.refCount === 0 && false)
      throw new Error("ref count -1?");
    this.refCount -= 1, this.refCount === 0 && (this.cache.remove(this), this.dispose());
  }
  dispose() {
    if (this.refCount !== 0 && false)
      throw new Error("ref count is not 0");
  }
};
var gl = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  remove(r) {
    if (this.cache.delete(r.data) === false && false)
      throw new Error("ref count remove non-exists");
  }
  load(r) {
    let e = this.cache.get(r);
    return e === void 0 && (e = this.create(r), this.cache.set(r, e)), e.refCount += 1, e;
  }
};
var ni = class extends yl {
  constructor(e, t) {
    super(e, t.imageHolderCache);
    this.data = e;
    this.shared = t;
    this.loaded = false;
    this.isVideo = false;
    this.isVideo = e.type == "video", this.updateSrc(e.data);
  }
  async updateSrc(e) {
    if (typeof document > "u")
      return;
    this.disposeTextures(), this.loaded = false;
    let t = () => {
      this.loaded = true;
      let i = [1e3, 1001, 1002];
      for (let s of i) {
        let l = this[s];
        l && (l.image = this.img, l.needsUpdate = true);
      }
      this.shared.requestRender();
    };
    if (this.isVideo) {
      if (this.img = document.createElement("video"), this.img.preload = "auto", this.img.playsInline = true, this.img.currentTime = 0.01, typeof e != "string") {
        var o = new FileReader();
        o.readAsDataURL(new Blob([e], { type: "video/mp4" }));
        let i;
        await new Promise((s) => {
          o.onloadend = (l) => {
            var _a2;
            i = (_a2 = l.target) == null ? void 0 : _a2.result, s(null);
          };
        }), this.img.src = i;
      } else
        this.img.src = e;
      this.img.onloadeddata = () => {
        t();
      };
    } else
      this.img = new Image(), this.img.src = ly(e), this.img.onload = t;
  }
  getTexture(e) {
    let t = this[e];
    if (t)
      return t;
    {
      let o;
      return this.isVideo ? o = new VideoTexture(this.img, void 0, e, e) : o = new Texture(this.img, void 0, e, e), this.loaded && (o.needsUpdate = true), this[e] = o, o;
    }
  }
  disposeTextures() {
    var _a2, _b2, _c2;
    (_a2 = this[1e3]) == null ? void 0 : _a2.dispose(), this[1e3] = void 0, (_b2 = this[1001]) == null ? void 0 : _b2.dispose(), this[1001] = void 0, (_c2 = this[1002]) == null ? void 0 : _c2.dispose(), this[1002] = void 0;
  }
  dispose() {
    super.dispose(), this.disposeTextures();
  }
};
var zt = class extends ni {
};
var po = class extends Ne {
};
var Ed = { noise: ["noiseType"], texture: ["projection", "axis", "side"], video: ["projection", "axis", "side"], displace: ["noiseType"], depth: ["smooth", "isWorldSpace", "gradientType", "isVector"] };
var Md = { depth: ["colors"] };
function CP(n, r, e) {
  var _a2, _b2;
  let t = Ed[n.type], o = Md[n.type];
  if (o !== void 0) {
    let i = n.color;
    if (o.includes(r)) {
      let s = (_b2 = (_a2 = i[r]) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length;
      if (s !== void 0 && s !== e.length)
        return true;
    }
  }
  return t !== void 0 ? t.includes(r) : false;
}
function Ld(n, r, e) {
  let t = e.uniforms[`f${e.id}_texture`];
  if (!t)
    return false;
  let o = false, i = n;
  if ("image" in i) {
    let s = i.image, l = r.image(s), c = t;
    c.image instanceof zt || c.image.deref(), c.image = l;
  }
  if ("video" in i) {
    let s = i.video, l = r.video(s), c = t;
    c.image instanceof zt || c.image.deref(), c.image = l;
  }
  if ("wrapping" in i) {
    let s = t;
    s.wrap = i.wrapping;
  }
  if ("repeat" in i || "offset" in i) {
    let s = "mat", l = e.uniforms[`f${e.id}_${s}`];
    "repeat" in i && (l.repeat = i.repeat), "offset" in i && (l.offset = i.offset), l.updateMatrix();
  }
  return o;
}
function cy(n, r, e, t) {
  let o = false;
  for (let [i, s] of Object.entries(n)) {
    if (!i || s === void 0)
      continue;
    if (Bd(i, e, t)) {
      i === "visible" && e.type === "light" && (o = true);
      continue;
    }
    e.visible = t.visible;
    let l = e.uniforms[`f${e.id}_${i}`];
    if (!!l && !(l instanceof po))
      switch (o = o || CP(e, i, s), l.constructor) {
        case Te:
          if (typeof s == "string") {
            let c = r.getColor(s);
            c && (l.value = c);
            break;
          } else {
            let c = s;
            l.value instanceof uo ? l.value = new $e(c.r, c.g, c.b, c.a) : l.setRGBA(c);
            break;
          }
        case Ft:
          if (typeof s == "string") {
            let c = r.getColor(s);
            c && (l.value = c);
            break;
          } else {
            let c = s;
            l.value instanceof uo ? l.value = new $e(c.r, c.g, c.b, c.a) : l.value.setRGBA(c.r, c.g, c.b, c.a);
            break;
          }
        case et: {
          let c = s;
          l.value.setX(c[0]), l.value.setY(c[1]);
          break;
        }
        case st: {
          let c = s;
          l.value.setX(c[0]), l.value.setY(c[1]), l.value.setZ(c[2]);
          break;
        }
        case Pt: {
          Ld(s, r, e);
          break;
        }
        case nr: {
          l.value = s.map((c) => new Vector4(...c));
          break;
        }
        default: {
          l.value = s;
          break;
        }
      }
  }
  return o;
}
var Dd = class extends le {
  constructor(e, t, o) {
    super("v3");
    this.nodeType = "Matcap";
    this.texture = e, this.alpha = t, this.mode = o, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.isShader("fragment")) {
      e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Dd.Nodes.matcap);
      e.require("normal"), e.requires.normal = true;
      let i = [];
      return i.push(this.texture.generate(e, "t")), i.push("normal"), i.push(this.alpha.build(e, "f")), i.push(this.mode.build(e, "i")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("MatcapNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var xs = Dd;
xs.Nodes = function() {
  return { matcap: new Q(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `) };
}();
var Lo = class extends po {
  constructor(e, t) {
    super("t");
    this.image = e;
    this.wrap = t;
  }
  get value() {
    return this.image.getTexture(this.wrap);
  }
};
var xl = class extends po {
  constructor(e) {
    super("v3");
    this.image = e;
    this._value = new Vector3();
  }
  get value() {
    return this._value.x = this.image.isVideo ? this.image.img.videoWidth ?? 0 : this.image.img.width, this._value.y = this.image.isVideo ? this.image.img.videoHeight ?? 0 : this.image.img.height, this._value;
  }
};
var Gd = class extends le {
  constructor(e, t, o, i, s, l, c, u, a, d) {
    super("v3");
    this.nodeType = "Toon";
    this.positioning = e, this.colors = t, this.steps = o, this.source = i, this.isWorldSpace = s, this.noiseStrength = l, this.noiseScale = c, this.shadowColor = u, this.offset = a, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`;
  }
  generate(e, t) {
    if (e.require("worldNormal"), e.require("worldPosition"), e.isShader("fragment")) {
      e.define("COLORS_MAX", 10), e.addFragmentVariable(this.calpha, "float");
      let o = e.include(Gd.Nodes.toon), i = [];
      return i.push(this.positioning.build(e, "i")), i.push(this.colors.build(e, "v4[]")), i.push(this.steps.build(e, "f[]")), i.push(this.source.build(e, "v3")), i.push(this.isWorldSpace.build(e, "b")), i.push(this.noiseStrength.build(e, "f")), i.push(this.noiseScale.build(e, "f")), i.push(this.shadowColor.build(e, "v4")), i.push(this.offset.build(e, "v3")), i.push(this.alpha.build(e, "f")), i.push(this.calpha), e.format(o + "(" + i.join(",") + ")", this.getType(e), t);
    } else
      return console.warn("ToonNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), t);
  }
};
var vs = Gd;
vs.Nodes = function() {
  let e = new Q(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`), t = new Q(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`), o = new Q(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`, [t]), i = new Q(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`), s = new Q(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`, [i]);
  return { toon: new Q(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`, [dt.simplex, e, o, s]) };
}();
function dy(n, r, e) {
  n.setUvTransform(e[0], e[1], r[0], r[1], 0, 0, 0);
}
var vl = class extends ri {
  constructor(e, t) {
    super(new Matrix3());
    this.repeat = e;
    this.offset = t;
    dy(this.value, e, t);
  }
  updateMatrix() {
    dy(this.value, this.repeat, this.offset);
  }
};
var Tr = class {
  constructor(r, e, t, o) {
    this.id = r;
    this.uuid = e;
    this.data = t;
    this.uniforms = {};
    for (let i in o)
      this.uniforms[`f${this.id}_${i}`] = o[i];
    for (let i in t)
      Bd(i, this, t);
  }
  get type() {
    return this.data.type;
  }
  static create(r, e, t, o) {
    if (t.type === "light")
      return Pr.createLigherLayer(r, e, t, o);
    if (t.type === "texture" || t.type === "video") {
      let i = t.type === "texture" ? o.image(t.texture.image) : o.video(t.texture.video), s = new Lo(i, t.texture.wrapping), l = new xl(i), c = new vl(t.texture.repeat, t.texture.offset), u = new J(t.crop ? 1 : 0), a = new xe(t.projection ?? 0), d = new xe(["x", "y", "z"].indexOf(t.axis) ?? 0), p = new xe(t.side ?? 0), f = new et(t.size ? new Vector2(t.size[0], t.size[1]) : new Vector2(100, 100)), m = new J(t.alpha ?? 1), h = new xe(t.mode ?? 0), y = new ms(s, l, u, a, d, p, f, c, m, h), g = new _e(y.calpha, "f");
      return new ke(r, e, t, { texture: s, textureSize: l, crop: u, projection: a, axis: d, side: p, size: f, mat: c, alpha: m, mode: h }, y, h, g);
    } else if (t.type === "matcap") {
      let i = o.image(t.texture.image), s = new Lo(i, t.texture.wrapping), l = new J(t.alpha ?? 1), c = new xe(t.mode ?? 0), u = new xs(s, l, c), a = new _e(u.calpha, "f");
      return new ke(r, e, t, { texture: s, alpha: l, mode: c }, u, c, a);
    } else if (t.type === "displace")
      if (t.displacementType === "noise") {
        let i = new st(new Vector3(...t.offset)), s = new J(t.scale ?? 10), l = new J(t.intensity ?? 8), c = new J(t.movement ?? 1), u = new xe(t.noiseType ?? 0), a = new ps(l, c, i, s, u);
        return new bs(r, e, t, { offset: i, scale: s, intensity: l, movement: c, noiseType: u }, a);
      } else
        throw new Error();
    else
      return BP(r, e, t, o);
  }
  updateByOp(r, e, t) {
    var _a2;
    let o = r;
    if (o.path[0] === void 0) {
      if (o.type === 0)
        return "type" in o.props || "category" in o.props ? ((_a2 = t.scene) == null ? void 0 : _a2.markNeedsUpdateRendererDirty(), true) : cy(o.props, t.shared, this, e);
    } else if (o.path[0] === "texture")
      return "texture" in e || "video" in e ? Ld(o.props, t.shared, this) : true;
    return false;
  }
  dispose() {
    if (MP(this)) {
      let r = this.uniforms[`f${this.id}_texture`];
      if (!r)
        return false;
      let e = r;
      e.image instanceof zt || e.image.deref();
    }
  }
  hasValueByKey(r) {
    return this.uniforms[r] !== void 0;
  }
  hasValue(r) {
    return this.hasValueByKey(`f${this.id}_${r}`);
  }
  setValue(r, e) {
    let t = `f${this.id}_${r}`;
    this.hasValueByKey(t) && e !== void 0 && (this.uniforms[t].value = e);
  }
  getNode(r) {
    let e = `f${this.id}_${r}`;
    if (this.hasValueByKey(e))
      return this.uniforms[e];
  }
  getValue(r) {
    let e = `f${this.id}_${r}`;
    if (this.hasValueByKey(e))
      return this.uniforms[e].value;
  }
  getName(r) {
    let t = /f\d+_(.*)/.exec(r);
    if (t && t.length > 1)
      return t[1];
    console.log(`Layer.getName: error ${r}`);
  }
  getNames() {
    let r = [];
    for (let e in this.uniforms) {
      let t = this.getName(e);
      t && r.push(t);
    }
    return r;
  }
};
var ke = class extends Tr {
  constructor(e, t, o, i, s, l, c) {
    super(e, t, o, i);
    this.params = i;
    this.color = s;
    this.mode = l;
    this.alpha = c;
  }
};
var bs = class extends Tr {
  constructor(e, t, o, i, s) {
    super(e, t, o, i);
    this.position = s;
  }
};
var Pr = class extends Tr {
  constructor(e, t, o, i, s) {
    super(e, t, o, s);
    this.node = i;
  }
  static createLigherLayer(e, t, o, i) {
    let s, l = new J(o.alpha), c = new xe(o.mode), u;
    if (!o.visible)
      s = new Mo(), u = {};
    else if (o.category === "lambert") {
      s = new ts();
      let a = new Te(i.color(o.emissive) ?? 0);
      u = { emissive: a }, s.emissive = a;
    } else if (o.category === "toon") {
      s = new os();
      let a = new J(o.shininess ?? 30), d = new Te(i.color(o.specular) ?? 1118481);
      u = { shininess: a, specular: d }, s.shininess = a, s.specular = d;
    } else if (o.category === "physical") {
      s = new rs();
      let a = new J(o.roughness ?? 0.3), d = new J(o.metalness ?? 0), p = new J(o.reflectivity ?? 0.5);
      u = { roughness: a, metalness: d, reflectivity: p }, s.roughness = a, s.metalness = d, s.reflectivity = p;
    } else {
      s = new fl();
      let a = new J(o.shininess ?? 30), d = new Te(o.specular !== void 0 ? i.color(o.specular) ?? 1118481 : 1118481);
      u = { shininess: a, specular: d }, s.shininess = a, s.specular = d;
    }
    return s.alpha = new J(1), s.shadingAlpha = l, s.shadingBlend = c, u.alpha = s.shadingAlpha, u.mode = s.shadingBlend, new Pr(e, t, o, s, u);
  }
  get category() {
    return this.node.category;
  }
};
function MP(n) {
  let r = n instanceof Tr ? n.type : n;
  return r === "texture" || r === "video" || r === "displace_map" || r === "matcap";
}
function LP(n, r, e, t) {
  switch (n.type) {
    case "color": {
      let o = new Te(t.color ?? 5855577), i = new J(t.alpha ?? 1), s = new _e("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      s.keywords.alpha = i;
      let l = new xe(t.mode ?? 0);
      return o.alpha = i, new ke(r, e, n, { color: o, alpha: i, mode: l }, o, l, s);
    }
    case "fresnel": {
      let o = new Te(t.color ?? 16777215), i = new J(t.bias ?? 0.1), s = new J(t.scale ?? 1), l = new J(t.intensity ?? 2), c = new J(t.factor ?? 1), u = new J(t.alpha ?? 1), a = new xe(t.mode ?? 0), d = new ss(o, i, s, l, c, u, a), p = new _e(d.calpha, "f");
      return new ke(r, e, n, { color: o, bias: i, scale: s, intensity: l, factor: c, alpha: u, mode: a }, d, a, p);
    }
    case "rainbow": {
      let o = new J(t.filmThickness ?? 30), i = new J(t.movement ?? 0), s = new st(t.wavelengths ?? new Vector3(0, 0, 0)), l = new J(t.noiseStrength ?? 0), c = new J(t.noiseScale ?? 1), u = new st(t.offset ?? new Vector3(0, 0, 0)), a = new J(t.alpha ?? 1), d = new as(o, i, s, l, c, u, a), p = new _e(d.calpha, "f"), f = new xe(t.mode ?? 0);
      return new ke(r, e, n, { filmThickness: o, movement: i, wavelengths: s, noiseStrength: l, noiseScale: c, offset: u, alpha: a, mode: f }, d, f, p);
    }
    case "transmission": {
      let o = new J(t.thickness ?? 10), i = new J(t.ior ?? 1.5), s = new J(t.roughness ?? 0.5), l = at.transmissionSize, c = at.transmissionRenderTarget, u = at.transmissionRenderTargetDepth, a = window.innerWidth, d = window.innerHeight, p = a >= d ? new et(d / a, 1) : new et(1, a / d), f = new J(t.alpha ?? 1), m = new cs(o, i, s, l, c, u, p, f), h = new _e(m.calpha, "f"), y = new xe(t.mode ?? 0);
      return new ke(r, e, n, { thickness: o, ior: i, roughness: s, aspectRatio: p, alpha: f, mode: y }, m, y, h);
    }
    case "toon": {
      let o = new xe(t.positioning ?? 0), i;
      t.colors ? i = new nr(t.colors.length, t.colors) : (i = new nr(10, new Vector4(0, 0, 0, 1)), i.value[1] = new Vector4(1, 1, 1, 1));
      let s;
      t.steps ? s = new or(t.steps.length, t.steps) : (s = new or(10, 1), s.value[0] = 0);
      let l = new st(t.source ?? new Vector3(0, 0, 0)), c = new co(t.isWorldSpace ?? true), u = new J(t.noiseStrength ?? 0), a = new J(t.noiseScale ?? 1), d = new Ft(t.shadowColor), p = new st(t.offset ?? new Vector3(0, 0, 0)), f = new J(t.alpha ?? 1), m = new vs(o, i, s, l, c, u, a, d, p, f), h = new _e(m.calpha, "f"), y = new xe(t.mode ?? 0);
      return new ke(r, e, n, { positioning: o, colors: i, steps: s, source: l, isWorldSpace: c, noiseStrength: u, noiseScale: a, shadowColor: d, offset: p, alpha: f, mode: y }, m, y, h);
    }
    case "outline": {
      let o = new Te(t.outlineColor ?? 16777215), i = new Te(t.contourColor ?? 16777215), s = new J(t.outlineWidth ?? 0.1), l = new J(t.contourWidth ?? 0.1), c = new J(t.outlineThreshold ?? 0.1), u = new J(t.contourThreshold ?? 0.1), a = new J(t.outlineSmoothing ?? 0.1), d = new J(t.contourFrequency ?? 0.1), p = new st(t.contourDirection ?? new Vector3(0, 1, 0)), f = new co(t.positionalLines ?? false), m = new co(t.compensation ?? true), h = at.normalRenderTarget, y = at.normalRenderTargetDepth, g = at.pixelRatioNode, v = at.resolution, S = new J(t.alpha ?? 1), w = new ls(o, i, s, l, c, u, a, d, p, f, m, v, h, y, g, S), b = new _e(w.calpha, "f"), T = new xe(t.mode ?? 0);
      return new ke(r, e, n, { outlineColor: o, contourColor: i, outlineWidth: s, contourWidth: l, outlineThreshold: c, contourThreshold: u, outlineSmoothing: a, contourFrequency: d, contourDirection: p, positionalLines: f, compensation: m, alpha: S, mode: T }, w, T, b);
    }
    case "depth": {
      let o = new xe(t.gradientType ?? 0), i = new co(t.smooth ?? false), s = new J(t.near ?? 50), l = new J(t.far ?? 200), c = new J(t.isVector ?? 1), u = new J(t.isWorldSpace ?? 0), a = new st(t.origin ?? new Vector3()), d = new st(t.direction ?? new Vector3()), p;
      t.colors ? p = new nr(t.colors.length, t.colors) : (p = new nr(2, new Vector4(0, 0, 0, 1)), p.value[1] = new Vector4(1, 1, 1, 1));
      let f;
      t.steps ? f = new or(t.steps.length, t.steps) : (f = new or(2, 1), f.value[0] = 0);
      let m = new J(t.alpha ?? 1), h = new xe(t.mode ?? 0), y = new ds(o, i, s, l, c, u, a, d, p, f, m), g = new _e(y.calpha, "f");
      return new ke(r, e, n, { gradientType: o, smooth: i, near: s, far: l, isVector: c, isWorldSpace: u, origin: a, direction: d, colors: p, steps: f, alpha: m, mode: h }, y, h, g);
    }
    case "noise": {
      let o = new J(t.scale ?? 1), i = new st(t.size ?? new Vector3(100, 100, 100)), s = new J(t.move ?? 1), l = new et(t.fA ?? new Vector2(1.7, 9.2)), c = new et(t.fB ?? new Vector2(8.3, 2.8)), u = new et(t.distortion ?? new Vector2(1, 1)), a = new Ft(t.colorA), d = new Ft(t.colorB), p = new Ft(t.colorC), f = new Ft(t.colorD), m = new J(t.alpha ?? 1), h = new xe(t.mode ?? 0), y = new xe(t.noiseType ?? 0), g = new is(o, i, s, l, c, u, a, d, p, f, m, y), v = new _e(g.calpha, "f");
      return new ke(r, e, n, { scale: o, size: i, move: s, fA: l, fB: c, distortion: u, colorA: a, colorB: d, colorC: p, colorD: f, alpha: m, mode: h, noiseType: y }, g, h, v);
    }
    case "normal": {
      let o = new st(t.cnormal ?? new Vector3(1, 1, 1)), i = new J(t.alpha ?? 1), s = new xe(t.mode ?? 0), l = new ys(o, i), c = new _e("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      return c.keywords.alpha = i, new ke(r, e, n, { cnormal: o, alpha: i, mode: s }, l, s, c);
    }
    case "gradient": {
      let o = new xe(t.gradientType ?? 0), i = new co(t.smooth ?? false), s;
      t.colors ? s = new nr(t.colors.length, t.colors) : (s = new nr(10, new Vector4(0, 0, 0, 1)), s.value[1] = new Vector4(1, 1, 1, 1));
      let l;
      t.steps ? l = new or(t.steps.length, t.steps) : (l = new or(10, 1), l.value[0] = 0);
      let c = new et(t.offset ?? new Vector2(0, 0)), u = new et(t.morph ?? new Vector2(0, 0)), a = new J(t.angle ?? 0), d = new J(t.alpha ?? 1), p = new xe(t.mode ?? 0), f = new fs(o, i, s, l, c, u, a, d), m = new _e(f.calpha, "f");
      return new ke(r, e, n, { gradientType: o, smooth: i, colors: s, steps: l, offset: c, morph: u, angle: a, alpha: d, mode: p }, f, p, m);
    }
    default: {
      let o = new Te(1, 0, 0, 1), i = new J(1), s = new _e("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )", "f");
      s.keywords.alpha = i;
      let l = new xe(0);
      return o.alpha = i, new ke(r, e, n, { color: o, alpha: i, mode: l }, o, l, s);
    }
  }
}
function BP(n, r, e, t) {
  let o = ay(e, t);
  return LP(e, n, r, o);
}
function Bd(n, r, e) {
  if (e.type === "displace" && (n === "intensity" || n === "visible")) {
    let t = r.uniforms[`f${r.id}_intensity`];
    return t ? (t.value = e.intensity * (e.visible ? 1 : 0), t) : void 0;
  }
  if (e.type !== "displace" && (n === "alpha" || n === "visible")) {
    let t = r.uniforms[`f${r.id}_alpha`];
    if (!t)
      return;
    if (t.value = e.alpha * (e.visible ? 1 : 0), e.type === "outline" && n === "visible") {
      let o = r.uniforms[`f${r.id}_compensation`];
      o && (o.value = e.compensation && e.visible);
    }
    return t;
  }
}
function uy(n, r) {
  let e = 0;
  for (let t of n.layers)
    if (t.data.type !== "displace" && "alpha" in t.data && t.data.type !== "light" && t.data.type !== "fresnel" && t.data.type !== "texture" && t.data.type !== "matcap" && t.data.type !== "rainbow" && t.data.type !== "outline") {
      let o = t.data.visible ? t.data.alpha : 0;
      if (o === 1 && t.data.type === "depth" || t.data.type === "gradient") {
        for (let i of t.data.colors)
          if (i[3] < 1) {
            o = i[3];
            break;
          }
      } else if (o === 1 && t.data.type === "noise") {
        let i = r.color(t.data.colorA).a, s = r.color(t.data.colorB).a, l = r.color(t.data.colorC).a, c = r.color(t.data.colorD).a, u = Math.min(i, Math.min(s, Math.min(l, c)));
        u < 1 && (o = u);
      }
      e += (1 - e) * o;
    }
  return e < 1;
}
var It = class extends ShaderMaterial {
  constructor() {
    super(void 0);
    this.flatShading = false;
    this.cacheKey = "";
    this.fog = true, this.dithering = true, this.vertexColors = true, this.transparent = true;
  }
  customProgramCacheKey() {
    return this.cacheKey;
  }
};
var Rd = class extends It {
  constructor(e, t, o, i) {
    super();
    this.flatShading = e;
    this.side = t;
    this.wireframe = o;
    this.root = i;
  }
  updateAfterBuild() {
    let e = this.root;
    this.lights = e.lights, this.vertexShader = e.vertexShader, this.fragmentShader = e.fragmentShader, this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.transparent = e.transparent, this.cacheKey = e.customProgramCacheKey() + "flat" + this.flatShading + this.side;
  }
  onBeforeCompile(e, t) {
    this.root.onBeforeCompile(e);
  }
  get data() {
    return this.root.data;
  }
  get category() {
    return this.root.category;
  }
  getFlavor(e, t, o) {
    return this.root.getFlavor(e, t, o);
  }
  get layers() {
    return this.root.layers;
  }
  get fragment() {
    return this.root.fragment;
  }
  getLayersOfType(e) {
    return this.root.getLayersOfType(e);
  }
  getLayerByUuid(e) {
    return this.root.getLayerByUuid(e);
  }
  updateByOp(e, t, o) {
    this.root.updateByOp(e, t, o);
  }
  nodeMaterialDispose() {
    this.root.nodeMaterialDispose();
  }
};
var si = class extends It {
  constructor(e, t) {
    super();
    this.data = e;
    this.layerIdGen = 0;
    this.flavors = [];
    this.type = "NodeMaterial";
    this.updaters = [], this.reset0(e, t);
  }
  get nodeMaterial() {
    return this;
  }
  getFlavor(e, t, o) {
    let i = o ? 6 : (e ? 3 : 0) + t;
    if (i === 0)
      return this;
    this.flavors === void 0 && (this.flavors = []), i -= 1;
    let s = this.flavors[i];
    return s === void 0 && (s = new Rd(e, t, o, this), this.flavors[i] = s, s.flatShading = e, s.side = t, s.updateAfterBuild()), s;
  }
  get fragment() {
    return this.lightLayer.node;
  }
  get category() {
    return this.lightLayer.category;
  }
  reset(e, t) {
    this.data !== e && this.reset0(e, t);
  }
  reset0(e, t) {
    this.data = e;
    let o = e.layers ?? wt.defaultTwoLayerData("phong").layers;
    this.layers = o.map((i) => Tr.create(this.layerIdGen++, i.id, i.data, t.shared)), this.layers.reverse(), this.name = e.name ?? "Untitled Material", this.onUpdate(), this.transparent = uy(e, t.shared);
  }
  getLayersOfType(e) {
    return this.layers.filter((t) => t.type === e);
  }
  getLayerByUuid(e) {
    return this.layers.find((t) => t.uuid === e);
  }
  onUpdate() {
    this.cacheKey = this.computeCacheKey(), this.lightLayer = this.layers.find((e) => e instanceof Pr), this.lightLayer === void 0 && (this.lightLayer = new Pr(0, "", { ...ft.defaultData("light", "phong"), visible: false }, new Mo(), {})), this.dispose(), this.needsUpdate = true, this.blendColors(), this.blendAfterColors(), this.blendPositions();
  }
  updateByOp(e, t, o) {
    var _a2, _b2, _c2;
    if (this.data = t, this.transparent = uy(t, o.shared), e.path[0] === "layers") {
      this.data = t;
      let i = o.shared, s = e.path[1];
      if (s === void 0) {
        if (this.layers.reverse(), e.type === 4) {
          let l = Tr.create(this.layerIdGen++, e.id, e.data, o.shared);
          this.layers.splice(e.localIndex, 0, l), (_a2 = o.scene) == null ? void 0 : _a2.markNeedsUpdateRendererDirty();
        } else if (e.type === 5)
          this.layers.splice(e.localIndex, 1)[0].dispose(), (_b2 = o.scene) == null ? void 0 : _b2.markNeedsUpdateRendererDirty();
        else if (e.type === 6) {
          let l = this.layers.findIndex((u) => u.uuid === e.id), c = this.layers[l];
          this.layers.splice(l, 1), this.layers.splice(e.localIndex, 0, c), (_c2 = o.scene) == null ? void 0 : _c2.markNeedsUpdateRendererDirty();
        }
        this.layers.reverse(), this.onUpdate();
      } else {
        let l = this.layers.find((c) => c.uuid === s);
        if (l) {
          let c = t.layers.data(s);
          if (l.updateByOp({ ...e, path: e.path.slice(2) }, c, o)) {
            let a = Tr.create(this.layerIdGen++, s, c, i);
            this.layers.splice(this.layers.findIndex((d) => d.uuid === s), 1, a), this.onUpdate();
          }
        }
      }
    } else
      this.reset(t, o);
  }
  blendColors() {
    let e = this.layers.findIndex((o) => o instanceof ke), t = this.layers.findIndex((o) => o instanceof Pr);
    if (e !== -1 && e < t) {
      let o = this.layers[e].color;
      for (let i = e + 1; i < t; ++i) {
        let s = this.layers[i];
        s instanceof ke && (o = new us(o, s.color, s.alpha, s.mode));
      }
      this.fragment.color = o;
    } else
      this.fragment.color = void 0;
  }
  blendAfterColors() {
    let e = new _e("outgoingLight", "f"), t = this.layers.findIndex((o) => o instanceof Pr);
    if (this.layers.length > t + 1) {
      for (let o = t + 1; o < this.layers.length; ++o) {
        let i = this.layers[o];
        i instanceof ke && (e = new us(e, i.color, i.alpha, i.mode));
      }
      this.fragment.afterColor = e;
    } else
      this.fragment.afterColor = void 0;
  }
  blendPositions() {
    let e = this.layers.filter((t) => t instanceof bs);
    if (e.length > 0) {
      let t = e[0].position;
      for (let o = 1; o < e.length; ++o)
        e[o] && (t = new Ot(t, e[o].position, Ot.ADD), t = new Ot(t, new J(0.5).setReadonly(true), Ot.MUL));
      this.fragment.position = t;
    } else
      this.fragment.position = void 0;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getVertexShader() {
    return this.vertexShader;
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  onBeforeCompile(e) {
    this.build(), e.defines = this.defines, e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.extensionDerivatives = this.extensions.derivatives === true, e.extensionFragDepth = this.extensions.fragDepth === true, e.extensionDrawBuffers = this.extensions.drawBuffers === true, e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === true;
  }
  clampUniformsForPreview(e, t) {
    let o = (i, s, l) => Math.min(Math.max(i, s), l);
    for (let i of this.layers)
      if (i.type === "displace") {
        let s = o(i.uniforms[`f${i.id}_intensity`].value, e, t);
        i.uniforms[`f${i.id}_intensity`].value = s;
      }
  }
  computeCacheKey() {
    let e = "[";
    for (let { data: t } of this.data.layers)
      if (t.type === "light")
        e += `"${t.visible ? t.category.toUpperCase() : "Basic"}"`;
      else {
        let o = (Ed[t.type] ?? []).map((l) => t[l]), i = (Md[t.type] ?? []).map((l) => {
          var _a2;
          return ((_a2 = t[l]) == null ? void 0 : _a2.length) ?? 0;
        }), s = [...o, ...i];
        s.length ? e += `["${t.type}", "${s.join('","')}"],` : e += `"${t.type}",`;
      }
    return e = e.slice(0, -1) + "]", e;
  }
  updateFrame(e) {
    for (let t = 0; t < this.updaters.length; ++t)
      e.updateNode(this.updaters[t]);
  }
  build() {
    let e = new pl();
    this.lights = this.lightLayer.data.visible, e.build(this.fragment, this.fragment), this.vertexShader = e.getCode("vertex"), this.fragmentShader = e.getCode("fragment"), this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.updaters = e.updaters;
    for (let t of this.flavors)
      t && t.updateAfterBuild();
    return this;
  }
  nodeMaterialDispose() {
    this.layers.forEach((e) => e.dispose()), super.dispose();
    for (let e of this.flavors)
      e && e.dispose();
  }
  assetsLoaded() {
    for (let e of this.layers)
      if (e instanceof ke) {
        let t = e.params.texture;
        if (t instanceof Lo && !t.image.loaded)
          return false;
      }
    return true;
  }
  getHash() {
    let e = "{";
    return e += '"fragment":' + this.fragment.getHash(), e += "}", e;
  }
};
Object.defineProperties(It.prototype, { properties: { get: function() {
  return this.fragment.properties;
} } });
var Do = class extends si {
};
var hy = Bs(py());
var fy = /* @__PURE__ */ new Map();
function my(n) {
  if (typeof n == "string")
    return n;
  let r = fy.get(n);
  return r || (r = { url: URL.createObjectURL(new Blob([n])) }, fy.set(n, r)), r.url;
}
var Go = class {
  constructor({ src: r, volume: e, delay: t, loop: o }) {
    this._volume = 1;
    this.delay = 0;
    this._loop = 1;
    this.loopsRemaining = 0;
    this._status = "stopped";
    this.onEnd = () => {
      this.loopsRemaining === 1 / 0 ? this.replay() : this.loopsRemaining > 1 ? (this.replay(), this.loopsRemaining--) : (this._status = "stopped", this.loopsRemaining = this._loop);
    };
    let i;
    typeof r == "string" ? i = { src: r } : i = { src: my(r), format: "wav" }, this.sound = new hy.Howl(i), this.sound.on("end", this.onEnd), this.src = r, e !== void 0 && (this.volume = e), t !== void 0 && (this.delay = t), o !== void 0 && (this.loop = o);
  }
  get status() {
    return this._status;
  }
  get volume() {
    return this._volume;
  }
  set volume(r) {
    this._volume = r, this.sound.volume(r);
  }
  get loop() {
    return this._loop;
  }
  set loop(r) {
    this._loop = r, this.loopsRemaining = r;
  }
  replay() {
    this.clearDelay(), this.delayTimerId = window.setTimeout(() => {
      this.sound.play(), this.clearDelay();
    }, this.delay);
  }
  fade(r, e = 1e3) {
    r ? (this.sound.volume(this._volume), this.clearFade(), this.fadeTimerId = window.setTimeout(() => {
      this.sound.fade(this._volume, 0, e), this.clearFade();
    }, r)) : this.sound.fade(this._volume, 0, e);
  }
  on(r, e, t) {
    this.sound.on(r, e, t);
  }
  off(r, e, t) {
    this.sound.off(r, e, t);
  }
  play() {
    this._status === "playing" || this.sound.playing() || (this._status === "paused" ? (this.sound.seek() === 0 ? this.replay() : this.sound.play(), this._status = "playing") : this._status === "stopped" && (this.replay(), this._status = "playing"));
  }
  pause() {
    this._status === "playing" && (this.sound.pause(), this.clearFade(), this.clearDelay(), this._status = "paused");
  }
  stop() {
    this.sound.stop(), this.loopsRemaining = this._loop, this.clearFade(), this.clearDelay(), this._status = "stopped";
  }
  clearFade() {
    this.fadeTimerId && (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
  }
  clearDelay() {
    this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId);
  }
  dispose(r = false) {
    this.off(), this.stop(), this.clearFade(), this.clearDelay();
  }
};
var Sl = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(r, e) {
    return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(r, e), this;
  }
  lineTo(r, e) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.lineTo(r, e), this;
  }
  quadraticCurveTo(r, e, t, o) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.quadraticCurveTo(r, e, t, o), this;
  }
  bezierCurveTo(r, e, t, o, i, s) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.bezierCurveTo(r, e, t, o, i, s), this;
  }
  splineThru(r) {
    var _a2;
    return (_a2 = this.currentPath) == null ? void 0 : _a2.splineThru(r), this;
  }
  toShapes() {
    let e = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }, t = { loc: e.ORIGIN, t: 0 };
    function o(h, y, g, v) {
      let S = h.x, w = y.x, b = g.x, T = v.x, _ = h.y, x = y.y, C = g.y, P = v.y, I = (T - b) * (_ - C) - (P - C) * (S - b), O = (w - S) * (_ - C) - (x - _) * (S - b), A = (P - C) * (w - S) - (T - b) * (x - _), G = I / A, z = O / A;
      if (A === 0 && I !== 0 || G <= 0 || G >= 1 || z < 0 || z > 1)
        return null;
      if (I === 0 && A === 0) {
        for (let $ = 0; $ < 2; $++)
          if (i($ === 0 ? g : v, h, y), t.loc === e.ORIGIN) {
            let te = $ === 0 ? g : v;
            return { x: te.x, y: te.y, t: t.t };
          } else if (t.loc === e.BETWEEN) {
            let te = +(S + t.t * (w - S)).toPrecision(10), K = +(_ + t.t * (x - _)).toPrecision(10);
            return { x: te, y: K, t: t.t };
          }
        return null;
      } else {
        for (let K = 0; K < 2; K++)
          if (i(K === 0 ? g : v, h, y), t.loc === e.ORIGIN) {
            let q = K === 0 ? g : v;
            return { x: q.x, y: q.y, t: t.t };
          }
        let $ = +(S + G * (w - S)).toPrecision(10), te = +(_ + G * (x - _)).toPrecision(10);
        return { x: $, y: te, t: G };
      }
    }
    function i(h, y, g) {
      let v = g.x - y.x, S = g.y - y.y, w = h.x - y.x, b = h.y - y.y, T = v * b - w * S;
      if (h.x === y.x && h.y === y.y) {
        t.loc = e.ORIGIN, t.t = 0;
        return;
      }
      if (h.x === g.x && h.y === g.y) {
        t.loc = e.DESTINATION, t.t = 1;
        return;
      }
      if (T < -Number.EPSILON) {
        t.loc = e.LEFT;
        return;
      }
      if (T > Number.EPSILON) {
        t.loc = e.RIGHT;
        return;
      }
      if (v * w < 0 || S * b < 0) {
        t.loc = e.BEHIND;
        return;
      }
      if (Math.sqrt(v * v + S * S) < Math.sqrt(w * w + b * b)) {
        t.loc = e.BEYOND;
        return;
      }
      let _;
      v !== 0 ? _ = w / v : _ = b / S, t.loc = e.BETWEEN, t.t = _;
    }
    function s(h, y) {
      let g = [], v = [];
      for (let S = 1; S < h.length; S++) {
        let w = h[S - 1], b = h[S];
        for (let T = 1; T < y.length; T++) {
          let _ = y[T - 1], x = y[T], C = o(w, b, _, x);
          C !== null && g.find((P) => P.t <= C.t + Number.EPSILON && P.t >= C.t - Number.EPSILON) === void 0 && (g.push(C), v.push(new Vector2(C.x, C.y)));
        }
      }
      return v;
    }
    function l(h, y, g) {
      let v = new Vector2();
      y.getCenter(v);
      let S = [];
      return g.forEach((w) => {
        w.boundingBox.containsPoint(v) && s(h, w.points).forEach((T) => {
          S.push({ identifier: w.identifier, isCW: w.isCW, point: T });
        });
      }), S.sort((w, b) => w.point.x - b.point.x), S;
    }
    function c(h, y, g, v, S) {
      (S == null || S === "") && (S = "nonzero");
      let w = new Vector2();
      h.boundingBox.getCenter(w);
      let b = [new Vector2(g, w.y), new Vector2(v, w.y)], T = l(b, h.boundingBox, y);
      T.sort((O, A) => O.point.x - A.point.x);
      let _ = [], x = [];
      T.forEach((O) => {
        O.identifier === h.identifier ? _.push(O) : x.push(O);
      });
      let C = _[0].point.x, P = [], I = 0;
      for (; I < x.length && x[I].point.x < C; )
        P.length > 0 && P[P.length - 1] === x[I].identifier ? P.pop() : P.push(x[I].identifier), I++;
      if (P.push(h.identifier), S === "evenodd") {
        let O = P.length % 2 === 0, A = P[P.length - 2];
        return { identifier: h.identifier, isHole: O, for: A };
      } else if (S === "nonzero") {
        let O = true, A = null, G = null;
        for (let z = 0; z < P.length; z++) {
          let $ = P[z];
          y[$] && (O ? (G = y[$].isCW, O = false, A = $) : G !== y[$].isCW && (G = y[$].isCW, O = true));
        }
        return { identifier: h.identifier, isHole: O, for: A };
      } else
        console.warn('fill-rule: "' + S + '" is currently not implemented.');
    }
    let u = 0, a = 999999999, d = -999999999, p = [];
    this.subPaths.forEach((h) => {
      let y = h.getPoints(), g = -999999999, v = 999999999, S = -999999999, w = 999999999;
      for (let b = 0; b < y.length; b++) {
        let T = y[b];
        T.y > g && (g = T.y), T.y < v && (v = T.y), T.x > S && (S = T.x), T.x < w && (w = T.x);
      }
      d <= S && (d = S + 1), a >= w && (a = w - 1), y.length && p.push({ curves: h.curves, points: y, isCW: ShapeUtils.isClockWise(y), identifier: u++, boundingBox: new Box2(new Vector2(w, v), new Vector2(S, g)) });
    });
    let f = p.map((h) => {
      var _a2;
      return c(h, p, a, d, (_a2 = this.userData) == null ? void 0 : _a2.style.fillRule);
    }), m = [];
    return p.forEach((h) => {
      let y = f[h.identifier];
      if (y && !y.isHole) {
        let g = new Shape();
        g.curves = h.curves, f.filter((S) => (S == null ? void 0 : S.isHole) && S.for === h.identifier).forEach((S) => {
          if (S) {
            let w = p[S.identifier], b = new Path();
            b.curves = w.curves, g.holes.push(b);
          }
        }), m.push(g);
      }
    }), m;
  }
};
var xy;
var Vd = new Promise((n) => {
  xy = n;
});
var gy = false;
async function vy() {
  if (gy)
    return;
  let n = await import("./opentype-PUSIHXD5.js");
  xy(n), gy = true;
}
var Ss = class {
  async load(r, e, t = () => {
  }) {
    let { load: o } = await Vd;
    o(r, (i, s) => {
      i || !s ? t(i ?? "Something went wrong") : e(s);
    });
  }
  async parse(r) {
    let { parse: e, Bidi: t } = await Vd;
    try {
      let o = e(r), i = new t(), s = (l) => o.charToGlyphIndex(l.char);
      return i.registerModifier("glyphIndex", null, s), i.applyFeatures(o, o.defaultRenderOptions.features), { font: o, bidi: i };
    } catch (o) {
      console.error(o);
    }
  }
};
async function FP(n) {
  return await (await fetch(n)).arrayBuffer();
}
var zP = new Ss();
async function jd(n) {
  let r, e, t = false;
  if (n.url ? (r = await FP(n.url), e = n.url, t = n.url.startsWith("/")) : n.data && (r = n.data.buffer), r) {
    let o = await zP.parse(r);
    if (o)
      return { font: o.font, url: e, intercepted: t, arr: r, bidi: o.bidi };
  }
}
function WP(n, r) {
  return r.state.glyphIndex === n || r.state.fina === n || r.state.medi === n || r.state.init === n;
}
var wl = class {
  constructor(r) {
    this._arrayBuffer = new ArrayBuffer(1);
    this._isLoaded = false;
    this._intercepted = false;
    this._isUserFont = r.isUserFont ?? false, this._loadingPromise = jd(r).then((e) => {
      e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = true, this._bidi = e.bidi);
    });
  }
  update(r) {
    this._isLoaded = false, this._isUserFont = r.isUserFont ?? false, this._loadingPromise = jd(r).then((e) => {
      e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = true, this._bidi = e.bidi);
    });
  }
  get url() {
    return this._url;
  }
  get intercepted() {
    return this._intercepted;
  }
  get isLoaded() {
    return this._isLoaded;
  }
  get loadingPromise() {
    return this._loadingPromise;
  }
  reverseLigaturesTable(r, e, t) {
    if (!this._bidi)
      return [];
    let o = this._bidi;
    o.getTextGlyphs(e);
    let i = o.tokenizer.tokens, s = [], l = 0, c = t.length === i.length;
    for (let u = 0; u < t.length; u++) {
      let a = t[u].index, d = String.fromCharCode(t[u].unicode), p = i[l];
      if (WP(a, p) || c)
        s.push({ char: d, index: a, replacements: [p.state.glyphIndex], replacementChars: [p.char] }), l++;
      else {
        let f = p.char, m = "", h = [p.state.glyphIndex], y = [], g = false;
        for (; !g; )
          l++, m = e.charAt(l), f += m, h.push(r.charToGlyphIndex(m)), y = r.stringToGlyphs(f), y.length === 1 && y[0].index === a && (g = true), l > e.length && (g = true);
        s.push({ char: d, index: a, replacements: h, replacementChars: Array.from(f) }), l++;
      }
    }
    return s;
  }
  generateShapes(r, e) {
    if (!this._isLoaded)
      return;
    let t = this.font, o = e.fontSize / this.unitsPerEm, i = e.fontSize * e.lineHeight, s = r.map((v) => this.getTextWidth(v, e)), l = e.width, c = this.getCharWidth(`
`, e), u = e.horizontalAlign === 1 ? c : 0, a = this.computeSpaceWidthForLine(r, 0, e), d = this.getLineInitialOffsetX(s[0], l, e.horizontalAlign, r[0], c), p = this.getLineInitialOffsetY(i, r.length, e.height, o, e.verticalAlign), f = [], m = r.map((v) => []), h = r.map((v) => []), y;
    for (let v = 0; v < r.length; v++) {
      let S = r[v], w = { features: { liga: true } }, b = [];
      try {
        b = t.stringToGlyphs(S, w);
      } catch (_) {
        console.warn(_);
      }
      d = this.getLineInitialOffsetX(s[v], l, e.horizontalAlign, S, c);
      let T = [];
      try {
        T = this.reverseLigaturesTable(t, S, b);
      } catch (_) {
        console.warn(_);
      }
      a = this.computeSpaceWidthForLine(r, v, e);
      for (let _ = 0; _ < b.length; _++) {
        let x = b[_], C = x.index === 0 ? `
` : x.unicode ? String.fromCharCode(x.unicode) : void 0, P = T[_], I = 0, O = 0;
        _ === 0 && e.horizontalAlign === 2 && x.leftSideBearing !== void 0 && (O = -x.leftSideBearing * o), y && (I = t.getKerningValue(x, y) * o), d += O + I;
        let A = 0;
        if (C === `
`)
          A = u;
        else if (C === " ")
          A = a;
        else {
          let G = this.createPath(x, o, d, p, e);
          G && (A = G.offsetX - (I + O), f.push(G.path));
        }
        if (P.replacements.length === 1)
          h[v].push([d, p]), m[v].push(A);
        else {
          let G = P.replacements.map((K) => (t.glyphs.get(K).advanceWidth ?? 0) * o), z = G.reduce((K, q) => K += q, 0), $ = G.map((K) => K / z), te = d;
          for (let K = 0; K < $.length; K++) {
            let q = A * $[K];
            h[v].push([te, p]), m[v].push(q), te += q;
          }
        }
        d += A, y = x;
      }
      p -= i;
    }
    let g = [];
    for (let v = 0, S = f.length; v < S; v++)
      g.push(...f[v].toShapes());
    return { shapes: g, charWidths: m, lineWidths: s, charCoords: h };
  }
  get isUserFont() {
    return this._isUserFont;
  }
  get arrayBuffer() {
    return this._arrayBuffer;
  }
  get ascender() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.ascender) ?? 0;
  }
  get descender() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.descender) ?? 0;
  }
  get familyName() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.names.fontFamily) ?? "";
  }
  get subfamilyName() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.names.fontSubfamily) ?? "";
  }
  get unitsPerEm() {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.unitsPerEm) ?? 1;
  }
  getLineInitialOffsetX(r, e, t, o, i) {
    return (t === 3 || t === 2) && o.indexOf(`
`) >= 0 && (r -= i), t === 3 ? e * 0.5 - r * 0.5 : t === 2 ? e - r : 0;
  }
  getLineInitialOffsetY(r, e, t, o, i) {
    let s = e * r, l = Math.abs(this.ascender - this.descender) * o, c = r - l, u = -this.ascender * o - c / 2;
    return i === 3 ? -(t - s - u) : i === 2 ? -(t * 0.5 - s * 0.5 - u) : u;
  }
  createPath(r, e, t, o, i) {
    var _a2;
    let s = r.getPath(t, -o, i.fontSize, { kerning: false, letterSpacing: i.letterSpacing });
    if (!s) {
      console.error('THREE.Font: character "' + r + '" does not exists in font family ' + this.familyName + ".");
      return;
    }
    let l = new Sl(), c = (r.advanceWidth ?? 1) * e;
    if (r)
      for (let u of s.commands) {
        let a = (_a2 = l.currentPath) == null ? void 0 : _a2.currentPoint;
        if (!(a && u.type !== "Z" && a.x === u.x && -a.y === u.y))
          switch (u.type) {
            case "M":
              l.moveTo(u.x, -u.y);
              break;
            case "L":
              l.lineTo(u.x, -u.y);
              break;
            case "Q":
              l.quadraticCurveTo(u.x1, -u.y1, u.x, -u.y);
              break;
            case "C":
              l.bezierCurveTo(u.x1, -u.y1, u.x2, -u.y2, u.x, -u.y);
              break;
          }
      }
    return l.subPaths.forEach((u) => {
      let a = qP(u.curves);
      a !== void 0 && u.currentPoint.distanceTo(a) > 0 && u.lineTo(a.x, a.y);
    }), { offsetX: c + i.fontSize * i.letterSpacing, path: l };
  }
  getCharWidth(r, e) {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.getAdvanceWidth(r, e.fontSize, { kerning: true, letterSpacing: e.letterSpacing })) ?? 0;
  }
  getTextWidth(r, e) {
    var _a2;
    return ((_a2 = this.font) == null ? void 0 : _a2.getAdvanceWidth(r, e.fontSize, { kerning: true, letterSpacing: e.letterSpacing })) ?? 0;
  }
  computeSpaceWidthForLine(r, e, t) {
    let o = this.getCharWidth(" ", t), i = r[e];
    if (i) {
      let s = this.countSpaces(i.trimEnd());
      if (t.horizontalAlign === 4 && e < r.length - 1 && s) {
        let l = t.width, c = this.getTextWidth(i, t);
        return (l - (c - s * o)) / s;
      }
    }
    return o;
  }
  countSpaces(r) {
    return (r.match(/ /g) || []).length;
  }
};
function qP(n) {
  if (n.length) {
    let r = n[0];
    if (r instanceof LineCurve)
      return r.v1;
    if (r instanceof CubicBezierCurve || r instanceof QuadraticBezierCurve)
      return r.v0;
  }
}
var Fd = class {
  constructor() {
    this.objects = /* @__PURE__ */ new Map();
    this.unreachable = /* @__PURE__ */ new Set();
  }
  getCached(r) {
    return this.objects.get(r);
  }
  get size() {
    return this.objects.size;
  }
  get(r, e) {
    let t = this.objects.get(r);
    return t === void 0 ? (t = this.createObject(r, e), this.objects.set(r, t)) : t.isShared = true, t;
  }
  mutateIfUnique(r, e) {
    let t = this.objects.get(r);
    if (t && t.isShared !== true)
      return this.objects.delete(r), this.objects.set(e, t), t;
  }
  startGc() {
    this.unreachable = new Set(this.objects.keys());
  }
  markAsReachable(r, e) {
    let t = this.objects.get(r);
    e === t ? this.unreachable.delete(r) : false;
  }
  endGc() {
    this.unreachable.forEach((r) => {
      this.disposeObject(this.objects.get(r)), this.objects.delete(r);
    }), this.unreachable.clear();
  }
  dispose() {
    this.objects.forEach((r) => {
      this.disposeObject(r);
    }), this.objects.clear();
  }
};
var ws = class extends Fd {
  constructor(e) {
    super();
    this.flatShading = e;
  }
  disposeObject(e) {
    e.dispose();
  }
  createObject(e, t) {
    let o = Co(e, t, this.flatShading);
    return o.computeBoundingSphere(), o;
  }
};
var by = { find(n) {
}, markNeedsUpdateRendererDirty: function() {
}, markGeometryCacheDirty: function() {
}, addPendingExpandCloner: function(n) {
}, addPendingUpdateCloner(n) {
}, addPendingCommand(n) {
} };
var zd = class extends gl {
  constructor(e) {
    super();
    this.shared = e;
  }
  create(e) {
    return new ni(e, this.shared);
  }
};
var Vo = class {
  constructor(r, e = {}) {
    this.geometryCache = new ws(true);
    this.geometryCache2 = new ws(false);
    this.imageHolderCache = new zd(this);
    this.thisContext = { scene: by, shared: this };
    this.deletedMaterial = new Do(wt.defaultTwoLayerData("phong"), this.thisContext);
    this.deletedImage = new zt(ln.emptyImage, this);
    this.deletedVideo = new zt(en.defaultVideo, this);
    this.materials = {};
    this.images = {};
    this.videos = {};
    this.colors = {};
    this.audios = {};
    this.fonts = {};
    this.penumbraSize = [];
    this.requestRender = () => {
      this._requestRender && this._requestRender();
    };
    if (e.images)
      for (let [t, o] of Object.entries(e.images))
        this.addImage(t, o);
    if (e.videos)
      for (let [t, o] of Object.entries(e.videos))
        this.addVideo(t, o);
    if (e.audios)
      for (let [t, o] of Object.entries(e.audios))
        this.addAudio(t, o.data);
    this.reset(r);
  }
  setRequestRender(r) {
    this._requestRender = r;
  }
  reset(r) {
    for (let [e, t] of Object.entries(r.images))
      this.addImage(e, t);
    for (let [e, t] of Object.entries(r.videos))
      this.addVideo(e, t);
    for (let [e, t] of Object.entries(r.colors))
      this.addColor(e, t);
    for (let [e, t] of Object.entries(r.materials))
      this.addMaterial(e, new Do(t, this.thisContext));
    for (let [e, t] of Object.entries(r.audios))
      this.addAudio(e, t.data);
    for (let [e, t] of Object.entries(r.fonts))
      this.addFont(e, t);
    this.penumbraSize = r.penumbraSize;
  }
  addMaterial(r, e) {
    e.uuid = r, this.materials[r] = e;
  }
  deleteMaterial(r) {
    this.materials[r] && (this.materials[r].nodeMaterialDispose(), delete this.materials[r]);
  }
  getMaterial(r) {
    let e = this.materials[r];
    return e;
  }
  getMaterialOrDeletedPlaceholder(r) {
    return this.materials[r] ?? this.deletedMaterial;
  }
  material(r) {
    return typeof r == "string" ? this.getMaterialOrDeletedPlaceholder(r) : new si(r, this.thisContext);
  }
  getMaterials() {
    return this.materials;
  }
  addImage(r, e) {
    return this.images[r] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), this.images[r].updateSrc(e.data), true) : (this.images[r] = new zt(e, this), false);
  }
  deleteImage(r) {
    let e = this.images[r];
    e && (e.dispose(), delete this.images[r]);
  }
  getDefaultImage() {
    return this.images.image_0;
  }
  getImage(r) {
    return this.images[r] ?? this.deletedImage;
  }
  image(r) {
    return typeof r == "string" ? this.getImage(r) : this.imageHolderCache.load(r);
  }
  addVideo(r, e) {
    return this.videos[r] ? (this.videos[r].updateSrc(e.data), true) : (this.videos[r] = new zt(e, this), false);
  }
  deleteVideo(r) {
    let e = this.videos[r];
    e && (e.dispose(), delete this.videos[r]);
  }
  getVideo(r) {
    return this.videos[r] ?? this.deletedVideo;
  }
  video(r) {
    return typeof r == "string" ? this.getVideo(r) : this.imageHolderCache.load(r);
  }
  addColor(r, e) {
    return this.colors[r] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), "a" in e ? this.colors[r].setRGBA(e.r, e.g, e.b, e.a) : this.colors[r].setRGBA(e.r, e.g, e.b, 1), true) : ("a" in e ? this.colors[r] = new uo(e.r, e.g, e.b, e.a) : this.colors[r] = new uo(e.r, e.g, e.b, 1), false);
  }
  updateColor(r, e) {
    if (this.colors[r]) {
      this.onColorOrImageUpdate && this.onColorOrImageUpdate();
      let t = this.colors[r];
      return this.colors[r].r = e.r ?? t.r, this.colors[r].g = e.g ?? t.g, this.colors[r].b = e.b ?? t.b, this.colors[r].a = e.a ?? t.a, true;
    }
    return false;
  }
  deleteColor(r) {
    this.colors[r] && delete this.colors[r];
  }
  getColor(r) {
    return this.colors[r];
  }
  color(r) {
    let e;
    if (typeof r == "string") {
      let t = this.getColor(r);
      t ? e = t : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), e = new $e(0, 0, 0, 0));
    } else
      return "a" in r ? new $e(r.r, r.g, r.b, r.a) : new $e(r.r, r.g, r.b, 1);
    return e;
  }
  addAudio(r, e) {
    this.audios[r] = e;
  }
  getAudio(r) {
    let e = this.audios[r];
    if (e instanceof Go)
      return e;
    {
      let t = new Go({ src: e });
      return this.audios[r] = t, t;
    }
  }
  deleteAudio(r) {
    let e = this.audios[r];
    e && (e instanceof Go && e.dispose(), delete this.audios[r]);
  }
  addFont(r, e) {
    this.fonts[r] = new wl(e), this.fonts[r].loadingPromise.then(() => this.requestRender());
  }
  getFont(r) {
    return this.fonts[r];
  }
  deleteFont(r) {
    this.fonts[r] && delete this.fonts[r];
  }
  dispose() {
    Object.keys(this.materials).forEach((e) => this.deleteMaterial(e)), this._requestRender = void 0, Object.values(this.audios).forEach((e) => {
      e instanceof Go && e.dispose();
    }), this.audios = {}, this.geometryCache.dispose(), this.geometryCache2.dispose();
  }
};
var Sy = new Vo(ca.emptyData());
var ir = class extends it {
  updateByPatchedOp(e, t, o) {
    if (super.updateByPatchedOp(e, t, o), uu(e.path, ["materials"]) !== null && e.type === 0 && Array.isArray(this.material))
      for (let [i, s] of Object.entries(e.props)) {
        let l = o.shared.material(s);
        this.material[Number(i)] = l;
      }
    else if (qt(e.path, ["material"]) && this.material instanceof It)
      "material" in t && typeof t.material != "string" && this.material.updateByOp(rt.drop(e, 1), t.material, o);
    else if (qt(e.path, ["materials", "*"]) && Array.isArray(this.material)) {
      let i = e.path[1];
      if ("materials" in t && i < this.material.length) {
        let s = t.materials[i];
        typeof s != "string" && this.material[i].updateByOp(rt.drop(e, 2), s, o);
      }
    }
  }
  updateState(e, t) {
    var _a2, _b2, _c2, _d2, _e2;
    super.updateState(e, t), e.castShadow !== void 0 && (this.castShadow = e.castShadow), e.receiveShadow !== void 0 && (this.receiveShadow = e.receiveShadow);
    let o = this.dataPatched;
    if (((_a2 = e.geometry) == null ? void 0 : _a2.type) !== "NonParametricGeometry" && "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = t.shared.material(e.material).getFlavor(o.flatShading, o.side, o.wireframe), (_b2 = t.scene) == null ? void 0 : _b2.markNeedsUpdateRendererDirty()), ((_c2 = e.geometry) == null ? void 0 : _c2.type) === "NonParametricGeometry" && ("materials" in e && e.materials !== void 0 ? (this.disposeMaterial(), this.material = e.materials.map((i) => t.shared.material(i).getFlavor(o.flatShading, o.side, o.wireframe)), (_d2 = t.scene) == null ? void 0 : _d2.markNeedsUpdateRendererDirty()) : "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = [t.shared.material(e.material).getFlavor(o.flatShading, o.side, o.wireframe)], (_e2 = t.scene) == null ? void 0 : _e2.markNeedsUpdateRendererDirty())), e.flatShading !== void 0 || e.wireframe !== void 0 || e.side !== void 0)
      if (Array.isArray(this.material))
        for (let i = 0; i < this.material.length; i++)
          this.material[i] = this.material[i].getFlavor(o.flatShading, o.side, o.wireframe);
      else
        this.material = this.material.getFlavor(o.flatShading, o.side, o.wireframe);
  }
  disposeMaterial() {
    this.material && la(this.material).forEach((e) => {
      e instanceof It && (e instanceof Do || e.nodeMaterialDispose());
    });
  }
  dispose() {
    this.disposeMaterial(), super.dispose();
  }
};
var lt = class extends ir {
  constructor(e, t, o) {
    super(e, t);
    this.data = t;
    this.localGeometry = void 0;
  }
  chooseGeoemtryCache(e) {
    return e.geometryCache;
  }
  markGeometryAsReachable(e) {
    this.geometryCreateDeleyed instanceof BufferGeometry && this.chooseGeoemtryCache(e).markAsReachable(this.dataPatched.geometry, this.geometryCreateDeleyed);
  }
  get geometry() {
    if (this.localGeometry !== void 0)
      return this.localGeometry;
    if (this.geometryCreateDeleyed instanceof Vo) {
      let e = this.geometryCreateDeleyed, t = this.chooseGeoemtryCache(e);
      this.geometryCreateDeleyed = t.get(this.dataPatched.geometry, e);
    }
    return this.geometryCreateDeleyed;
  }
  set geometry(e) {
    this.localGeometry = e;
  }
  get is2DAndNoDepth() {
    let e = this.dataPatched.geometry;
    return Oi.is2DParametricMesh(e.type) && e.depth === 0;
  }
  get is2DType() {
    return Oi.is2DParametricMesh(this.geometry.userData.type);
  }
  get isNonParametric() {
    return this.geometry.userData.type === "NonParametricGeometry";
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), qt(e.path, ["geometry"]) && this.updateByPatchedOpGeometry(rt.drop(e, 1), t.geometry, o);
  }
  removeInteractionGeometry() {
    var _a2;
    (_a2 = this.localGeometry) == null ? void 0 : _a2.dispose(), this.localGeometry = void 0;
  }
  updateGeometryInteractions(e, t) {
    var _a2;
    this.invalidateDownstreamBooleanData();
    let o = this.data.geometry.type;
    if (o === "NonParametricGeometry" || o === "SubdivGeometry") {
      let i = e;
      if (this.localGeometry === void 0) {
        let a = { ...this.data.geometry, ...i };
        this.localGeometry = Co(a, t, this.data.flatShading);
      }
      let s, l, c;
      i.scaleBaked ? [s, l, c] = i.scaleBaked : { width: s, height: l, depth: c } = i;
      let u = this.localGeometry.userData;
      u.sxPrev !== void 0 && Xi(this.localGeometry.attributes, s / u.sxPrev, l / u.syPrev, c / u.szPrev), u.sxPrev = s, u.syPrev = l, u.szPrev = c;
    } else {
      let i = { ...this.data.geometry, ...e };
      (_a2 = this.localGeometry) == null ? void 0 : _a2.dispose(), this.localGeometry = Co(i, t, this.data.flatShading);
    }
  }
  refreshAttachedCloners(e) {
    for (let t of this.attachedSurfaceCloners)
      e.scene.addPendingUpdateCloner(t.object);
  }
  refreshAttachedPaths(e) {
    for (let t of this.attachedPaths)
      e.scene.addPendingCommand(() => t.updateShape());
  }
  createGeometryDelayed(e) {
    this.geometryCreateDeleyed = e.shared, this.refreshAttachedCloners(e), this.refreshAttachedPaths(e);
  }
  updateByPatchedOpGeometry(e, t, o) {
    var _a2;
    let i = false;
    e.type === 0 && e.path.length === 0 && Ei(["scaleBaked"], Object.keys(e.props)) && this.geometryCreateDeleyed instanceof Fe && this.chooseGeoemtryCache(o.shared).mutateIfUnique(this.geometryCreateDeleyed.data, t) === this.geometryCreateDeleyed && (i = true, this.geometryCreateDeleyed.mutateDirectlyScaleBaked(t, e.props.scaleBaked), this.refreshAttachedCloners(o), this.refreshAttachedPaths(o)), i || ((_a2 = o.scene) == null ? void 0 : _a2.markGeometryCacheDirty(), this.createGeometryDelayed(o)), this.resetBBoxNeedsUpdate(), this.invalidateDownstreamBooleanData();
  }
  updateGeometryOnStateUpdate(e, t) {
    this.createGeometryDelayed(t);
  }
  updateState(e, t) {
    e.geometry !== void 0 && this.updateGeometryOnStateUpdate(e.geometry, t), super.updateState(e, t);
  }
  updateGeometryGroupsIfNeeded() {
    var _a2;
    Array.isArray(this.material) && this.geometry.groups.length === 0 && this.geometry.addGroup(0, Math.max(((_a2 = this.geometry.getIndex()) == null ? void 0 : _a2.count) ?? 0, this.geometry.getAttribute("position").count), 0);
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.userData.parameters;
    this.is2DType ? e.set(0, 0, o.depth * 0.5) : this.isNonParametric ? (e.setScalar(0), this.geometry.boundingSphere && e.copy(this.geometry.boundingSphere.center), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5)) : e.setScalar(0), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5);
  }
};
function XP(n) {
  var _a2, _b2;
  if (n.geometry.attributes.extrudeNormal || !n.geometry.attributes.position || !n.geometry.attributes.normal)
    return;
  let r = /* @__PURE__ */ new Map(), e = n.geometry.attributes, t = e.position.array, o = e.normal.array, i = new Float32Array(t.length);
  for (let s = 0; s < t.length; s += 3) {
    let l = `${t[s]}_${t[s + 1]}_${t[s + 2]}`, c = new Vector3(o[s], o[s + 1], o[s + 2]);
    r.has(l) ? (_a2 = r.get(l)) == null ? void 0 : _a2.normals.push(c) : r.set(l, { normals: [c], result: new Vector3() });
  }
  r.forEach((s, l) => {
    for (let c of s.normals)
      s.result.add(c);
    s.result.divideScalar(s.normals.length);
  });
  for (let s = 0; s < t.length; s += 3) {
    let l = `${t[s]}_${t[s + 1]}_${t[s + 2]}`, c = (_b2 = r.get(l)) == null ? void 0 : _b2.result;
    c && (i[s] = c.x, i[s + 1] = c.y, i[s + 2] = c.z);
  }
  n.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(i, 3));
}
function KP(n) {
  if (n.geometry.attributes.extrudeNormals || !n.geometry.attributes.position)
    return;
  let e = n.geometry.attributes.position.array, t = new Float32Array(e.length), o = new Vector3();
  for (let i = 0; i < e.length; i += 3)
    o.set(e[i], e[i + 1], e[i + 2]).normalize(), t[i] = o.x, t[i + 1] = o.y, t[i + 2] = o.z;
  n.geometry.setAttribute("extrudeNormal", new Float32BufferAttribute(t, 3));
}
function ai(n) {
  if (Array.isArray(n.material)) {
    for (let r of n.material)
      if (r.getLayersOfType("outline").length === 0)
        return;
  } else if (!(n.material instanceof It) || n.material.getLayersOfType("outline").length === 0)
    return;
  n instanceof lt && n.is2DAndNoDepth ? KP(n) : XP(n);
}
function li(n) {
  if (!n.geometry.attributes.position)
    return;
  let e = n.geometry.attributes.position.array, t = new Float32Array(e.length), o = parseInt(n.uuid.replace(/\D/g, "")), i = [MathUtils.seededRandom(o), MathUtils.seededRandom(o + 1e4), MathUtils.seededRandom(o + 2e4)];
  for (let s = 0; s < e.length; s++)
    t[s] = i[s % 3];
  n.geometry.setAttribute("randomColor", new BufferAttribute(t, 3));
}
var eO;
Yn.then((n) => {
  eO = n;
});
var Or = new Box3();
var _s = new Vector3();
function Ty(n) {
  let r = false;
  return n.scene.objects.traverse((e, t) => {
    t.type === "Mesh" && t.geometry.type === "SubdivGeometry" && (r = true);
  }), r;
}
var jo = class extends lt {
  constructor(e, t, o) {
    super(e, t, o);
    this.data = t;
    this.hiddenMatrixOld = new Matrix4();
    this.smoothShading = true;
    this.skipReactionUpdate = false;
  }
  chooseGeoemtryCache(e) {
    return this.dataPatched.flatShading ? e.geometryCache : e.geometryCache2;
  }
  get subdivPointerNew() {
    return this.localGeometry !== void 0 ? this.subdivPointer : this.geometry.ensureSubdivPointer();
  }
  get originalGeometryNew() {
    return this.localGeometry !== void 0 ? this.originalGeometry : this.geometry.originalGeometry;
  }
  get phongAngle() {
    return this.data.geometry.phongAngle ?? 45;
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.userData.parameters;
    e.copy(this.originalGeometryNew.boundingSphere.center), t.set(o.width, o.height, o.depth ?? 0).multiplyScalar(0.5);
  }
  createGeometryByControls(e) {
    var _a2, _b2, _c2;
    if (this.skipReactionUpdate === true)
      return;
    let t = (_a2 = this.localGeometry) == null ? void 0 : _a2.uuid, { originalGeometry: o, subdividedGeometry: i, subdivPointer: s } = Fe.build(e, this.subdivPointer, this.smoothShading, this.hasNonUniformScale ? this.shearScale : void 0);
    this.subdivPointer = s, o !== void 0 && ((_b2 = this.originalGeometry) == null ? void 0 : _b2.dispose(), this.originalGeometry = o), i !== void 0 && ((_c2 = this.subdividedGeometry) == null ? void 0 : _c2.dispose(), this.subdividedGeometry = i ?? void 0), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry, ai(this), li(this), this.calcBoundingBox(), t && (this.localGeometry.uuid = t);
  }
  updateState(e, t) {
    if (super.updateState(e, t), e.flatShading !== void 0) {
      let o = this.material;
      this.material = o.getFlavor(false, o.side, o.wireframe), this.smoothShading = !e.flatShading, this.createGeometryDelayed(t);
    }
  }
  updateMesh(e = false) {
    Fe.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1, this.originalGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0), this.subdividedGeometry && Fe.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1, this.subdividedGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0);
  }
  updateTopology() {
    this.originalGeometry.dispose(), this.originalGeometry = Fe.buildLevel(this.subdivPointer, true, this.smoothShading ? this.phongAngle : -1), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = Fe.buildLevel(this.subdivPointer, false, this.smoothShading ? this.phongAngle : -1)), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry;
  }
  raycast(e, t) {
    let o = this.localGeometry;
    this.localGeometry = this.originalGeometryNew, it.prototype.raycast.call(this, e, t), this.localGeometry = o;
  }
  activateSVDCompensation() {
    !this.hasNonUniformScale || (this.matrix.copy(this.matrixWorldRigid), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
  }
  deactivateSVDCompensation() {
    !this.hasNonUniformScale || (this.updateMatrix(), this.hasNonUniformScale = void 0, this.hiddenMatrix.copy(this.hiddenMatrixOld));
  }
  calcBoundingBox() {
    let e = this.originalGeometry;
    e.boundingSphere === null && (e.boundingSphere = new Sphere(), this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere));
    let t = e.attributes.position, o = e.boundingSphere.center;
    Or.setFromBufferAttribute(t), Or.getCenter(o), e.boundingSphere.radius = o.distanceTo(Or.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), Or.getSize(_s), this.hasNonUniformScale && _s.divide(this.scale);
    let i = { width: _s.x, height: _s.y, depth: _s.z };
    return this.geometry.userData.parameters = i, i;
  }
  updateBoundingSphere(e) {
    let t = this.originalGeometry;
    Or.min.set(e[0], e[2], e[4]), Or.max.set(e[1], e[3], e[5]), this.hasNonUniformScale && (Or.min.applyMatrix4(this.shearScaleInv), Or.max.applyMatrix4(this.shearScaleInv)), t.boundingSphere === null && (t.boundingSphere = new Sphere());
    let o = t.boundingSphere.center;
    Or.getCenter(o), t.boundingSphere.radius = o.distanceTo(Or.max);
  }
  freeSubdivPointer() {
    var _a2, _b2;
    this.subdivPointer && (Fe.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0), this.localGeometry = void 0, (_a2 = this.originalGeometry) == null ? void 0 : _a2.dispose(), (_b2 = this.subdividedGeometry) == null ? void 0 : _b2.dispose();
  }
  dispose() {
    super.dispose(), this.freeSubdivPointer();
  }
  updateByPatchedOpGeometry(e, t, o) {
    super.updateByPatchedOpGeometry(e, t, o), this.localGeometry && this.createGeometryByControls(t);
  }
};
var Py = -1;
var rO = 1;
var Oy = { x: [1, 0, 0], "-x": [-1, 0, 0], y: [0, 1, 0], "-y": [0, -1, 0], z: [0, 0, 1], "-z": [0, 0, -1] };
var Ay = { polygon_center: 0, edge: 1, vertex: 2 };
var Ts = (n, r) => (e, t) => !r || e === 0 || n === 0 ? 0 : n * t / 100;
var me = (n, r) => {
  let e = Math.abs(r), t = e * -1;
  return (n - Py) * (e - t) / (rO - Py) + t;
};
function Iy(n) {
  let r = [], e = {};
  for (var t = 0, o = n.length; t < o; t++) {
    var i = JSON.stringify(n[t].pos.map((s) => Math.round(s * 1e4) / 1e4));
    e[i] || (r.push(n[t]), e[i] = true);
  }
  return r;
}
var oO = new Vector3();
var _l = new Vector3();
var nO = new Vector3();
var iO = new Vector3();
function ci(n, r) {
  let e = nO.fromArray(n), t = iO.fromArray(r);
  _l.copy(t).sub(e);
  let o = _l.length();
  return _l.normalize().multiplyScalar(o * 0.5), oO.copy(e).add(_l).toArray();
}
var Ut = new Triangle();
var Tl = new Vector3();
var Pl = new Vector3();
var Fo = new Vector3();
function Cy(n) {
  let r = [];
  for (let e = 0; e <= n.index.count; e++)
    if (Tl.fromArray(n.index.array, e * 3), Ut.setFromAttributeAndIndices(n.attributes.position, Tl.x, Tl.y, Tl.z), Ut.getNormal(Pl), Ut.getMidpoint(Fo), !(isNaN(Fo.x) || isNaN(Fo.y) || isNaN(Fo.z))) {
      let { a: t, b: o, c: i } = Ut, s = t.toArray(), l = o.toArray(), c = i.toArray(), u = t.distanceTo(o), a = o.distanceTo(i), d = i.distanceTo(t), p = ci(s, l), f = ci(l, c), m = ci(c, s), h = [u, a, d], y = Math.max(...h), g = h.filter((w) => Math.round(w) === Math.round(y)).length > 1, v = [], S = Ut.getMidpoint(Fo).toArray();
      y === u && !g && (v = [f, m, m], S = p), y === a && !g && (v = [p, m, m], S = f), y === d && !g && (v = [p, f, f], S = m), g && (v = [p, f, m]), r.push({ vertices: [s, l, c], faceCenters: v, midpoint: S, norm: Ut.getNormal(Pl).toArray() });
    }
  return r;
}
function Ny(n) {
  let r = [], { position: e } = n.attributes;
  for (let t = 0; t < e.count; t++) {
    Ut.setFromAttributeAndIndices(e, t * 3, t * 3 + 1, t * 3 + 2), Ut.getNormal(Pl), Ut.getMidpoint(Fo);
    let o = Ut.a.toArray(), i = Ut.b.toArray(), s = Ut.c.toArray();
    r.push({ vertices: [o, i, s], faceCenters: [ci(o, i), ci(i, s), ci(s, o)], midpoint: Fo.toArray(), norm: Pl.toArray() });
  }
  return r;
}
var sO = 4;
var aO = 0.5;
var Hd = (n) => 0.5 * (1 - Math.cos(n * Math.PI));
var Wd = class {
  constructor() {
    this.perlin = new Array(4095 + 1);
  }
  noise(r, e = 0, t = 0) {
    if (this.perlin == null) {
      this.perlin = new Array(4095 + 1);
      for (let g = 0; g < 4095 + 1; g++)
        this.perlin[g] = Math.random();
    }
    r < 0 && (r = -r), e < 0 && (e = -e), t < 0 && (t = -t);
    let o = Math.floor(r), i = Math.floor(e), s = Math.floor(t), l = r - o, c = e - i, u = t - s, a, d, p = 0, f = 0.5, m, h, y;
    for (let g = 0; g < sO; g++) {
      let v = o + (i << 4) + (s << 8);
      a = Hd(l), d = Hd(c), m = this.perlin[v & 4095], m += a * (this.perlin[v + 1 & 4095] - m), h = this.perlin[v + 16 & 4095], h += a * (this.perlin[v + 16 + 1 & 4095] - h), m += d * (h - m), v += 256, h = this.perlin[v & 4095], h += a * (this.perlin[v + 1 & 4095] - h), y = this.perlin[v + 16 & 4095], y += a * (this.perlin[v + 16 + 1 & 4095] - y), h += d * (y - h), m += Hd(u) * (h - m), p += m * f, f *= aO, o <<= 1, l *= 2, i <<= 1, c *= 2, s <<= 1, u *= 2, l >= 1 && (o++, l--), c >= 1 && (i++, c--), u >= 1 && (s++, u--);
    }
    return p;
  }
  noiseSeed(r) {
    let e = (() => {
      let s, l;
      return { setSeed(c) {
        l = s = (c ?? Math.random() * 4294967296) >>> 0;
      }, getSeed() {
        return s;
      }, rand() {
        return l = (1664525 * l + 1013904223) % 4294967296, l / 4294967296;
      } };
    })();
    e.setSeed(r), this.perlin = new Array(4095 + 1);
    for (let t = 0; t < 4095 + 1; t++)
      this.perlin[t] = e.rand();
  }
};
var Ey = Wd;
var My = new Vector3();
var Ly = new Matrix4();
var By = new Ray();
function Dy(n) {
  let r = false;
  return n.scene.objects.traverse((e, t) => {
    t.type === "Mesh" && t.geometry.type === "TextGeometry" && (r = true);
  }), r;
}
var di = class extends lt {
  constructor(e, t, o) {
    super(e, t, o);
    this.data = t;
  }
  get textGeometry() {
    return this.geometry;
  }
  get charWidths() {
    return this.textGeometry.charWidths;
  }
  get charCoords() {
    return this.textGeometry.charCoords;
  }
  get wrappedText() {
    return this.textGeometry.wrappedText;
  }
  get font() {
    return this.textGeometry.font;
  }
  get initialOffsetY() {
    var _a2;
    let e = this.dataPatched;
    return ((_a2 = this.font) == null ? void 0 : _a2.getLineInitialOffsetY(this.lineHeight, this.wrappedText.length, e.geometry.height, this.fontScale, e.geometry.verticalAlign)) ?? 0;
  }
  get fontScale() {
    let e = this.dataPatched;
    return this.font ? e.geometry.fontSize / this.font.unitsPerEm : 1;
  }
  get AD() {
    return Math.abs(this.ascender - this.descender);
  }
  get ascender() {
    var _a2;
    return (((_a2 = this.font) == null ? void 0 : _a2.ascender) ?? 1) * this.fontScale;
  }
  get descender() {
    var _a2;
    return (((_a2 = this.font) == null ? void 0 : _a2.descender) ?? 1) * this.fontScale;
  }
  get lineHeight() {
    let e = this.dataPatched;
    return e.geometry.fontSize * e.geometry.lineHeight;
  }
  raycast(e, t) {
    let { matrixWorld: o } = this;
    if (!(isNaN(e.ray.origin.x) || this.scale.x === 0 || this.scale.y === 0 || this.scale.z === 0) && (Ly.copy(o).invert(), By.copy(e.ray).applyMatrix4(Ly), By.intersectBox(this.singleBBox, My))) {
      let i = My.applyMatrix4(o), s = e.ray.origin.distanceTo(i);
      t.push({ distance: s, point: i.clone(), object: this });
    }
  }
};
var yt = 1e-4;
var Ar;
var jy;
var Fy;
var zy;
var Ry = new Vector3();
var Vy = new Vector3();
Yn.then((n) => {
  Ar = n, jy = [Ar.get_face_center, Ar.get_edge_midpoint, Ar.get_vertex_position], Fy = [Ar.get_face_normal, Ar.get_edge_normal, Ar.get_vertex_normal], zy = [Ar.face_count, Ar.edge_count, Ar.vertex_count];
});
var pO = new Matrix4();
var fO = new Matrix4();
var fo = new Vector3();
var Uo = new Vector3();
var Ps = new Vector3();
var $d = new Vector3();
var mO = new Vector3();
var hO = new Vector3();
var kr = new Ey();
var pi = class extends Mn(Object3D) {
  constructor(e, t) {
    super();
    this.parameters = t;
    this.objectForSample = void 0;
    this._pendingMediaLoad = false;
    this.object = e;
  }
  resetOnMove() {
    this.removeFromParent(), this.parent = null;
  }
  expandClones(e) {
    if (this.parent === null)
      this.updateState(this.parameters, e);
    else
      for (let t of this.children)
        t instanceof Fr && t.expand();
  }
  invalidateTransform(e) {
    this.matrixWorldNeedsUpdate = true, this.traverse((t) => {
      t instanceof Fr && t.object === e && (t.matrixWorldNeedsUpdate = true);
    });
  }
  onObjUpdateMatrix() {
    this.parameters.type !== "toObject" && (this.matrixWorldNeedsUpdate = true);
  }
  update() {
    switch (this._updateCount(), this.parameters.type) {
      case "radial":
        this._updateRadial(this.parameters);
        break;
      case "linear":
        this._updateLinear(this.parameters);
        break;
      case "grid":
        this._updateGrid(this.parameters);
        break;
      case "toObject":
        this._updateToObject(this.parameters);
    }
    for (let e of this.children)
      e.updateMatrix(), e.hasNonUniformScale && (e.updateMatrixWorld(), e.updateMatrixWorldSVD());
  }
  _updateCount(e) {
    let t;
    if (e !== void 0 ? t = e : t = this.parameters.type === "grid" ? Math.round(this.parameters.grid.count[0]) * Math.round(this.parameters.grid.count[1]) * Math.round(this.parameters.grid.count[2]) : this.parameters.count, this.parameters.type === "toObject" && !this.parameters.toObject.object && (t = 0), this.parameters.type === "toObject" && this.objectForSample) {
      for (let i = 0, s = this.children.length; i < s; ++i)
        this.remove(this.children[0]);
      let o = this.children;
      if (o.length === t)
        return;
      if (o.length < t)
        for (let i = 0, s = t - o.length; i < s; ++i) {
          let l = new Fr(this.object);
          l.expand(), this.add(l);
        }
      else
        for (let i = 0, s = o.length - t; i < s; ++i)
          this.remove(o[i]);
    } else {
      if (this.children.length === t)
        return;
      if (this.children.length < t)
        for (let o = 0, i = t - this.children.length; o < i; ++o) {
          let s = new Fr(this.object);
          s.expand(), this.add(s);
        }
      else
        for (let o = 0, i = this.children.length - t; o < i; ++o)
          this.remove(this.children[0]);
    }
  }
  _updateRadial(e) {
    let t = e.radial, o = t.start * MathUtils.DEG2RAD, i = t.end * MathUtils.DEG2RAD, s = o - i, l = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), c;
    switch (t.axis) {
      case "z":
        c = new Vector3(0, 0, 1);
        break;
      case "y":
        c = new Vector3(0, 1, 0);
        break;
      default:
      case "x":
        c = new Vector3(1, 0, 0);
        break;
    }
    let u = e.randomnessObject ?? fr.defaultData([1, 1, 1]).randomnessObject, a = u.noiseType === "perlin";
    kr.noiseSeed(u.seed);
    let d = Ra((0, ui.default)(u.seed)), p = Ts(u.strength, this.parameters.randomness);
    for (let [f, m] of this.children.entries()) {
      let h = f * (u.freqScale / 10) + u.movement, y = a ? kr.noise(h) : d(h, h);
      m.scale.x = t.scale[0] + p(f, me(y, u.scale[0])) || yt, m.scale.y = t.scale[1] + p(f, me(y, u.scale[1])) || yt, m.scale.z = t.scale[2] + p(f, me(y, u.scale[2])) || yt, m.position.setScalar(0);
      let g = s / e.count * f - o;
      switch (t.axis) {
        case "x":
          m.rotation.set(0, g, 0);
          break;
        case "y":
          m.rotation.set(0, 0, g);
          break;
        case "z":
          m.rotation.set(g, 0, 0);
          break;
      }
      m.translateOnAxis(c, t.radius), m.position.x += t.position[0] + p(f, me(y, u.position[0])), m.position.y += t.position[1] + p(f, me(y, u.position[1])), m.position.z += t.position[2] + p(f, me(y, u.position[2]));
      let v = p(f, me(y, u.rotation[0])), S = p(f, me(y, u.rotation[1])), w = p(f, me(y, u.rotation[2]));
      t.alignment === true ? (m.rotation.x += l.x + v, m.rotation.y += l.y + S, m.rotation.z += l.z + w) : m.rotation.set(l.x + v, l.y + S, l.z + w);
    }
  }
  _updateLinear(e) {
    if (e.type !== "linear")
      throw new Error();
    let t = e.linear, o = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), i = e.randomnessObject ?? fr.defaultData([1, 1, 1]).randomnessObject, s = i.noiseType === "perlin";
    kr.noiseSeed(i.seed);
    let l = Ra((0, ui.default)(i.seed)), c = Ts(i.strength, this.parameters.randomness);
    for (let [u, a] of this.children.entries()) {
      let d = u * (i.freqScale / 10) + i.movement, p = s ? kr.noise(d) : l(d, d), f = c(u, me(p, i.rotation[0])), m = c(u, me(p, i.rotation[1])), h = c(u, me(p, i.rotation[2]));
      a.scale.x = 1 + (t.scale[0] - 1) * u + c(u, me(p, i.scale[0])) || yt, a.scale.y = 1 + (t.scale[1] - 1) * u + c(u, me(p, i.scale[1])) || yt, a.scale.z = 1 + (t.scale[2] - 1) * u + c(u, me(p, i.scale[2])) || yt, a.rotation.x = o.x * u + f, a.rotation.y = o.y * u + m, a.rotation.z = o.z * u + h, a.position.x = t.position[0] * u + c(u, me(p, i.position[0])), a.position.y = t.position[1] * u + c(u, me(p, i.position[1])), a.position.z = t.position[2] * u + c(u, me(p, i.position[2]));
    }
  }
  _updateGrid(e) {
    let t = 0, o = e.grid, i = e.randomnessObject ?? fr.defaultData([1, 1, 1]).randomnessObject, s = Ts(i.strength, this.parameters.randomness), l = i.noiseType === "perlin";
    kr.noiseSeed(i.seed);
    let c = Om((0, ui.default)(i.seed));
    if (o.useCenter === true) {
      let u = { x: o.count[0] % 2 === 0 ? 2 : 1, y: o.count[1] % 2 === 0 ? 2 : 1, z: o.count[2] % 2 === 0 ? 2 : 1 }, a = new Vector3(o.size[0] * (o.count[0] - u.x) * 0.5, o.size[1] * (o.count[1] - u.y) * 0.5, o.size[2] * (o.count[2] - u.z) * 0.5);
      for (let d = 0; d < o.count[0]; d++)
        for (let p = 0; p < o.count[1]; p++)
          for (let f = 0; f < o.count[2]; f++) {
            let m = [(d + 1) * (i.freqScale / 10) + i.movement, (p + 1) * (i.freqScale / 10) + i.movement, (f + 1) * (i.freqScale / 10) + i.movement], h = l ? kr.noise(...m) : c(...m), y = this.children[t++];
            y.scale.x = 1 + s(t, me(h, i.scale[0])) || yt, y.scale.y = 1 + s(t, me(h, i.scale[1])) || yt, y.scale.z = 1 + s(t, me(h, i.scale[2])) || yt;
            let g = s(t, me(h, i.rotation[0])), v = s(t, me(h, i.rotation[1])), S = s(t, me(h, i.rotation[2]));
            y.rotation.set(g, v, S), y.position.x = o.size[0] * d - a.x + s(t, me(h, i.position[0])), y.position.y = o.size[1] * p - a.y + s(t, me(h, i.position[1])), y.position.z = o.size[2] * f - a.z + s(t, me(h, i.position[2]));
          }
    } else
      for (let u = 0; u < o.count[0]; u++)
        for (let a = 0; a < o.count[1]; a++)
          for (let d = 0; d < o.count[2]; d++) {
            let p = [(u + 1) * (i.freqScale / 10) + i.movement, (a + 1) * (i.freqScale / 10) + i.movement, (d + 1) * (i.freqScale / 10) + i.movement], f = l ? kr.noise(...p) : c(...p), m = this.children[t++];
            m.scale.x = 1 + s(t, me(f, i.scale[0])) || yt, m.scale.y = 1 + s(t, me(f, i.scale[1])) || yt, m.scale.z = 1 + s(t, me(f, i.scale[2])) || yt;
            let h = s(t, me(f, i.rotation[0])), y = s(t, me(f, i.rotation[1])), g = s(t, me(f, i.rotation[2]));
            m.rotation.set(h, y, g), m.position.x = o.size[0] * u + s(t, me(f, i.position[0])), m.position.y = -o.size[1] * a + s(t, me(f, i.position[1])), m.position.z = -o.size[2] * d + s(t, me(f, i.position[2]));
          }
  }
  _updateToObject(e) {
    var _a2;
    if (e.type !== "toObject")
      throw new Error();
    let { toObject: t } = e, o = new Euler(t.rotation[0], t.rotation[1], t.rotation[2]), i = e.randomnessObject ?? fr.defaultData([1, 1, 1]).randomnessObject, s = i.noiseType === "perlin";
    kr.noiseSeed(i.seed);
    let l = Ra((0, ui.default)(i.seed)), c = Ts(i.strength, this.parameters.randomness);
    if (!t.object) {
      for (let [, g] of this.children.entries())
        g.position.set(0, 0, 0), g.scale.setScalar(1), g.rotation.set(0, 0, 0);
      this.objectForSample = void 0;
      return;
    }
    if (!this.objectForSample)
      return;
    if (this.objectForSample instanceof di)
      if (!((_a2 = this.objectForSample.font) == null ? void 0 : _a2.isLoaded) || this.objectForSample.geometry.attributes.position === void 0) {
        this._pendingMediaLoad = true;
        return;
      } else
        this._pendingMediaLoad = false;
    if (this.objectForSample.geometry === void 0 && this.objectForSample.isAncestorOf(this.object.uuid)) {
      console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`);
      return;
    }
    let u = this.getSubdivData(), a = [], d = (g) => {
      let v = g.length, S = g.map((T) => T[0]).reduce((T, _) => T + _, 0), w = g.map((T) => T[1]).reduce((T, _) => T + _, 0), b = g.map((T) => T[2]).reduce((T, _) => T + _, 0);
      return [S / v, w / v, b / v];
    }, p = (g) => Math.round(g * 1e6) / 1e6;
    u.forEach((g) => {
      let v = u.filter((S) => p(g.pos[0]) === p(S.pos[0]) && p(g.pos[1]) === p(S.pos[1]) && p(g.pos[2]) === p(S.pos[2]));
      v.length > 1 ? a.push({ pos: g.pos, norm: d(v.map((S) => S.norm)) }) : a.push(g);
    });
    let f = Iy(a);
    if (u.length > 0) {
      let g = Math.round(f.length * t.count / 100);
      this._updateCount(g);
    }
    this.objectForSample.updateMatrixWorld();
    let m = new Va(this.objectForSample).build(), h = Oy[t.axis], y = this.children;
    m.setRandomGenerator((0, ui.default)(this.object.uuid + t.seed));
    for (let [g, v] of y.entries()) {
      let S = g * (i.freqScale / 10) + i.movement, w = s ? kr.noise(S) : l(S, S), b = c(g, me(w, i.rotation[0])), T = c(g, me(w, i.rotation[1])), _ = c(g, me(w, i.rotation[2]));
      t.spreadType === "random" ? m.sample(Ps, $d) : (f.length && (Ps.fromArray(f[g].pos), $d.fromArray(f[g].norm)), this.objectForSample instanceof jo && Ps.applyMatrix4(pO.copy(this.objectForSample.matrixWorld).invert())), Ps.applyMatrix4(this.object.hiddenMatrix.clone().invert()), v.position.copy(Ps), fo.fromArray(h);
      let x = t.align === "normal" ? $d : this.object.getWorldDirection(hO), C = Uo.fromArray(t.position);
      Uo.x += Uo.x + c(g, me(w, i.position[0])), Uo.y += Uo.y + c(g, me(w, i.position[1])), Uo.z += Uo.z + c(g, me(w, i.position[2]));
      let P = Math.acos(x.dot(fo)), I = mO.crossVectors(fo, x).normalize(), O = fO.makeRotationAxis(I, P), A = x.clone().cross(this.object.up).normalize(), G = A.clone().cross(x).normalize(), z = new Matrix4().makeBasis(A, x, G), $ = new Vector3(fo.y, fo.z, fo.x).normalize(), te = $.clone().cross(fo).normalize(), K = new Matrix4().makeBasis($, fo, te).invert(), q = new Matrix4().multiplyMatrices(z, K);
      v.rotation.setFromRotationMatrix(q), C.applyMatrix4(O), v.position.add(C), v.rotation.x = v.rotation.x + o.x + b, v.rotation.y = v.rotation.y + o.y + T, v.rotation.z = v.rotation.z + o.z + _, v.scale.setScalar(1), v.scale.x = v.scale.x + t.scale[0] + c(g, me(w, i.scale[0])) || yt, v.scale.y = v.scale.y + t.scale[1] + c(g, me(w, i.scale[1])) || yt, v.scale.z = v.scale.z + t.scale[2] + c(g, me(w, i.scale[2])) || yt, v.scale.multiply(this.object.scale), v.hiddenMatrix = this.object.hiddenMatrix;
    }
  }
  getSubdivData() {
    if (!this.objectForSample)
      return [];
    let e = this.parameters.toObject.spreadType;
    if (e === "random")
      return [];
    if (this.objectForSample instanceof jo) {
      let t = this.objectForSample, o = Ay[e], i = zy[o], s = jy[o], l = Fy[o], c = [], u = i(t.subdivPointerNew);
      for (let a = 0; a <= u - 1; a++) {
        let d = s(t.subdivPointerNew, a), p = l(t.subdivPointerNew, a);
        Ry.fromArray(d).applyMatrix4(t.matrixWorld), Vy.fromArray(p), c.push({ pos: Ry.toArray(), norm: Vy.toArray() });
      }
      return c;
    } else
      return (this.objectForSample.geometry.index ? Cy(this.objectForSample.geometry) : Ny(this.objectForSample.geometry)).map((o, i) => e === "polygon_center" ? { pos: o.midpoint, norm: o.norm } : e === "vertex" ? [{ pos: o.vertices[0], norm: o.norm }, { pos: o.vertices[1], norm: o.norm }, { pos: o.vertices[2], norm: o.norm }] : e === "edge" ? [{ pos: o.faceCenters[0], norm: o.norm }, { pos: o.faceCenters[1], norm: o.norm }, { pos: o.faceCenters[2], norm: o.norm }] : []).flat();
  }
  updateState(e, t) {
    var _a2;
    if (this.parameters = Vr(e), this.parameters.type !== "toObject")
      (this.parent === null || this.parent !== this.object) && (this.removeFromParent(), (_a2 = this.object.parent) == null ? void 0 : _a2.add(this), this.matrix = this.object.matrix, this.hiddenMatrix = this.object.hiddenMatrix, this.matrixWorldNeedsUpdate = true, this.matrixAutoUpdate = false);
    else if (this.parent === null || this.parent.uuid !== this.parameters.toObject.object) {
      this.removeFromParent();
      let o = t.find(this.parameters.toObject.object);
      o instanceof it ? this.objectForSample = o : this.objectForSample = void 0, this.matrix = new Matrix4(), this.hiddenMatrix = new Matrix4(), this.matrixWorldNeedsUpdate = true, this.matrixAutoUpdate = false, o && o.add(this);
    }
    this.update();
  }
  get pendingMediaLoad() {
    return this._pendingMediaLoad;
  }
};
var Ir = (n) => {
  var r;
  return r = class extends n {
  }, r.geometryHelper = new BoxGeometry(30, 30, 30), r;
};
var Ol = new Ray();
var Yd = new Sphere();
var Uy = new Matrix4();
var Cr = (n, r, e, t, o = false) => {
  let i = r, s = n.matrixWorld;
  if (i.boundingSphere === null && i.computeBoundingSphere(), Yd.copy(i.boundingSphere), Yd.applyMatrix4(s), e.ray.intersectsSphere(Yd) === false || (Uy.copy(s).invert(), Ol.copy(e.ray).applyMatrix4(Uy), i.boundingBox !== null && Ol.intersectsBox(i.boundingBox) === false))
    return;
  let l, c, u, a, d = i.index, p = i.attributes.position, f = i.drawRange, m, h;
  if (o === false) {
    let g = Math.max(0, f.start), v = Math.min(d.count, f.start + f.count);
    for (m = g, h = v; m < h; m += 3)
      if (c = d.getX(m), u = d.getX(m + 1), a = d.getX(m + 2), l = y(n, e, Ol, p, c, u, a), l) {
        l.faceIndex = Math.floor(m / 3), t.push(l);
        return;
      }
  } else {
    let v = i.attributes.position, S = new Vector3(), w = new Vector3(), b = new Vector3(), T = new Vector3(), _ = 2, C = 1 / ((n.scale.x + n.scale.y + n.scale.z) / 3), P = C * C, I = Math.max(0, f.start), O = Math.min(v.count, f.start + f.count);
    for (let A = I, G = O - 1; A < G; A += _) {
      if (S.fromBufferAttribute(v, A), w.fromBufferAttribute(v, A + 1), Ol.distanceSqToSegment(S, w, T, b) > P)
        continue;
      T.applyMatrix4(n.matrixWorld);
      let $ = e.ray.origin.distanceTo(T);
      $ < e.near || $ > e.far || t.push({ distance: $, point: b.clone().applyMatrix4(n.matrixWorld), object: n });
    }
  }
  function y(g, v, S, w, b, T, _) {
    let x = new Vector3(), C = new Vector3(), P = new Vector3(), I = new Vector3(), O = new Vector3();
    if (x.fromBufferAttribute(w, b), C.fromBufferAttribute(w, T), P.fromBufferAttribute(w, _), S.intersectTriangle(x, C, P, false, I) === null)
      return null;
    O.copy(I), O.applyMatrix4(g.matrixWorld);
    let G = v.ray.origin.distanceTo(O);
    return G < v.near || G > v.far ? null : { faceIndex: 1, distance: G, point: O.clone(), object: g };
  }
};
var Al = new Vector3();
var kt = new Camera();
var Kd = class extends LineSegments {
  constructor(e) {
    let t = new BufferGeometry(), o = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false }), i = [], s = [], l = {}, c = new Color(15711266), u = new Color(15711266), a = new Color(2857471);
    d("n1", "n2", c), d("n2", "n4", c), d("n4", "n3", c), d("n3", "n1", c), d("f1", "f2", c), d("f2", "f4", c), d("f4", "f3", c), d("f3", "f1", c), d("n1", "f1", c), d("n2", "f2", c), d("n3", "f3", c), d("n4", "f4", c), d("p", "n1", u), d("p", "n2", u), d("p", "n3", u), d("p", "n4", u), d("u1", "u2", a), d("u2", "u3", a), d("u3", "u1", a);
    function d(f, m, h) {
      p(f, h), p(m, h);
    }
    function p(f, m) {
      i.push(0, 0, 0), s.push(m.r, m.g, m.b), l[f] === void 0 && (l[f] = []), l[f].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Float32BufferAttribute(i, 3)), t.setAttribute("color", new Float32BufferAttribute(s, 3));
    super(t, o);
    this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = l, this.update();
  }
  update() {
    let e = this.geometry, t = this.pointMap, o = true;
    kt.projectionMatrixInverse.elements = [0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0, -0, -0, -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001];
    let i = 1, s = 1, l = o ? 0.8 : 1e-4;
    sr("n1", t, e, kt, -i, -s, l), sr("n2", t, e, kt, i, -s, l), sr("n3", t, e, kt, -i, s, l), sr("n4", t, e, kt, i, s, l);
    let c = l;
    sr("f1", t, e, kt, -i, -s, c), sr("f2", t, e, kt, i, -s, c), sr("f3", t, e, kt, -i, s, c), sr("f4", t, e, kt, i, s, c);
    let u = c, a = 0.5;
    sr("u1", t, e, kt, i * 0.7 * a, s * 1.1, u), sr("u2", t, e, kt, -i * 0.7 * a, s * 1.1, u), sr("u3", t, e, kt, 0, s * (1.1 + 0.9 * a), u), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function sr(n, r, e, t, o, i, s) {
  Al.set(o, i, s).unproject(t);
  let l = r[n];
  if (l !== void 0) {
    let c = e.getAttribute("position");
    for (let u = 0, a = l.length; u < a; u++)
      c.setXYZ(l[u], Al.x, Al.y, Al.z);
  }
}
var Il = class extends Ir(Kd) {
  constructor(e) {
    super(e);
    this.object = e;
    this.object = e, this.name = `CombinedCameraHelper: ${e.uuid}`;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.updateTarget();
  }
  updateTarget() {
    let e = this.object.getTarget();
    this.updateWorldMatrix(true, false), this.worldToLocal(e);
  }
  raycast(e, t) {
    Cr(this.object, this.geometry, e, t, true);
  }
};
var Cl;
((r) => r.is = (e) => "objectHelper" in e)(Cl || (Cl = {}));
var mo = (n, r) => class extends Ua(n) {
  constructor() {
    super(...arguments);
    this.objectHelper = new r(this);
    this.gizmos = {};
  }
  get geometryHelper() {
    return r.geometryHelper;
  }
  raycast(o, i) {
    this.objectHelper.raycast(o, i);
  }
  showGizmos() {
    for (let o in this.gizmos) {
      let i = this.gizmos[o];
      i instanceof Box3Helper && (i.visible = true);
    }
  }
  updateEntityBoxSize(o, i) {
    this.objectHelper.visible && this.geometryHelper instanceof BoxGeometry ? (o.setScalar(0), i.set(this.geometryHelper.parameters.width, this.geometryHelper.parameters.height, this.geometryHelper.parameters.height).multiplyScalar(0.5)) : super.updateEntityBoxSize(o, i);
  }
  hideGizmos() {
    for (let o in this.gizmos) {
      let i = this.gizmos[o];
      i instanceof Box3Helper && (i.visible = false);
    }
  }
};
var Zd = 790;
var fi = new Vector3();
var Qd = new Vector3();
var Wr = class extends mo(Camera, Il) {
  constructor(e = "", t = { ...nn.defaultData, name: "" }) {
    super();
    this._cameraType = "OrthographicCamera";
    this.targetOffset = bo.DefaultTargetOffset;
    this.isUpVectorFlipped = false;
    this.angleOffsetFromUp = 0;
    this.wasMovedByUser = false;
    this.super_Entity(e, t), this.matrixAutoUpdate = true, this.width = window.innerWidth, this.height = window.innerHeight;
    let o = this.width, i = this.height;
    if (t.orthographic.autoZoom) {
      let s = t.orthographic.autoZoomFrustumSize ?? Zd, l = o / i, c = o > i ? l : 1, u = o > i ? 1 : l;
      this.orthoCamera = new OrthographicCamera(-s * 0.5 * c, s * 0.5 * c, s * 0.5 * (1 / u), -s * 0.5 * (1 / u), -5e4, 1e4);
    } else
      this.orthoCamera = new OrthographicCamera(o * -0.5, o * 0.5, i * 0.5, i * -0.5, -5e4, 1e4);
    this.perspCamera = new PerspectiveCamera(45, o / i, 50, 1e4), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.objectHelper.update();
  }
  get isPerspectiveCamera() {
    return this.cameraType === "PerspectiveCamera";
  }
  get isOrthographicCamera() {
    return !this.isPerspectiveCamera;
  }
  get cameraType() {
    return this._cameraType;
  }
  set fov(e) {
    this.perspCamera.fov = e;
  }
  get fov() {
    return this.perspCamera.fov;
  }
  setNear(e, t) {
    e === "PerspectiveCamera" ? this.perspCamera.near = t : this.orthoCamera.near = t;
  }
  setZoom(e, t) {
    t >= 0 && (e === "PerspectiveCamera" ? this.perspCamera.zoom = t : this.orthoCamera.zoom = t);
  }
  set cameraType(e) {
    e === "PerspectiveCamera" ? this.toPerspective() : e === "OrthographicCamera" && this.toOrthographic();
  }
  get near() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near;
  }
  set near(e) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = e : this.orthoCamera.near = e;
  }
  get zoom() {
    return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom;
  }
  set zoom(e) {
    e >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = e : this.orthoCamera.zoom = e);
  }
  lookAt(e, t, o) {
    typeof e == "number" && (e = new Vector3(e, t, o)), super.lookAt(e), this.getWorldPosition(fi), this.targetOffset = fi.distanceTo(e);
  }
  getTarget(e = new Vector3()) {
    return this.getWorldDirection(Qd), this.getWorldPosition(fi), Qd.multiplyScalar(this.targetOffset), e.copy(fi).add(Qd), e;
  }
  getDistanceToTarget() {
    let e = this.getTarget();
    return this.getWorldPosition(fi), fi.distanceTo(e);
  }
  updateUp() {
    let e = this.getWorldQuaternion(new Quaternion()), t = new Vector3(0, 0, 1).applyQuaternion(e), o = new Vector3().copy(Object3D.DEFAULT_UP);
    this.isUpVectorFlipped && o.negate(), o.applyQuaternion(e);
    let i = new Vector3().copy(Object3D.DEFAULT_UP).projectOnPlane(t), s = new Vector3().crossVectors(i, o).dot(t) >= 0 ? 1 : -1;
    this.angleOffsetFromUp = i.angleTo(o) * s;
  }
  updateTransformState(e) {
    let t = super.updateTransformState(e);
    return e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateUp(), t;
  }
  getViewFrontToObject(e) {
    let t = e.getWorldPosition(new Vector3()), i = e.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().add(i), target: t };
  }
  getViewToObject(e) {
    let t = e.getWorldPosition(new Vector3()), i = this.getWorldDirection(new Vector3()).multiplyScalar(this.targetOffset);
    return { position: t.clone().sub(i), target: t };
  }
  setViewplaneSize(e, t) {
    if (this.aspect = e / t, this.data.type === "OrthographicCamera" && this.data.orthographic.autoZoom) {
      let o = this.data.orthographic.autoZoomFrustumSize ?? Zd, i = e > t ? this.aspect : 1, s = e > t ? 1 : this.aspect;
      this.left = -o * 0.5 * i, this.right = o * 0.5 * i, this.top = o * 0.5 * (1 / s), this.bottom = -o * 0.5 * (1 / s);
    } else
      this.left = -e * 0.5, this.right = e * 0.5, this.top = t * 0.5, this.bottom = -t * 0.5;
    this.updateProjectionMatrix();
  }
  toOrthographic() {
    this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", this.objectHelper && this.objectHelper.update();
  }
  toPerspective() {
    this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", this.objectHelper && this.objectHelper.update();
  }
  setFocalLength(e) {
    this.perspCamera.setFocalLength(e), this.toPerspective();
  }
  getFocalLength() {
    return this.perspCamera.getFocalLength();
  }
  getEffectiveFOV() {
    return this.perspCamera.getEffectiveFOV();
  }
  getFilmWidth() {
    return this.perspCamera.getFilmWidth();
  }
  getFilmHeight() {
    return this.perspCamera.getFilmHeight();
  }
  setViewOffset(e, t, o, i, s, l) {
    this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(e, t, o, i, s, l) : this.orthoCamera.setViewOffset(e, t, o, i, s, l);
  }
  clearViewOffset() {
    this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
  }
  updateProjectionMatrix() {
    this._cameraType === "PerspectiveCamera" ? this.toPerspective() : this._cameraType === "OrthographicCamera" && this.toOrthographic();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  copy(e, t) {
    return super.copy(e, t), this.orthoCamera.copy(e.orthoCamera), this.perspCamera.copy(e.perspCamera), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.far = e.far, this.view = e.view === null ? null : Object.assign({}, e.view), this._cameraType = e._cameraType, this.aspect = e.aspect, this.fov = e.fov, this.focus = e.focus, this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this.targetOffset = e.targetOffset, this.updateProjectionMatrix(), this;
  }
  toCameraState(e = []) {
    let t = { type: this.cameraType, far: this.far, orthographic: { near: this.orthoCamera.near, zoom: this.orthoCamera.zoom, autoZoom: true, autoZoomFrustumSize: Zd }, perspective: { near: this.perspCamera.near, fov: this.perspCamera.fov, zoom: this.perspCamera.zoom }, up: this.up.toArray(), targetOffset: this.targetOffset, isUpVectorFlipped: this.isUpVectorFlipped };
    return Nn(t, e);
  }
  updateCameraSubtype(e, t) {
    let o = e === "perspective" ? "PerspectiveCamera" : "OrthographicCamera";
    t.zoom !== void 0 && this.setZoom(o, t.zoom), t.near !== void 0 && this.setNear(o, t.near), t.fov !== void 0 && o === "PerspectiveCamera" && (this.fov = t.fov);
  }
  updateState(e, t) {
    this.updateCameraState(e, t);
  }
  updateCameraState(e, t) {
    this.updateState_Entity(e, t), e.far !== void 0 && (this.far = e.far), e.orthographic !== void 0 && this.updateCameraSubtype("orthographic", e.orthographic), e.perspective !== void 0 && this.updateCameraSubtype("perspective", e.perspective), e.type !== void 0 && (this.cameraType = e.type), e.up !== void 0 && this.up.fromArray(e.up), e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset), e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateProjectionMatrix();
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), e.path.length === 1 && e.type === 0 && this.updateCameraSubtype(e.path[0], e.props);
  }
  toState(e) {
    return { ...super.toState(e), ...this.toCameraState(e), type: this.cameraType };
  }
};
var Yy = new Matrix4();
var Wt = class extends ir {
  constructor(e, t, o) {
    super(e, t);
    this.data = t;
    this.meshSetAddresses = [];
    this.needsTransformForDownstream = false;
    this.geometry = new BufferGeometry();
    this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 };
  }
  get booleanOp() {
    return this.data.geometry.operation;
  }
  get phongAngle() {
    return this.data.geometry.phongAngle ?? 45;
  }
  get isLOD() {
    return this.recomputeBoolean(), false;
  }
  updateByPatchedOp(e, t, o) {
    super.updateByPatchedOp(e, t, o), e.path.length === 1 && e.path[0] === "geometry" && e.type === 0 && e.props.operation !== void 0 && (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
  }
  freeBooleanPointer() {
    super.freeBooleanPointer(), this.geometry.dispose();
  }
  recomputeBoolean(e, t = true) {
    var _a2;
    if (this.booleanMeshSetAddress !== -1 && !e)
      return;
    for (let i = 0; i < this.children.length; i++) {
      let s = this.children[i];
      s instanceof Wt && s.recomputeBoolean(e === true, t);
    }
    this.meshSetAddresses = [];
    for (let i = 0; i < this.children.length; i++) {
      let s = this.children[i];
      if (s instanceof it && s.dataPatched.visible === true && ((_a2 = s.geometry.attributes.position) == null ? void 0 : _a2.count) > 0 && s.geometry.drawRange.count > 0) {
        if (s.booleanMeshSetAddress === -1) {
          if ((s.geometry.index ?? s.geometry.getAttribute("position")).count / 3 < 15e5 && (s.booleanMeshSetAddress = tr.getMeshSet(s.geometry, e === true, t)), s.booleanMeshSetAddress === -1)
            return;
          tr.transformMeshSet(s.booleanMeshSetAddress, s.matrix), s.booleanMatrixInvOld.copy(s.matrix).invert(), s.booleanWasTransformed = false;
        } else
          s instanceof Wt && s.needsTransformForDownstream === true ? (tr.transformMeshSet(s.booleanMeshSetAddress, s.matrix), s.needsTransformForDownstream = false) : s.booleanWasTransformed === true && (Yy.multiplyMatrices(s.matrix, s.booleanMatrixInvOld), tr.transformMeshSet(s.booleanMeshSetAddress, Yy), s.booleanMatrixInvOld.copy(s.matrix).invert(), s.booleanWasTransformed = false);
        this.meshSetAddresses.push(s.booleanMeshSetAddress);
      }
    }
    if (this.meshSetAddresses.length === 0) {
      this.geometry.setAttribute("position", new Float16BufferAttribute([], 0)), this.geometry.setDrawRange(0, 0);
      return;
    }
    if (e === true)
      return tr.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
    let o = this.geometry;
    o.dispose(), this.geometry = new BufferGeometry(), this.geometry.userData = o.userData, this.geometry.boundingSphere = o.boundingSphere;
    try {
      this.booleanMeshSetAddress = tr.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry, this.phongAngle);
    } catch (i) {
      this.booleanMeshSetAddress = 0, console.error(i);
    }
    this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = true, ai(this), li(this);
  }
  dispose() {
    super.dispose(), this.geometry.dispose();
  }
};
var Xy;
((r) => {
  function n(e) {
    return Ce.is(e) && e instanceof Light;
  }
  r.is = n;
})(Xy || (Xy = {}));
var mi = (n, r) => class extends mo(n, r) {
  updateState_Light(t, o) {
    this.updateState_Entity(t, o), t.color !== void 0 && (this.color = o.shared.color(t.color)), t.intensity !== void 0 && (this.intensity = t.intensity), t.depth !== void 0 && (this.shadow.camera.far = t.depth, this.shadow.needsUpdate = true), t.shadows !== void 0 && (this.castShadow = t.shadows);
  }
};
var Os = (n) => n instanceof it;
var As = (n) => n !== null && n instanceof Wt;
var Ky = (n) => n instanceof Wr;
var Zy = (n) => Cl.is(n);
var ho = class extends Ir(AxesHelper) {
  constructor(e, t = 15) {
    super(t);
    this.object = e;
    this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${e.uuid}`, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
  }
  raycast(e, t) {
    Cr(this.object, ho.geometryHelper, e, t);
  }
  update() {
  }
};
var Is = class extends mo(Group, ho) {
  constructor(r, e) {
    super(), this.super_Entity(r, e), this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Entity(r, e);
  }
};
var hi = class extends Ir(DirectionalLightHelper) {
  constructor(e, t = 15, o = 10066329) {
    super(e, t, o);
    this.object = e;
    this.added = false;
    this.name = `DirectionalLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Cr(this.object, hi.geometryHelper, e, t);
  }
};
var yi = class extends Ir(PointLightHelper) {
  constructor(e, t = 15, o = 6710886) {
    super(e, t, o);
    this.object = e;
    this.name = `PointLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Cr(this.object, yi.geometryHelper, e, t);
  }
};
var Nl = class extends Ir(SpotLightHelper) {
  constructor(e, t = 6710886) {
    super(e, t);
    this.object = e;
    this.name = `SpotLightHelper: ${e.uuid}`;
  }
  raycast(e, t) {
    Cr(this.object, Nl.geometryHelper, e, t);
  }
  update() {
    if (this.object !== void 0) {
      let e = Nl._vector, t = this.object.distance ? this.object.distance : 1e3, o = t * Math.tan(this.object.angle);
      this.cone.scale.set(o, o, t), e.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e);
      let i = this.color !== void 0 ? this.color : this.light.color;
      if (this.cone.material instanceof Array)
        for (let s = 0, l = this.cone.material.length; s < l; s++)
          this.cone.material[s].color.set(i);
      else
        this.cone.material.color.set(i);
    }
  }
};
var Cs = Nl;
Cs._vector = new Vector3();
function FO(n, r) {
  n.shadow.camera.right = r / 2, n.shadow.camera.left = -r / 2, n.shadow.camera.top = r / 2, n.shadow.camera.bottom = -r / 2, n.shadow.needsUpdate = true;
}
var El = class extends mi(DirectionalLight, hi) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 2048, this.shadow.mapSize.height = 2048, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.top = 1250, i.bottom = -1250, i.right = 1250, i.left = -1250, i.near = -1e4, i.far = 2500;
    let s = new CameraHelper(this.shadow.camera);
    s.visible = false, this.gizmos.shadowmap = s;
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let r in this.gizmos) {
      let e = this.gizmos[r];
      e instanceof CameraHelper && e.update();
    }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e);
    let t = r.depth !== void 0 && r.depth !== this.shadow.camera.far || r.size !== void 0 && r.size / 2 !== this.shadow.camera.right;
    r.size !== void 0 && FO(this, r.size), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), t && this.update();
  }
};
var Ll = class extends mi(PointLight, yi) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.fov = 90, i.aspect = 1, i.near = 100, i.far = 2500;
    let s = new Vector3(-i.far + this.position.x, -i.far + this.position.y, -i.far + this.position.z), l = new Vector3(i.far + this.position.x, i.far + this.position.y, i.far + this.position.z), c = new Box3(s, l), u = new Box3Helper(c, new Color(16755200));
    u.visible = false, this.gizmos.shadowmap = u, this.update();
  }
  update() {
    if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this.gizmos))
      for (let r in this.gizmos) {
        let e = this.gizmos[r];
        if (e instanceof Box3Helper) {
          let t = this.shadow.camera, o = new Vector3(-t.far + this.position.x, -t.far + this.position.y, -t.far + this.position.z), i = new Vector3(t.far + this.position.x, t.far + this.position.y, t.far + this.position.z);
          e.box.set(o, i), e.updateMatrixWorld(true);
        }
      }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e), r.distance !== void 0 && (this.distance = r.distance), r.decay !== void 0 && (this.decay = r.decay), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null));
  }
};
var tg = new Vector3();
var rg = new Vector3();
var og = new Quaternion();
var Bl = class extends mi(SpotLight, Cs) {
  constructor(r, e, t) {
    super(), this.super_Entity(r, e), this.castShadow = true, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3);
    let i = this.shadow.camera;
    i.fov = MathUtils.RAD2DEG * 2 * this.angle, i.aspect = 1, i.near = 100, i.far = 2500;
    let s = new CameraHelper(this.shadow.camera);
    s.visible = false, this.gizmos.shadowmap = s, this.update();
  }
  update() {
    this.shadow.camera.updateProjectionMatrix();
    for (let r in this.gizmos) {
      let e = this.gizmos[r];
      e instanceof CameraHelper && e.update();
    }
  }
  updateMatrixWorld(r) {
    super.updateMatrixWorld(r), rg.setFromMatrixPosition(this.matrixWorld), og.setFromRotationMatrix(this.matrixWorld), tg.copy(this.up).applyQuaternion(og).negate().multiplyScalar(this.distance), this.target.position.copy(rg).add(tg), this.target.updateMatrixWorld(), this.objectHelper && this.objectHelper.update();
  }
  updateState(r, e) {
    this.updateState_Light(r, e), r.distance !== void 0 && (this.distance = r.distance), r.decay !== void 0 && (this.decay = r.decay), r.angle !== void 0 && (this.angle = r.angle), r.penumbra !== void 0 && (this.penumbra = r.penumbra), r.shadowRadius !== void 0 && (this.shadow.radius = r.shadowRadius), r.shadowResolution !== void 0 && (this.shadow.mapSize.set(r.shadowResolution, r.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null));
  }
};
var Dl = class extends lt {
  get forceComputeSize() {
    return true;
  }
  get shape() {
    return this.geometry.userData.shape;
  }
  updateEntityBoxSize(r, e) {
    let t = this.geometry.getAttribute("position");
    t !== void 0 ? Qi(t, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : t.count, r, e) : super.updateEntityBoxSize(r, e);
  }
};
var gi = class extends lt {
  constructor(e, t, o) {
    super(e, t, o);
    this._shapeId = null;
    this._context = o;
  }
  updateState(e, t) {
    super.updateState(e, t), this.updateShape();
  }
  updateShape() {
    var _a2;
    let e = this.data.geometry.extrusion.shape, t;
    if (e.type === "Custom") {
      let i = e.shapeId;
      if (i !== this._shapeId && this.detachShape(), i) {
        this._shapeId = i;
        let s = this._context.scene.find(i);
        (s == null ? void 0 : s.data) && (s.attachedPaths.add(this), t = (_a2 = s.geometry.userData) == null ? void 0 : _a2.shape), t || this._context.scene.addPendingCommand(() => this.updateShape());
      }
    } else {
      let i;
      switch (e.type) {
        case "Rectangle":
          i = il;
          break;
        case "Ellipse":
          i = Un;
          break;
        case "Polygon":
          i = nl;
          break;
        case "Star":
          i = sl;
          break;
        default:
          throw new Error(`Unknown shape type: ${e.type}`);
      }
      t = i.create({ parameters: e }).userData.shape;
    }
    let o = this.geometry;
    t && o.inputs && (o.inputs.shapeData = t, o.build(), this.attachedSurfaceCloners.forEach((i) => i.update()));
  }
  detachShape() {
    var _a2;
    this._shapeId !== null && ((_a2 = this._context.scene.find(this._shapeId)) == null ? void 0 : _a2.attachedPaths.delete(this));
  }
  createGeometryDelayed(e) {
    this.geometryCreateDeleyed = e.shared, this.updateShape(), this.refreshAttachedPaths(e);
  }
  updateTransformState(e) {
    return super.updateTransformState(e);
  }
  updateGeometryInteractions(e, t) {
    super.updateGeometryInteractions(e, t), this.updateShape();
  }
  updateEntityBoxSize(e, t) {
    let o = this.geometry.getAttribute("position");
    o !== void 0 ? Qi(o, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : o.count, e, t) : super.updateEntityBoxSize(e, t);
  }
};
var qr = class extends mo(Group, ho) {
  constructor(e, t, o) {
    super();
    t.type === "Instance" && typeof e == "string" && (t = this.transformAssignData(t, o)), this.super_Entity(e, t), this.objectHelper.update();
  }
  get isComponentRoot() {
    return this.data.type === "Component" && typeof this.identity == "string";
  }
  get isInstanceRoot() {
    return this.data.type === "Instance" && typeof this.identity == "string";
  }
  transformAssignData(e, t) {
    let o = t.scene.data.objects.get(e.component);
    if (o) {
      let i, s;
      for (let l of Jr.rootOverrideProps)
        e[l] === void 0 ? (i === void 0 && (i = { ...e }), i[l] = o.data[l]) : (s === void 0 && (s = {}), s[l] = e[l]);
      return this.overrideData = s, i ?? e;
    }
    return e;
  }
  updateByOp(e, t, o, i) {
    let s;
    if (this.isInstanceRoot && !i && (t = this.transformAssignData(t, o), e.type === 0 && e.path.length === 0 && this.component))
      for (let l of Jr.rootOverrideProps)
        l in e.props && e.props[l] === void 0 && (s === void 0 && (s = { ...e, props: { ...e.props } }), s.props[l] = this.component.data[l]);
    super.updateByOp(s ?? e, t, o, i);
  }
  updateState(e, t) {
    this.updateState_Entity(e, t);
  }
  expandInstanceChildren(e) {
    let t = this.data;
    if (this.component === void 0) {
      this.component = e.scene.find(t.component) ?? null;
      let o = false;
      if (this.component !== this.oldComponent) {
        if (this.oldComponent) {
          let i = 0;
          for (let s of this.children)
            if (Ce.is(s))
              e.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(s), Gl(s), i += 1;
            else
              break;
          this.children.splice(0, i);
        }
        o = true;
      }
      this.component && sg(e, [this.uuid], t.overrides, this, this.component, this.component, 0, o), this.oldComponent = this.component;
    }
  }
};
function Gl(n) {
  if (n.component) {
    let r = n.component.instances.indexOf(n);
    r >= 0 && n.component.instances.splice(r, 1);
    for (let e of n.children)
      Ce.is(e) && Gl(e);
  }
}
function ig(n, r, e, t) {
  return n.component === r && Ei(n.identity, t) ? n.overrideData === e ? 2 : 1 : 0;
}
function sg(n, r, e, t, o, i, s, l) {
  if (s > 50)
    return false;
  if (t.component !== o) {
    if (t.component) {
      let u = t.component.instances.indexOf(t);
      u >= 0 && t.component.instances.splice(u, 1);
    }
    o.instances.push(t), t.component = o;
  }
  o instanceof qr && o.isInstanceRoot && o.expandInstanceChildren(n);
  let c = 0;
  for (let u of o.children)
    if (Ce.is(u)) {
      let a = [...r, ...typeof u.identity == "string" ? [u.identity] : u.identity], d = sn.resolve(e, a, 1), p = null, f;
      if (!l) {
        let m = t.children[c];
        if (p = Ce.is(m) ? m : null, p !== null) {
          let h = ig(p, u, d, a);
          f = h >= 1 ? p.stateSelection : void 0, h !== 2 && (p = null);
        }
        if (p === null && (p = n.scene.findInstance(a) ?? null, p !== null)) {
          let h = ig(p, u, d, a);
          if (f = h >= 1 ? p.stateSelection : void 0, h !== 2)
            p = null;
          else {
            let y = p.parent.children.indexOf(p);
            p.parent.children.splice(y, 1), t.children.splice(c, 0, p), p.parent === t ? (y <= c && console.error("not possible"), void 0) : (p.parent = t, p.matrixWorldNeedsUpdate = true, p.resetBBoxNeedsUpdate(), p.updateVisible(), n.pendingDeletes.delete(p), void 0);
          }
        }
      }
      if (p === null) {
        let m = d ? Er.apply(u.data, d) : u.data;
        Yt.is(m.type) && (m = { ...m, type: "Empty" }), p = Kt.createEntity(a, m, n), p.overrideData = d, t.add(p), t.children.splice(t.children.length - 1, 1), t.children.splice(c, 0, p), p.updateState(p.data, n), f && p.changeSelectedState(f, n), n.scene.registerInstanceAndSetUuid(p);
      }
      c += 1, sg(n, r, e, p, u, i, s + 1, l);
    }
  if (!l) {
    let u = c;
    for (; ; ) {
      let a = t.children[c];
      if (Ce.is(a))
        n.pendingDeletes.add(a);
      else
        break;
      c += 1;
    }
    t.children.splice(u, c - u);
  }
  return true;
}
function YO(n, r, e) {
  let t;
  return r.geometry.type === "TextGeometry" ? new di(n, r, e) : (r.geometry.type === "SubdivGeometry" ? t = new jo(n, r, e) : r.geometry.type === "PathGeometry" ? t = new gi(n, r, e) : r.geometry.type === "VectorGeometry" ? t = new Dl(n, r, e) : r.geometry.type === "BooleanGeometry" ? t = new Wt(n, r, e) : t = new lt(n, r, e), t);
}
function Rl(n, r, e) {
  return r.type === "Mesh" ? YO(n, r, e) : r.type === "Empty" ? new Is(n, r) : r.type === "PointLight" ? new Ll(n, r, e) : r.type === "SpotLight" ? new Bl(n, r, e) : r.type === "DirectionalLight" ? new El(n, r, e) : r.type === "Component" || r.type === "Instance" ? new qr(n, r, e) : Yt.is(r.type) ? new Wr(n, r) : (console.error(r), new Is(n, r));
}
Kt.createEntity = Rl;
function XO(n, r, e) {
  let t = Rl(n.identity, r, e), o = n.children, i = n.attachedPaths, s = n.parent, l = n.component, c = n.instances, u = n.overrideData, a = n.uuid, d = n.stateSelection;
  n.dispose();
  for (let p of Object.keys(n))
    delete n[p];
  Object.setPrototypeOf(n, Object.getPrototypeOf(t));
  for (let p of Object.keys(t))
    n[p] = t[p];
  n.children = [...n.children, ...o], n.attachedPaths = i, n.parent = s, n.component = l, n.instances = c, n.uuid = a, n.overrideData = u, n.updateState(n.data, e), d && n.changeSelectedState(d, e), n.resetBBoxNeedsUpdate();
}
Kt.changeEntityProptotype = XO;
Kt.Cloner = pi;
function ag(n, r, e, t) {
  n.updateByOp(r, e, t, false);
}
function lg(n, r) {
  let e = false, t = r.getLayersOfType("transmission"), o = r.getLayersOfType("outline");
  return o.length > 0 && (n.layers.set(8), t.length > 0 && n.layers.enable(3), e = true, li(n), ai(n)), t.length === 0 && o.length === 0 && n.layers.set(0), e;
}
function cg(n, r) {
  if (!r.layers)
    return false;
  let e = false, t = r.getLayersOfType("transmission"), o = r.getLayersOfType("outline");
  return t.length > 0 && (n.layers.set(3), o.length > 0 && n.layers.enable(8), e = true), t.length === 0 && o.length === 0 && n.layers.set(0), e;
}
function dg(n) {
  let r = false;
  return n.traverseEntity((e) => {
    if (e instanceof ir)
      if (Array.isArray(e.material))
        for (let t = 0; t < e.material.length; t++)
          lg(e, e.material[t]) && (r = true);
      else
        lg(e, e.material) && (r = true);
  }), r;
}
function ug(n) {
  let r = false;
  return n.traverseEntity((e) => {
    if (e instanceof ir)
      if (Array.isArray(e.material))
        for (let t = 0; t < e.material.length; t++)
          cg(e, e.material[t]) && (r = true);
      else
        cg(e, e.material) && (r = true);
  }), r;
}
var eA = new Raycaster();
var tA = new Matrix4();
var rA = new Ray();
function pg(n, r, e) {
  let t = n.cloner;
  if (t)
    for (let o of t.children) {
      let i = tA.copy(o.matrixWorld).invert(), s = rA.copy(r.ray).applyMatrix4(i), l = n.matrixWorld;
      s.applyMatrix4(l);
      let c = eA;
      c.set(s.origin, s.direction), c.near = r.near, c.far = r.far, c.intersectObject(n, false).length > 0 && e.push({ object: n });
    }
}
var Vl = class {
  constructor() {
    this._constraints = /* @__PURE__ */ new Map();
  }
  setConstraint(r, e) {
    e === null ? this._constraints.delete(r) : this._constraints.set(r, e);
  }
  removeDependencies(r) {
    this._constraints.delete(r);
  }
  applyConstraints(r) {
    let e = /* @__PURE__ */ new Set();
    this._constraints.forEach((t, o) => {
      let i = [o, t], s = t;
      for (; this._constraints.has(s); )
        s = this._constraints.get(s), e.has(s) || i.push(s);
      for (let l = i.length - 2; l >= 0; l--)
        if (!e.has(i[l])) {
          let c = r.find(i[l]);
          c ? c.applyPathSnapping(r) : console.warn(`missing entity ${i[l]}`), e.add(i[l]);
        }
    });
  }
  findDependency(r, e) {
    let t = r;
    for (; this._constraints.has(t); )
      if (t = this._constraints.get(t), t === e)
        return true;
    return false;
  }
};
var cA = new MeshBasicMaterial();
cA.wireframe = true;
var fg = new Vector3();
var Jd = class extends Scene {
  constructor(e, t) {
    super();
    this.data = e;
    this.backupFog = new Fog(16777215, 0.1, 2e3);
    this.fogUseBGColor = false;
    this.enableHelpers = false;
    this.wireframeState = false;
    this.needsTransmissionDirty = true;
    this.needsNormalDirty = true;
    this._needsTransmission = false;
    this._needsNormal = false;
    this.geometryCacheChanged = false;
    this.bgColor = new $e(1, 1, 1, 1);
    this.entityByUuid = {};
    this.entityIdentityToEntity = {};
    this.toExpandCloner = /* @__PURE__ */ new Set();
    this.toUpdateCloner = /* @__PURE__ */ new Set();
    this.pendingCommands = [];
    this.pathConstraints = new Vl();
    this.needsRecomputeInstances = false;
    this.ambientLight = new HemisphereLight(13882323, 8553090, 0.75), this.ambientLight.name = "Default Ambient Light", this.ambientLight.layers.enable(3), this.personalCamera = this.createPersonalCamera(), this.activeCamera = this.personalCamera, this.postprocessing = e.postprocessing, this.init(e, t), this.matrixAutoUpdate = false;
  }
  markGeometryCacheDirty() {
    this.geometryCacheChanged = true;
  }
  markNeedsUpdateRendererDirty() {
    this.needsTransmissionDirty = true, this.needsNormalDirty = true;
  }
  needsTransmission() {
    return this.needsTransmissionDirty && (this._needsTransmission = ug(this), this.needsTransmissionDirty = false), this._needsTransmission;
  }
  needsNormal() {
    return this.needsNormalDirty && (this._needsNormal = dg(this), this.needsNormalDirty = false), this._needsNormal;
  }
  registerInstanceAndSetUuid(e) {
    let t = e.identity.join("-"), o = this.entityIdentityToEntity[t];
    o && (e.uuid = o.uuid), this.entityIdentityToEntity[t] = e, this.entityByUuid[e.uuid] = e;
  }
  findInstance(e) {
    return this.entityIdentityToEntity[e.join("-")];
  }
  getWithSortKey(e) {
    let t = this.find(e);
    if (t === void 0)
      return;
    let o = [], i = t;
    for (; i !== this; ) {
      let s = i;
      i = i.parent;
      let l = i.children.indexOf(s);
      o.splice(0, 0, l);
    }
    return { entity: t, sortKey: o };
  }
  getAllSorted(e) {
    let t = [];
    for (let o of e) {
      let i = this.getWithSortKey(o.id);
      i !== void 0 && t.push(i);
    }
    return t.sort((o, i) => Hu(o.sortKey, i.sortKey)), t.map((o) => o.entity);
  }
  nonExistOrDescendantOf(e, t) {
    let o = this.find(e);
    if (o === void 0)
      return true;
    for (; o; ) {
      if (o.uuid === t)
        return true;
      o = o.parent;
    }
    return false;
  }
  find(e) {
    if (e === "" || e === void 0)
      return;
    let t = this.entityByUuid[e];
    return t === void 0 ? this.getObjectByProperty("uuid", e) : t;
  }
  debugEnsureEntity(e) {
    let t = this.find(e);
    if (t) {
      if (Array.isArray(t.identity) && this.findInstance(t.identity) === void 0) {
        console.error("not found instance");
        debugger;
      }
    } else {
      console.error("not found");
      debugger;
    }
  }
  addPendingExpandCloner(e) {
    this.toExpandCloner.add(e);
  }
  addPendingUpdateCloner(e) {
    this.toUpdateCloner.add(e);
  }
  markToExpandCloner(e) {
    this.toExpandCloner.add(e), e.traverseEntityAncestors((t) => {
      this.toExpandCloner.add(t);
    });
  }
  doPendingExpandCloner() {
    this.toExpandCloner.forEach((e) => {
      e.expandCloner(this);
    }), this.toExpandCloner.clear();
  }
  doPendingUpdateCloner() {
    this.toUpdateCloner.forEach((e) => {
      var _a2;
      (_a2 = e.cloner) == null ? void 0 : _a2.update();
    }), this.toUpdateCloner.clear();
  }
  doPendingUpdates() {
    this.doPendingExpandCloner(), this.doPendingUpdateCloner(), this.applyPendingCommands();
  }
  addPendingCommand(e) {
    this.pendingCommands.push(e);
  }
  applyPendingCommands() {
    this.pendingCommands.forEach((e) => e()), this.pendingCommands.length = 0;
  }
  updateTreeByOp(e, t) {
    var _a2;
    if (e.path.length === 0 && e.type === 7) {
      let o = e.parent === null ? this : this.find(e.parent);
      if (o === void 0)
        throw new Error("unexpected");
      let i = this.createObject(e.id, e.data, e.children, o, e.localIndex, t);
      i.updateVisible(), i.resetBBoxNeedsUpdate(), Os(i) && As(i.parent) && (i.invalidateUpstreamBooleanData(), i.parent.invalidateDownstreamBooleanData().recomputeBoolean()), this.markNeedsRecomputeInstancesForAncessors(o), this.markNeedsRecomputeInstancesForChildren(i), this.markToExpandCloner(i);
    } else if (e.path.length === 0 && e.type === 8) {
      let o = this.find(e.id);
      if (o === void 0)
        throw new Error("unexpected");
      this.markToExpandCloner(o), o.resetBBoxNeedsUpdate(), this.unregisterObject(o);
      let i = o.parent;
      this.markNeedsRecomputeInstancesForAncessors(i), this.markNeedsRecomputeInstancesForChildren(o), o.parent.remove(o), As(o.parent) && (o.parent.invalidateUpstreamBooleanData(), o.parent.invalidateDownstreamBooleanData().recomputeBoolean()), Os(o) && (o.freeBooleanPointer(), i instanceof Wt && i.invalidateDownstreamBooleanData().recomputeBoolean()), o instanceof gi && o.detachShape(), this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(o), this.pathConstraints.removeDependencies(o.uuid);
    } else if (e.path.length === 0 && e.type === 9) {
      let o = this.find(e.id);
      if (o === void 0)
        throw new Error("unexpected");
      this.markNeedsRecomputeInstancesForChildren(o);
      let i = o.parent;
      this.markNeedsRecomputeInstancesForAncessors(i), (_a2 = o.cloner) == null ? void 0 : _a2.resetOnMove(), this.markToExpandCloner(o);
      let s = e.parent === null ? this : this.find(e.parent);
      if (s === void 0)
        throw new Error("unexpected");
      s.add(o), this.markNeedsRecomputeInstancesForAncessors(s), this.markToExpandCloner(o), o.invalidateClonerTransform(o), o.updateVisible(), o.resetBBoxNeedsUpdate();
      let l = e.localIndex;
      s.children.splice(l, 0, s.children.pop()), Os(o) && (o.invalidateUpstreamBooleanData(), As(o.parent) ? o.parent.invalidateDownstreamBooleanData().recomputeBoolean() : i instanceof Wt && i.invalidateDownstreamBooleanData().recomputeBoolean());
    }
    this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
  }
  updateEntityByOp(e, t, o, i) {
    if (t.type === 0) {
      if (("overrides" in t.props || "component" in t.props) && this.markNeedsRecomputeInstances(), t.path.includes("overrides") && "states" in t.props) {
        let { states: l, rest: c } = t.props;
        t = { ...t, props: c }, this.markNeedsRecomputeInstances();
      }
      t.path[0] === "pathSnapping" && t.props.pathId !== void 0 && this.pathConstraints.setConstraint(e, t.props.pathId);
    }
    let s = this.find(e);
    if (s)
      try {
        ag(s, t, o, { scene: this, shared: i }), s instanceof lt && s.updateGeometryGroupsIfNeeded();
      } catch (l) {
        console.error(l);
      }
  }
  get enableFog() {
    return this.fog !== null;
  }
  set enableFog(e) {
    this.fog = e === true ? this.backupFog : null;
  }
  init(e, t) {
    if (this.createChildrenObjects(e.objects, this, t), this.personalCamera.removeFromParent(), this.add(this.personalCamera), this.ambientLight.removeFromParent(), this.add(this.ambientLight), this.setBackgroundColor(ht(e.backgroundColor, t)), this.updateFog(e.fog, t), this.updateAmbientLight(e.environment.ambientLight, t), this.activeCamera = this.personalCamera, e.publish.playCamera !== null) {
      let o = this.find(e.publish.playCamera);
      o instanceof Wr && this.switchActiveCamera(o);
    }
    this.expandInstances(t, true), this.traverseEntity((o) => {
      As(o) && o.recomputeBoolean();
    }), this.doPendingExpandCloner(), this.applyPendingCommands();
  }
  markNeedsRecomputeInstances() {
    this.needsRecomputeInstances = true;
  }
  markNeedsRecomputeInstancesForChildren(e) {
    e.traverseEntity((t) => {
      (t.data.type === "Component" || t.data.type === "Instance") && this.markNeedsRecomputeInstances();
    });
  }
  markNeedsRecomputeInstancesForAncessors(e) {
    Ce.is(e) && (e.data.type === "Component" && this.markNeedsRecomputeInstances(), e.traverseAncestors((t) => {
      Ce.is(t) && t.data.type === "Component" && this.markNeedsRecomputeInstances();
    }));
  }
  relativeizeInner(e, t, o, i, s, l, c) {
    e && e !== i.uuid && i.find(e) && s.forInstancesRec((a) => {
      a.isInstanceRoot || (a.data = Qo(a.data, (d) => {
        let p = d.events.data(c.id), f = a.goUp(l);
        if (f) {
          let m = [...la(f.identity), e].join("-"), h = this.entityIdentityToEntity[m];
          if (h) {
            let y = h.uuid;
            ut.zoom(p, t)[o] = y;
          } else {
            if (false)
              debugger;
            console.warn("cannot find instance");
          }
        }
      }).data);
    });
  }
  rewriteEventsBeforeGoToPlayMode() {
    this.traverseEntity((e) => {
      if (e instanceof qr && typeof e.identity == "string" && e.data.type === "Component")
        return e.traverseEntity((t, o) => {
          t.data.events.forEach((i) => {
            i.data.type === "GameControl" ? t.forInstancesRec((s) => {
              s.isInstanceRoot || (s.data = Qo(s.data, (l) => {
                l.events.delete(i.id);
              }).data);
            }) : i.data.type === "Conditional" ? (i.data.condition.type === "Distance" ? (this.relativeizeInner(i.data.condition.fromObject, ["condition"], "fromObject", e, t, o, i), this.relativeizeInner(i.data.condition.toObject, ["condition"], "toObject", e, t, o, i)) : i.data.condition.type === "State" ? this.relativeizeInner(i.data.condition.object, ["condition"], "object", e, t, o, i) : i.data.condition.type === "Comparison" && (i.data.condition.lOperand.type === "Property" && this.relativeizeInner(i.data.condition.lOperand.value[0], ["condition", "lOperand", "value"], 0, e, t, o, i), i.data.condition.rOperand.type === "Property" && this.relativeizeInner(i.data.condition.rOperand.value[0], ["condition", "rOperand", "value"], 0, e, t, o, i)), i.data.inActions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["inActions", s.id], "object", e, t, o, i);
            }), i.data.outActions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["outActions", s.id], "object", e, t, o, i);
            })) : "actions" in i.data && i.data.actions.forEach((s) => {
              s.data.type === "Transition" && this.relativeizeInner(s.data.object, ["actions", s.id], "object", e, t, o, i);
            });
          });
        }), true;
    });
  }
  expandInstances(e, t) {
    let o = /* @__PURE__ */ new Set();
    this.traverseEntity((i) => {
      if (i instanceof qr && i.isInstanceRoot)
        return i.expandInstanceChildren({ scene: this, shared: e, pendingDeletes: o }), t || i.resetBBoxNeedsUpdate(), true;
    });
    for (let i of o)
      this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(i), Gl(i);
  }
  recomputeInstances(e) {
    this.needsRecomputeInstances && (this.needsRecomputeInstances = false, this.traverseEntity((t) => {
      t instanceof qr && t.isInstanceRoot && (t.component = void 0);
    }), this.expandInstances(e, false));
  }
  disposeAndUnregisterEntityRecursivelyIfNotReregistered(e) {
    e.traverseEntity((t) => {
      let o = typeof t.identity == "string" ? t.identity : t.identity.join("-");
      this.entityIdentityToEntity[o] === t && (delete this.entityByUuid[t.uuid], delete this.entityIdentityToEntity[o]), t.dispose();
    });
  }
  clearScene() {
    for (let e of this.children)
      Ce.is(e) && e.disposeRecursively();
    this.children.length = 0;
  }
  resetAfterClear(e, t) {
    this.init(e, t);
  }
  createPersonalCamera() {
    let e = new Wr(Jd.PERSONAL_CAMERA_ID, { ...nn.defaultData, name: "Personal Camera" });
    return e.objectHelper.visible = false, this.registerObjectCreatedInLegacy(e), e;
  }
  raycast(e) {
    let t = [], o = (i) => {
      for (let s of i.children) {
        let l = s.cloner;
        Ce.is(s) && !s.raycastLock && (s.visible || (l == null ? void 0 : l.object.data.visible)) && ((Os(s) || Zy(s) && this.enableHelpers && s.objectHelper.visible) && (e.intersectObject(s, false, t), pg(s, e, t)), o(s));
      }
    };
    return o(this), t;
  }
  forEachEntity(e) {
    for (let t of this.children)
      Ce.is(t) && e(t);
  }
  traverseEntity(e) {
    for (let t of this.children)
      Ce.is(t) && t.traverseEntity(e);
  }
  traverseObject(e) {
    for (let t of this.children)
      Di.is(t) && t.traverseObject(e);
  }
  traverseVisibleEntity(e) {
    for (let t of this.children)
      Ce.is(t) && t.visible && t.traverseVisibleEntity(e);
  }
  updateFog(e, t) {
    this.enableFog = e.enabled, this.fogUseBGColor = e.useBackgroundColor, e.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = ht(e.color, t), this.backupFog.near = e.near, this.backupFog.far = e.far;
  }
  dispose() {
    this.clearScene();
  }
  updateAmbientLight(e, t) {
    e.color !== void 0 && (this.ambientLight.color = ht(e.color, t)), e.intensity !== void 0 && (this.ambientLight.intensity = e.intensity), e.groundColor !== void 0 && (this.ambientLight.groundColor = ht(e.groundColor, t)), e.enabled !== void 0 && (this.ambientLight.visible = e.enabled);
  }
  switchActiveCamera(e) {
    this.activeCamera !== this.personalCamera && (this.activeCamera.objectHelper.visible = true), this.activeCamera = e, e.objectHelper.visible = false;
  }
  setBackgroundColor(e) {
    this.bgColor = e, this.fogUseBGColor === true && (this.backupFog.color = e);
  }
  createChildrenObjects(e, t, o) {
    let i = 0;
    for (let s of e)
      this.createObject(s.id, s.data, s.children, t, i, o), i += 1;
  }
  registerObjectCreatedInLegacy(e) {
    this.entityByUuid[e.uuid] = e;
  }
  unregisterObject(e) {
    delete this.entityByUuid[e.uuid];
    for (let t of e.children)
      this.unregisterObject(t);
  }
  createObject(e, t, o, i, s, l) {
    var _a2;
    let c = { scene: this, shared: l }, u = Rl(e, t, c);
    return u && (this.entityByUuid[e] = u, i.add(u), i.children.splice(s, 0, i.children.pop()), o.length > 0 && (u.isInstanceRoot ? console.error("instance should not have children!") : this.createChildrenObjects(o, u, l)), u.updateState(t, c), u instanceof lt && u.updateGeometryGroupsIfNeeded(), u.updateVisible(), u.cloner && this.toExpandCloner.add(u), ((_a2 = t.pathSnapping) == null ? void 0 : _a2.pathId) && this.pathConstraints.setConstraint(e, t.pathSnapping.pathId)), u;
  }
  getCenter(e) {
    let t = [];
    for (let i = 0, s = e.length; i < s; ++i) {
      let { id: l, recursive: c } = e[i], u = this.find(l), a = c ? u.recursiveBBox : u.singleBBox;
      t.push(...a.vertices);
    }
    let o = new Box3();
    return o.setFromPoints(t), o.getCenter(fg), fg;
  }
  copyMatrixWorld(e, t) {
    if (e === null) {
      t.identity();
      return;
    }
    let o = this.find(e);
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  copyParentMatrixWorld(e, t) {
    var _a2;
    if (e === null) {
      t.identity();
      return;
    }
    let o = (_a2 = this.find(e)) == null ? void 0 : _a2.parent;
    o ? t.copy(o.matrixWorld) : t.identity();
  }
  traverseMaterial(e) {
    this.traverseEntity((t) => {
      if (t instanceof it)
        if (Array.isArray(t.material))
          for (let o = 0; o < t.material.length; o++)
            t.material[o] instanceof It && e(t.material[o]);
        else
          t.material instanceof It && e(t.material);
    });
  }
  updateCanvasSize(e, t) {
    this.activeCamera.setViewplaneSize(e, t);
    let o, i;
    e >= t ? (o = t / e, i = 1) : (o = 1, i = e / t), this.traverseMaterial((s) => {
      s.getLayersOfType("transmission").forEach((c) => {
        c.uniforms[`f${c.id}_aspectRatio`].value.x = o, c.uniforms[`f${c.id}_aspectRatio`].value.y = i;
      });
    });
  }
};
var Es = Jd;
Es.PERSONAL_CAMERA_ID = "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";
var yo;
function uA() {
  return yo || (yo = new DRACOLoader(), yo.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()), yo.decoderPending;
}
async function pA(n) {
  if (yo) {
    let r = { attributeIDs: yo.defaultAttributeIDs, attributeTypes: yo.defaultAttributeTypes, useUniqueIDs: false }, e;
    try {
      e = await yo.decodeGeometry(new Int8Array(n).buffer, r);
    } catch (t) {
      console.error(t);
    }
    if (e)
      return { index: e.index ? { array: e.index.array } : void 0, attributes: Object.entries(e.attributes).map(([t, o]) => ({ name: t, itemSize: o.itemSize, array: o.array })) };
  }
  return null;
}
async function mg(n, r) {
  let [e, t] = Xl(Qs.deserialize(new Uint8Array(n)));
  wm(e);
  let o = [];
  e.scene.objects.traverse((i, s) => {
    s.type === "Mesh" && s.geometry.type === "NonParametricGeometry" && s.geometry.data.draco !== void 0 && o.push(s);
  }), o.length && await uA();
  for (let i of o) {
    let s = await pA(Ye(i.geometry.data.draco));
    if (s) {
      s.index && (i.geometry.data.index = { array: s.index.array, itemSize: 1, normalized: false, type: "Uint32Array" });
      let l = {};
      s.attributes.forEach(({ name: c, array: u, itemSize: a }) => {
        l[c] = { array: u, itemSize: a, type: "Float32Array", normalized: false };
      }), i.geometry.data.attributes = l, i.geometry.data.draco = void 0;
    }
  }
  return r && r(e), t.result().data;
}
function hg(n) {
  let r;
  if (!!n.index)
    for (let e = 0; e < n.index.array.length; e += 3)
      r = n.index.array[e], n.index.array[e] = n.index.array[e + 2], n.index.array[e + 2] = r;
}
function gg(n) {
  let r = /* @__PURE__ */ new Set();
  return n.traverse((e) => {
    if (e instanceof ir)
      if (Ve(e.material))
        e.material.forEach((t) => {
          let o = t;
          r.has(o) || r.add(o);
        });
      else {
        let t = e.material;
        r.has(t) || r.add(t);
      }
  }), r.forEach((e) => {
    if (e instanceof Array)
      return;
    let t = e.onBeforeCompile.bind(e);
    if (mA(e)) {
      Object.assign(e, { isMeshStandardMaterial: true, isMeshPhysicalMaterial: true, transmission: 1, attenuationColor: new Color(), specularColor: new Color() });
      let o = 0;
      e.onBeforeCompile = (i, s) => {
        t && t(i, s), i.uniforms = Object.assign({}, ShaderLib.physical.uniforms, i.uniforms), e.getLayersOfType("transmission").forEach((l) => {
          if (i.uniforms.transmissionSamplerMap.value) {
            let c = l.color;
            c && (c.transmissionSamplerMap.value = i.uniforms.transmissionSamplerMap.value, c.transmissionSamplerSize.value = i.uniforms.transmissionSamplerSize.value);
          } else
            o++, o < 2 && (e.needsUpdate = true);
        });
      };
    } else
      hA(e) || (e.onBeforeCompile = (o, i) => {
        t && t(o, i), e.transparent = false;
      });
  }), n;
}
function mA(n) {
  return n.getLayersOfType("transmission").length > 0;
}
function hA(n) {
  let r = 0;
  return n.layers.forEach((e) => {
    if (e.type !== "light" && e.type !== "fresnel") {
      let t = e.uniforms["f" + e.id + "_alpha"];
      t && (r += (1 - r) * t.value);
    }
  }), r < 1;
}
function xg(n) {
  return n.traverse((r) => {
    if (r.type === "Camera") {
      let e = r;
      e.type = e.cameraType;
    }
  }), n;
}
function vg(n) {
  let r = [], e = (t, o = 0) => {
    let i = o > 0 ? t + o : t;
    return r.includes(i) ? e(t, o + 1) : i;
  };
  return n.traverse((t) => {
    if (r.includes(t.name)) {
      let o = t.name, i = e(t.name);
      if (t.name = i, t.isMesh) {
        let s = t;
        s.material instanceof Array ? s.material.forEach((l) => {
          l.name = l.name.replace(o, i);
        }) : s.material.isAsset || (s.material.name = s.material.name.replace(o, i));
      }
    }
    r.push(t.name);
  }), n;
}
function bg(n) {
  let r = [];
  return n.traverse((e) => {
    e instanceof pi && r.push(e);
  }), r.forEach((e) => {
    let t = e.object, i = e.children.map((l) => {
      l.updateMatrix();
      let c = l.geometry.clone().applyMatrix4(l.matrix);
      return l.matrix.determinant() < 0 && hg(c), c;
    }), s = mergeBufferGeometries(e.parameters.hideBase ? i : [t instanceof it ? t.geometry : [], ...i]);
    t instanceof it && (t.geometry = s), e.removeFromParent(), t.setFromClonerState(null, { scene: n, shared: Sy });
  }), n;
}
function Sg(n) {
  return n.traverse((r) => {
    r.matrixAutoUpdate = true;
  }), n;
}
function wg(n) {
  Object.values(n.shared.materials).forEach((r) => {
    eu(r);
  }), n.scene.objects.traverse((r, e) => {
    "material" in e ? eu(e.material) : "materials" in e && e.materials.forEach((t) => {
      eu(t);
    });
  });
}
function eu(n) {
  if (typeof n == "string")
    return;
  let r = [];
  n.layers.forEach((e, t) => {
    e.type === "outline" && r.push(t);
  }), r.reverse().forEach((e) => {
    n.layers.delete(e);
  }), r.length && console.warn("The Spline Loader currently does not support the outline layer.");
}
var Og = Bs(Tg(), 1);
var Pg = "The SplineLoader only accepts .splinecode files that are generated from Spline export panel.";
var tu = class extends Loader {
  load(r, e, t, o = console.error) {
    let i = new FileLoader(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), r.endsWith(".spline") ? console.warn(Pg + " The .spline files are only meant to be used by the Editor.") : r.endsWith(".splinecode") || console.warn(Pg), i.load(r, async (s) => {
      try {
        if (typeof s == "string")
          throw new Error("The .spline file is not binary!");
        let l = await this.parse(s);
        e(l);
      } catch (l) {
        o(l);
      }
    }, t, o);
  }
  async parse(r) {
    let e = await mg(r, wg);
    e.version && (0, Og.default)(e.version, "0.9.269") > 0 && console.warn("Your .splinecode file is more recent than the library. Please upgrade @splinetool/loader to the latest version."), await Promise.all([Ty(e) && Uh(), Dy(e) && vy()].filter(Boolean));
    let t = new Vo(e.shared);
    Object.values(t.getMaterials()).forEach((s) => Object.assign(s, { isAsset: true }));
    let o = new Es(e.scene, t);
    o.remove(o.personalCamera), e.scene.environment.ambientLight.enabled || o.remove(o.ambientLight);
    let i = e.scene.publish.playCamera;
    if (i) {
      let s = o.find(i);
      s && Ky(s) && Object.assign(s, { makeDefault: true });
    }
    return o = bg(o), o = gg(o), o = xg(o), o = vg(o), o = Sg(o), o;
  }
};

// node_modules/@splinetool/r3f-spline/dist/useSpline.es.js
function useSpline(url) {
  const scene = useLoader(tu, url);
  return useGraph(scene);
}
export {
  useSpline as default
};
//# sourceMappingURL=@splinetool_r3f-spline.js.map
